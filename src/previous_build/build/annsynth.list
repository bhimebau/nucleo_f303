
build/annsynth.elf:     file format elf32-littlearm


Disassembly of section .text:

080001a0 <main>:
  DAC_DHRM_12BIT_RIGHT,
  0
};


int main(void) {
 80001a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80001a4:	f5ad 7d0b 	sub.w	sp, sp, #556	; 0x22c
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 80001a8:	f001 fe72 	bl	8001e90 <halInit>
  driversInit();
 80001ac:	f003 fcd0 	bl	8003b50 <driversInit>
  chSysInit();
 80001b0:	f000 fee6 	bl	8000f80 <chSysInit>
  
  for (i=0;i<IDS;i++) {
    hiddenin[i] = (float) i + 2.5;
    hidden_weights[i] = (float) i + 4.786;
 80001b4:	ed9f 6a70 	vldr	s12, [pc, #448]	; 8000378 <__fini_array_end+0x1d8>
 80001b8:	a929      	add	r1, sp, #164	; 0xa4
 80001ba:	aa09      	add	r2, sp, #36	; 0x24
   */
  halInit();
  driversInit();
  chSysInit();
  
  for (i=0;i<IDS;i++) {
 80001bc:	2300      	movs	r3, #0
    hiddenin[i] = (float) i + 2.5;
 80001be:	eef0 6a04 	vmov.f32	s13, #4
 80001c2:	ee07 3a90 	vmov	s15, r3
 80001c6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   */
  halInit();
  driversInit();
  chSysInit();
  
  for (i=0;i<IDS;i++) {
 80001ca:	3301      	adds	r3, #1
    hiddenin[i] = (float) i + 2.5;
 80001cc:	ee37 7aa6 	vadd.f32	s14, s15, s13
    hidden_weights[i] = (float) i + 4.786;
 80001d0:	ee77 7a86 	vadd.f32	s15, s15, s12
  halInit();
  driversInit();
  chSysInit();
  
  for (i=0;i<IDS;i++) {
    hiddenin[i] = (float) i + 2.5;
 80001d4:	eebd 7ac7 	vcvt.s32.f32	s14, s14
    hidden_weights[i] = (float) i + 4.786;
 80001d8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  halInit();
  driversInit();
  chSysInit();
  
  for (i=0;i<IDS;i++) {
    hiddenin[i] = (float) i + 2.5;
 80001dc:	ee17 0a10 	vmov	r0, s14
 80001e0:	f842 0f04 	str.w	r0, [r2, #4]!
    hidden_weights[i] = (float) i + 4.786;
 80001e4:	ee17 0a90 	vmov	r0, s15
   */
  halInit();
  driversInit();
  chSysInit();
  
  for (i=0;i<IDS;i++) {
 80001e8:	2b20      	cmp	r3, #32
    hiddenin[i] = (float) i + 2.5;
    hidden_weights[i] = (float) i + 4.786;
 80001ea:	f841 0f04 	str.w	r0, [r1, #4]!
   */
  halInit();
  driversInit();
  chSysInit();
  
  for (i=0;i<IDS;i++) {
 80001ee:	d1e8      	bne.n	80001c2 <main+0x22>
    hiddenin[i] = (float) i + 2.5;
    hidden_weights[i] = (float) i + 4.786;
  }
  for (i=0;i<HDS;i++) {
    outin[i] = (float) i + 2.5;
    out_weights[i] = (float) i + 4.786;
 80001f0:	ed9f 6a61 	vldr	s12, [pc, #388]	; 8000378 <__fini_array_end+0x1d8>
 80001f4:	a949      	add	r1, sp, #292	; 0x124
 80001f6:	aa69      	add	r2, sp, #420	; 0x1a4
   */
  halInit();
  driversInit();
  chSysInit();
  
  for (i=0;i<IDS;i++) {
 80001f8:	2300      	movs	r3, #0
    hiddenin[i] = (float) i + 2.5;
    hidden_weights[i] = (float) i + 4.786;
  }
  for (i=0;i<HDS;i++) {
    outin[i] = (float) i + 2.5;
 80001fa:	eef0 6a04 	vmov.f32	s13, #4
 80001fe:	ee07 3a90 	vmov	s15, r3
 8000202:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  
  for (i=0;i<IDS;i++) {
    hiddenin[i] = (float) i + 2.5;
    hidden_weights[i] = (float) i + 4.786;
  }
  for (i=0;i<HDS;i++) {
 8000206:	3301      	adds	r3, #1
    outin[i] = (float) i + 2.5;
 8000208:	ee37 7aa6 	vadd.f32	s14, s15, s13
    out_weights[i] = (float) i + 4.786;
 800020c:	ee77 7a86 	vadd.f32	s15, s15, s12
  for (i=0;i<IDS;i++) {
    hiddenin[i] = (float) i + 2.5;
    hidden_weights[i] = (float) i + 4.786;
  }
  for (i=0;i<HDS;i++) {
    outin[i] = (float) i + 2.5;
 8000210:	eebd 7ac7 	vcvt.s32.f32	s14, s14
    out_weights[i] = (float) i + 4.786;
 8000214:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  for (i=0;i<IDS;i++) {
    hiddenin[i] = (float) i + 2.5;
    hidden_weights[i] = (float) i + 4.786;
  }
  for (i=0;i<HDS;i++) {
    outin[i] = (float) i + 2.5;
 8000218:	ee17 0a10 	vmov	r0, s14
 800021c:	f841 0f04 	str.w	r0, [r1, #4]!
    out_weights[i] = (float) i + 4.786;
 8000220:	ee17 0a90 	vmov	r0, s15
  
  for (i=0;i<IDS;i++) {
    hiddenin[i] = (float) i + 2.5;
    hidden_weights[i] = (float) i + 4.786;
  }
  for (i=0;i<HDS;i++) {
 8000224:	2b20      	cmp	r3, #32
    outin[i] = (float) i + 2.5;
    out_weights[i] = (float) i + 4.786;
 8000226:	f842 0f04 	str.w	r0, [r2, #4]!
  
  for (i=0;i<IDS;i++) {
    hiddenin[i] = (float) i + 2.5;
    hidden_weights[i] = (float) i + 4.786;
  }
  for (i=0;i<HDS;i++) {
 800022a:	d1e8      	bne.n	80001fe <main+0x5e>
    outin[i] = (float) i + 2.5;
    out_weights[i] = (float) i + 4.786;
  }
  palSetPad(GPIOE, GPIOE_LED5_ORANGE);
 800022c:	4a53      	ldr	r2, [pc, #332]	; (800037c <__fini_array_end+0x1dc>)
 800022e:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000232:	ab29      	add	r3, sp, #164	; 0xa4
 8000234:	8311      	strh	r1, [r2, #24]
 8000236:	ad0a      	add	r5, sp, #40	; 0x28
  
  // Sample/Hold
  for (i=HDS-1;i>0;i--) {
    hiddenin[i] = hiddenin[i-1];
 8000238:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 800023c:	605a      	str	r2, [r3, #4]
    out_weights[i] = (float) i + 4.786;
  }
  palSetPad(GPIOE, GPIOE_LED5_ORANGE);
  
  // Sample/Hold
  for (i=HDS-1;i>0;i--) {
 800023e:	42ab      	cmp	r3, r5
 8000240:	d1fa      	bne.n	8000238 <main+0x98>
    hiddenin[i] = hiddenin[i-1];
  }
  hiddenin[0] = 3.546;
 8000242:	2403      	movs	r4, #3
  
  // Input Scaling 
  arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
 8000244:	a92a      	add	r1, sp, #168	; 0xa8
 8000246:	ab02      	add	r3, sp, #8
 8000248:	4628      	mov	r0, r5
 800024a:	2220      	movs	r2, #32
  
  // Sample/Hold
  for (i=HDS-1;i>0;i--) {
    hiddenin[i] = hiddenin[i-1];
  }
  hiddenin[0] = 3.546;
 800024c:	602c      	str	r4, [r5, #0]
  
  // Hidden Inputs 
  for (i=0;i<HDS;i++) {
    arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
    if (result > 1) result = 1;
    if (result < 0) result = 0;
 800024e:	f04f 0800 	mov.w	r8, #0
    hiddenin[i] = hiddenin[i-1];
  }
  hiddenin[0] = 3.546;
  
  // Input Scaling 
  arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
 8000252:	f004 fcd5 	bl	8004c00 <arm_dot_prod_q31>
 8000256:	2420      	movs	r4, #32
  
  // Hidden Inputs 
  for (i=0;i<HDS;i++) {
    arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
    if (result > 1) result = 1;
    if (result < 0) result = 0;
 8000258:	f04f 0900 	mov.w	r9, #0
  arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
  
  // Hidden Inputs 
  for (i=0;i<HDS;i++) {
    arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
    if (result > 1) result = 1;
 800025c:	2601      	movs	r6, #1
 800025e:	2700      	movs	r7, #0
 8000260:	e003      	b.n	800026a <main+0xca>
 8000262:	e9cd 6702 	strd	r6, r7, [sp, #8]
  
  // Input Scaling 
  arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
  
  // Hidden Inputs 
  for (i=0;i<HDS;i++) {
 8000266:	3c01      	subs	r4, #1
 8000268:	d013      	beq.n	8000292 <main+0xf2>
    arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
 800026a:	a92a      	add	r1, sp, #168	; 0xa8
 800026c:	2220      	movs	r2, #32
 800026e:	ab02      	add	r3, sp, #8
 8000270:	4628      	mov	r0, r5
 8000272:	f004 fcc5 	bl	8004c00 <arm_dot_prod_q31>
    if (result > 1) result = 1;
 8000276:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800027a:	2a02      	cmp	r2, #2
 800027c:	f173 0100 	sbcs.w	r1, r3, #0
 8000280:	daef      	bge.n	8000262 <main+0xc2>
    if (result < 0) result = 0;
 8000282:	2a00      	cmp	r2, #0
 8000284:	f173 0300 	sbcs.w	r3, r3, #0
 8000288:	daed      	bge.n	8000266 <main+0xc6>
  
  // Input Scaling 
  arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
  
  // Hidden Inputs 
  for (i=0;i<HDS;i++) {
 800028a:	3c01      	subs	r4, #1
    arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
    if (result > 1) result = 1;
    if (result < 0) result = 0;
 800028c:	e9cd 8902 	strd	r8, r9, [sp, #8]
  
  // Input Scaling 
  arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
  
  // Hidden Inputs 
  for (i=0;i<HDS;i++) {
 8000290:	d1eb      	bne.n	800026a <main+0xca>
 8000292:	2408      	movs	r4, #8
    arm_dot_prod_q31(outin,out_weights,HDS,&result);
    if (result > 1) {
      result = 1;
    }
    else if (result < 0) {
      result = 0;
 8000294:	f04f 0800 	mov.w	r8, #0
 8000298:	f04f 0900 	mov.w	r9, #0
    if (result < 0) result = 0;
  }
  for (i=0;i<ODS;i++) {
    arm_dot_prod_q31(outin,out_weights,HDS,&result);
    if (result > 1) {
      result = 1;
 800029c:	2601      	movs	r6, #1
 800029e:	2700      	movs	r7, #0
 80002a0:	e003      	b.n	80002aa <main+0x10a>
 80002a2:	e9cd 6702 	strd	r6, r7, [sp, #8]
  for (i=0;i<HDS;i++) {
    arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
    if (result > 1) result = 1;
    if (result < 0) result = 0;
  }
  for (i=0;i<ODS;i++) {
 80002a6:	3c01      	subs	r4, #1
 80002a8:	d013      	beq.n	80002d2 <main+0x132>
    arm_dot_prod_q31(outin,out_weights,HDS,&result);
 80002aa:	a96a      	add	r1, sp, #424	; 0x1a8
 80002ac:	2220      	movs	r2, #32
 80002ae:	ab02      	add	r3, sp, #8
 80002b0:	a84a      	add	r0, sp, #296	; 0x128
 80002b2:	f004 fca5 	bl	8004c00 <arm_dot_prod_q31>
    if (result > 1) {
 80002b6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002ba:	2a02      	cmp	r2, #2
 80002bc:	f173 0100 	sbcs.w	r1, r3, #0
 80002c0:	daef      	bge.n	80002a2 <main+0x102>
      result = 1;
    }
    else if (result < 0) {
 80002c2:	2a00      	cmp	r2, #0
 80002c4:	f173 0300 	sbcs.w	r3, r3, #0
 80002c8:	daed      	bge.n	80002a6 <main+0x106>
  for (i=0;i<HDS;i++) {
    arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
    if (result > 1) result = 1;
    if (result < 0) result = 0;
  }
  for (i=0;i<ODS;i++) {
 80002ca:	3c01      	subs	r4, #1
    arm_dot_prod_q31(outin,out_weights,HDS,&result);
    if (result > 1) {
      result = 1;
    }
    else if (result < 0) {
      result = 0;
 80002cc:	e9cd 8902 	strd	r8, r9, [sp, #8]
  for (i=0;i<HDS;i++) {
    arm_dot_prod_q31(hiddenin,hidden_weights,IDS,&result);
    if (result > 1) result = 1;
    if (result < 0) result = 0;
  }
  for (i=0;i<ODS;i++) {
 80002d0:	d1eb      	bne.n	80002aa <main+0x10a>
    }
    else if (result < 0) {
      result = 0;
    }
  }
  palClearPad(GPIOE, GPIOE_LED5_ORANGE);
 80002d2:	4b2a      	ldr	r3, [pc, #168]	; (800037c <__fini_array_end+0x1dc>)
  
  dacStart(&DACD1, &daccfg1);
 80002d4:	482a      	ldr	r0, [pc, #168]	; (8000380 <__fini_array_end+0x1e0>)
 80002d6:	492b      	ldr	r1, [pc, #172]	; (8000384 <__fini_array_end+0x1e4>)
    }
    else if (result < 0) {
      result = 0;
    }
  }
  palClearPad(GPIOE, GPIOE_LED5_ORANGE);
 80002d8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80002dc:	835a      	strh	r2, [r3, #26]
  
  dacStart(&DACD1, &daccfg1);
 80002de:	f003 fc4f 	bl	8003b80 <dacStart>
    
    /*
     * Activates the serial driver 1 using the driver default configuration.
   * PC4(RX) and PC5(TX). The default baud rate is 9600.
   */
  sdStart(&SD1, NULL);
 80002e2:	4829      	ldr	r0, [pc, #164]	; (8000388 <__fini_array_end+0x1e8>)
 80002e4:	4621      	mov	r1, r4
 80002e6:	f001 febb 	bl	8002060 <sdStart>
  palSetPadMode(GPIOC, 4, PAL_MODE_ALTERNATE(7));
 80002ea:	4828      	ldr	r0, [pc, #160]	; (800038c <__fini_array_end+0x1ec>)
 80002ec:	2110      	movs	r1, #16
 80002ee:	f240 3282 	movw	r2, #898	; 0x382
 80002f2:	f002 fe65 	bl	8002fc0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOC, 5, PAL_MODE_ALTERNATE(7));
 80002f6:	f240 3282 	movw	r2, #898	; 0x382
 80002fa:	4824      	ldr	r0, [pc, #144]	; (800038c <__fini_array_end+0x1ec>)
 80002fc:	2120      	movs	r1, #32
 80002fe:	f002 fe5f 	bl	8002fc0 <_pal_lld_setgroupmode>

  gptStart(&GPTD1, &gpt_adc_config);
 8000302:	4823      	ldr	r0, [pc, #140]	; (8000390 <__fini_array_end+0x1f0>)
 8000304:	4923      	ldr	r1, [pc, #140]	; (8000394 <__fini_array_end+0x1f4>)
 8000306:	f001 fe23 	bl	8001f50 <gptStart>
  // gptStartContinuous(&GPTD1, 227);
  gptStartContinuous(&GPTD1, (int) SAMPLE_PERIOD_US);
 800030a:	4821      	ldr	r0, [pc, #132]	; (8000390 <__fini_array_end+0x1f0>)
 800030c:	21be      	movs	r1, #190	; 0xbe
 800030e:	f001 fe2f 	bl	8001f70 <gptStartContinuous>

  palSetPadMode(GPIOA, 0, PAL_MODE_INPUT_ANALOG); // this is 15th channel
 8000312:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000316:	2101      	movs	r1, #1
 8000318:	2203      	movs	r2, #3
 800031a:	f002 fe51 	bl	8002fc0 <_pal_lld_setgroupmode>
  palSetPadMode(GPIOA, 1, PAL_MODE_INPUT_ANALOG); // this is 10th channel
 800031e:	2203      	movs	r2, #3
 8000320:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000324:	2102      	movs	r1, #2
 8000326:	f002 fe4b 	bl	8002fc0 <_pal_lld_setgroupmode>
  adcStart(&ADCD1, &adccfg);
 800032a:	481b      	ldr	r0, [pc, #108]	; (8000398 <__fini_array_end+0x1f8>)
 800032c:	491b      	ldr	r1, [pc, #108]	; (800039c <__fini_array_end+0x1fc>)
 800032e:	f001 fddf 	bl	8001ef0 <adcStart>

  // chprintf((BaseSequentialStream*)&SD1, "\n\rUp and Running %s\n\r", convFloat(afloat,max/2));
  /* print_arch(&ann); */
  /* Initialize the command shell */ 
  shellInit();
 8000332:	f003 fd95 	bl	8003e60 <shellInit>
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventflags_t events) {

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8000336:	f04f 33ff 	mov.w	r3, #4294967295
 800033a:	4819      	ldr	r0, [pc, #100]	; (80003a0 <__fini_array_end+0x200>)
 800033c:	a905      	add	r1, sp, #20
 800033e:	2201      	movs	r2, #1
 8000340:	f001 faf6 	bl	8001930 <chEvtRegisterMaskWithFlags>
  /* 
   *  setup to listen for the shell_terminated event. This setup will be stored in the tel  * event listner structure in item 0
   */
  chEvtRegister(&shell_terminated, &tel, 0);

  shelltp1 = shellCreate(&shell_cfg1, sizeof(waShell), NORMALPRIO);
 8000344:	f44f 6115 	mov.w	r1, #2384	; 0x950
 8000348:	2240      	movs	r2, #64	; 0x40
 800034a:	4816      	ldr	r0, [pc, #88]	; (80003a4 <__fini_array_end+0x204>)
 800034c:	f003 fda0 	bl	8003e90 <shellCreate>
 8000350:	4b15      	ldr	r3, [pc, #84]	; (80003a8 <__fini_array_end+0x208>)
  chThdCreateStatic(waCounterThread, sizeof(waCounterThread), NORMALPRIO+1, counterThread, NULL);
 8000352:	9400      	str	r4, [sp, #0]
 8000354:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
  /* 
   *  setup to listen for the shell_terminated event. This setup will be stored in the tel  * event listner structure in item 0
   */
  chEvtRegister(&shell_terminated, &tel, 0);

  shelltp1 = shellCreate(&shell_cfg1, sizeof(waShell), NORMALPRIO);
 8000358:	6018      	str	r0, [r3, #0]
  chThdCreateStatic(waCounterThread, sizeof(waCounterThread), NORMALPRIO+1, counterThread, NULL);
 800035a:	2241      	movs	r2, #65	; 0x41
 800035c:	4813      	ldr	r0, [pc, #76]	; (80003ac <__fini_array_end+0x20c>)
 800035e:	4b14      	ldr	r3, [pc, #80]	; (80003b0 <__fini_array_end+0x210>)
 8000360:	f001 f906 	bl	8001570 <chThdCreateStatic>

  while (TRUE) {
    chEvtDispatch(fhandlers, chEvtWaitOne(ALL_EVENTS));
 8000364:	f04f 30ff 	mov.w	r0, #4294967295
 8000368:	f001 fb4a 	bl	8001a00 <chEvtWaitOne>
 800036c:	4601      	mov	r1, r0
 800036e:	4811      	ldr	r0, [pc, #68]	; (80003b4 <__fini_array_end+0x214>)
 8000370:	f001 fb26 	bl	80019c0 <chEvtDispatch>
  }
 8000374:	e7f6      	b.n	8000364 <main+0x1c4>
 8000376:	bf00      	nop
 8000378:	409926e9 	.word	0x409926e9
 800037c:	48001000 	.word	0x48001000
 8000380:	200012b8 	.word	0x200012b8
 8000384:	08006d20 	.word	0x08006d20
 8000388:	2000119c 	.word	0x2000119c
 800038c:	48000800 	.word	0x48000800
 8000390:	2000118c 	.word	0x2000118c
 8000394:	20000aac 	.word	0x20000aac
 8000398:	20001154 	.word	0x20001154
 800039c:	200015a4 	.word	0x200015a4
 80003a0:	20001338 	.word	0x20001338
 80003a4:	08006ec0 	.word	0x08006ec0
 80003a8:	2000162c 	.word	0x2000162c
 80003ac:	200013d0 	.word	0x200013d0
 80003b0:	08004891 	.word	0x08004891
 80003b4:	20000aa8 	.word	0x20000aa8
 80003b8:	f3af 8000 	nop.w
 80003bc:	f3af 8000 	nop.w

080003c0 <_port_switch>:
 80003c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80003c4:	ed2d 8a10 	vpush	{s16-s31}
 80003c8:	f8c1 d00c 	str.w	sp, [r1, #12]
 80003cc:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 80003d0:	ecbd 8a10 	vpop	{s16-s31}
 80003d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080003d8 <_port_thread_start>:
 80003d8:	2300      	movs	r3, #0
 80003da:	f383 8811 	msr	BASEPRI, r3
 80003de:	4628      	mov	r0, r5
 80003e0:	47a0      	blx	r4
 80003e2:	f001 f935 	bl	8001650 <chThdExit>

080003e6 <_port_switch_from_isr>:
 80003e6:	f000 fff3 	bl	80013d0 <chSchDoReschedule>

080003ea <_port_exit_from_isr>:
 80003ea:	df00      	svc	0
 80003ec:	e7fe      	b.n	80003ec <_port_exit_from_isr+0x2>
	...

080003f0 <__aeabi_drsub>:
 80003f0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80003f4:	e002      	b.n	80003fc <__adddf3>
 80003f6:	bf00      	nop

080003f8 <__aeabi_dsub>:
 80003f8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080003fc <__adddf3>:
 80003fc:	b530      	push	{r4, r5, lr}
 80003fe:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000402:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000406:	ea94 0f05 	teq	r4, r5
 800040a:	bf08      	it	eq
 800040c:	ea90 0f02 	teqeq	r0, r2
 8000410:	bf1f      	itttt	ne
 8000412:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000416:	ea55 0c02 	orrsne.w	ip, r5, r2
 800041a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800041e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000422:	f000 80e2 	beq.w	80005ea <__adddf3+0x1ee>
 8000426:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800042a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800042e:	bfb8      	it	lt
 8000430:	426d      	neglt	r5, r5
 8000432:	dd0c      	ble.n	800044e <__adddf3+0x52>
 8000434:	442c      	add	r4, r5
 8000436:	ea80 0202 	eor.w	r2, r0, r2
 800043a:	ea81 0303 	eor.w	r3, r1, r3
 800043e:	ea82 0000 	eor.w	r0, r2, r0
 8000442:	ea83 0101 	eor.w	r1, r3, r1
 8000446:	ea80 0202 	eor.w	r2, r0, r2
 800044a:	ea81 0303 	eor.w	r3, r1, r3
 800044e:	2d36      	cmp	r5, #54	; 0x36
 8000450:	bf88      	it	hi
 8000452:	bd30      	pophi	{r4, r5, pc}
 8000454:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000458:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800045c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000460:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000464:	d002      	beq.n	800046c <__adddf3+0x70>
 8000466:	4240      	negs	r0, r0
 8000468:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800046c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000470:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000474:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000478:	d002      	beq.n	8000480 <__adddf3+0x84>
 800047a:	4252      	negs	r2, r2
 800047c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000480:	ea94 0f05 	teq	r4, r5
 8000484:	f000 80a7 	beq.w	80005d6 <__adddf3+0x1da>
 8000488:	f1a4 0401 	sub.w	r4, r4, #1
 800048c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000490:	db0d      	blt.n	80004ae <__adddf3+0xb2>
 8000492:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000496:	fa22 f205 	lsr.w	r2, r2, r5
 800049a:	1880      	adds	r0, r0, r2
 800049c:	f141 0100 	adc.w	r1, r1, #0
 80004a0:	fa03 f20e 	lsl.w	r2, r3, lr
 80004a4:	1880      	adds	r0, r0, r2
 80004a6:	fa43 f305 	asr.w	r3, r3, r5
 80004aa:	4159      	adcs	r1, r3
 80004ac:	e00e      	b.n	80004cc <__adddf3+0xd0>
 80004ae:	f1a5 0520 	sub.w	r5, r5, #32
 80004b2:	f10e 0e20 	add.w	lr, lr, #32
 80004b6:	2a01      	cmp	r2, #1
 80004b8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80004bc:	bf28      	it	cs
 80004be:	f04c 0c02 	orrcs.w	ip, ip, #2
 80004c2:	fa43 f305 	asr.w	r3, r3, r5
 80004c6:	18c0      	adds	r0, r0, r3
 80004c8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80004cc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004d0:	d507      	bpl.n	80004e2 <__adddf3+0xe6>
 80004d2:	f04f 0e00 	mov.w	lr, #0
 80004d6:	f1dc 0c00 	rsbs	ip, ip, #0
 80004da:	eb7e 0000 	sbcs.w	r0, lr, r0
 80004de:	eb6e 0101 	sbc.w	r1, lr, r1
 80004e2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80004e6:	d31b      	bcc.n	8000520 <__adddf3+0x124>
 80004e8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80004ec:	d30c      	bcc.n	8000508 <__adddf3+0x10c>
 80004ee:	0849      	lsrs	r1, r1, #1
 80004f0:	ea5f 0030 	movs.w	r0, r0, rrx
 80004f4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80004f8:	f104 0401 	add.w	r4, r4, #1
 80004fc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000500:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000504:	f080 809a 	bcs.w	800063c <__adddf3+0x240>
 8000508:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800050c:	bf08      	it	eq
 800050e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000512:	f150 0000 	adcs.w	r0, r0, #0
 8000516:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800051a:	ea41 0105 	orr.w	r1, r1, r5
 800051e:	bd30      	pop	{r4, r5, pc}
 8000520:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000524:	4140      	adcs	r0, r0
 8000526:	eb41 0101 	adc.w	r1, r1, r1
 800052a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800052e:	f1a4 0401 	sub.w	r4, r4, #1
 8000532:	d1e9      	bne.n	8000508 <__adddf3+0x10c>
 8000534:	f091 0f00 	teq	r1, #0
 8000538:	bf04      	itt	eq
 800053a:	4601      	moveq	r1, r0
 800053c:	2000      	moveq	r0, #0
 800053e:	fab1 f381 	clz	r3, r1
 8000542:	bf08      	it	eq
 8000544:	3320      	addeq	r3, #32
 8000546:	f1a3 030b 	sub.w	r3, r3, #11
 800054a:	f1b3 0220 	subs.w	r2, r3, #32
 800054e:	da0c      	bge.n	800056a <__adddf3+0x16e>
 8000550:	320c      	adds	r2, #12
 8000552:	dd08      	ble.n	8000566 <__adddf3+0x16a>
 8000554:	f102 0c14 	add.w	ip, r2, #20
 8000558:	f1c2 020c 	rsb	r2, r2, #12
 800055c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000560:	fa21 f102 	lsr.w	r1, r1, r2
 8000564:	e00c      	b.n	8000580 <__adddf3+0x184>
 8000566:	f102 0214 	add.w	r2, r2, #20
 800056a:	bfd8      	it	le
 800056c:	f1c2 0c20 	rsble	ip, r2, #32
 8000570:	fa01 f102 	lsl.w	r1, r1, r2
 8000574:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000578:	bfdc      	itt	le
 800057a:	ea41 010c 	orrle.w	r1, r1, ip
 800057e:	4090      	lslle	r0, r2
 8000580:	1ae4      	subs	r4, r4, r3
 8000582:	bfa2      	ittt	ge
 8000584:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000588:	4329      	orrge	r1, r5
 800058a:	bd30      	popge	{r4, r5, pc}
 800058c:	ea6f 0404 	mvn.w	r4, r4
 8000590:	3c1f      	subs	r4, #31
 8000592:	da1c      	bge.n	80005ce <__adddf3+0x1d2>
 8000594:	340c      	adds	r4, #12
 8000596:	dc0e      	bgt.n	80005b6 <__adddf3+0x1ba>
 8000598:	f104 0414 	add.w	r4, r4, #20
 800059c:	f1c4 0220 	rsb	r2, r4, #32
 80005a0:	fa20 f004 	lsr.w	r0, r0, r4
 80005a4:	fa01 f302 	lsl.w	r3, r1, r2
 80005a8:	ea40 0003 	orr.w	r0, r0, r3
 80005ac:	fa21 f304 	lsr.w	r3, r1, r4
 80005b0:	ea45 0103 	orr.w	r1, r5, r3
 80005b4:	bd30      	pop	{r4, r5, pc}
 80005b6:	f1c4 040c 	rsb	r4, r4, #12
 80005ba:	f1c4 0220 	rsb	r2, r4, #32
 80005be:	fa20 f002 	lsr.w	r0, r0, r2
 80005c2:	fa01 f304 	lsl.w	r3, r1, r4
 80005c6:	ea40 0003 	orr.w	r0, r0, r3
 80005ca:	4629      	mov	r1, r5
 80005cc:	bd30      	pop	{r4, r5, pc}
 80005ce:	fa21 f004 	lsr.w	r0, r1, r4
 80005d2:	4629      	mov	r1, r5
 80005d4:	bd30      	pop	{r4, r5, pc}
 80005d6:	f094 0f00 	teq	r4, #0
 80005da:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80005de:	bf06      	itte	eq
 80005e0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80005e4:	3401      	addeq	r4, #1
 80005e6:	3d01      	subne	r5, #1
 80005e8:	e74e      	b.n	8000488 <__adddf3+0x8c>
 80005ea:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80005ee:	bf18      	it	ne
 80005f0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80005f4:	d029      	beq.n	800064a <__adddf3+0x24e>
 80005f6:	ea94 0f05 	teq	r4, r5
 80005fa:	bf08      	it	eq
 80005fc:	ea90 0f02 	teqeq	r0, r2
 8000600:	d005      	beq.n	800060e <__adddf3+0x212>
 8000602:	ea54 0c00 	orrs.w	ip, r4, r0
 8000606:	bf04      	itt	eq
 8000608:	4619      	moveq	r1, r3
 800060a:	4610      	moveq	r0, r2
 800060c:	bd30      	pop	{r4, r5, pc}
 800060e:	ea91 0f03 	teq	r1, r3
 8000612:	bf1e      	ittt	ne
 8000614:	2100      	movne	r1, #0
 8000616:	2000      	movne	r0, #0
 8000618:	bd30      	popne	{r4, r5, pc}
 800061a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800061e:	d105      	bne.n	800062c <__adddf3+0x230>
 8000620:	0040      	lsls	r0, r0, #1
 8000622:	4149      	adcs	r1, r1
 8000624:	bf28      	it	cs
 8000626:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800062a:	bd30      	pop	{r4, r5, pc}
 800062c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000630:	bf3c      	itt	cc
 8000632:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000636:	bd30      	popcc	{r4, r5, pc}
 8000638:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800063c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000640:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000644:	f04f 0000 	mov.w	r0, #0
 8000648:	bd30      	pop	{r4, r5, pc}
 800064a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800064e:	bf1a      	itte	ne
 8000650:	4619      	movne	r1, r3
 8000652:	4610      	movne	r0, r2
 8000654:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000658:	bf1c      	itt	ne
 800065a:	460b      	movne	r3, r1
 800065c:	4602      	movne	r2, r0
 800065e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000662:	bf06      	itte	eq
 8000664:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000668:	ea91 0f03 	teqeq	r1, r3
 800066c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000670:	bd30      	pop	{r4, r5, pc}
 8000672:	bf00      	nop

08000674 <__aeabi_ui2d>:
 8000674:	f090 0f00 	teq	r0, #0
 8000678:	bf04      	itt	eq
 800067a:	2100      	moveq	r1, #0
 800067c:	4770      	bxeq	lr
 800067e:	b530      	push	{r4, r5, lr}
 8000680:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000684:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000688:	f04f 0500 	mov.w	r5, #0
 800068c:	f04f 0100 	mov.w	r1, #0
 8000690:	e750      	b.n	8000534 <__adddf3+0x138>
 8000692:	bf00      	nop

08000694 <__aeabi_i2d>:
 8000694:	f090 0f00 	teq	r0, #0
 8000698:	bf04      	itt	eq
 800069a:	2100      	moveq	r1, #0
 800069c:	4770      	bxeq	lr
 800069e:	b530      	push	{r4, r5, lr}
 80006a0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80006a4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80006a8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80006ac:	bf48      	it	mi
 80006ae:	4240      	negmi	r0, r0
 80006b0:	f04f 0100 	mov.w	r1, #0
 80006b4:	e73e      	b.n	8000534 <__adddf3+0x138>
 80006b6:	bf00      	nop

080006b8 <__aeabi_f2d>:
 80006b8:	0042      	lsls	r2, r0, #1
 80006ba:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80006be:	ea4f 0131 	mov.w	r1, r1, rrx
 80006c2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80006c6:	bf1f      	itttt	ne
 80006c8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80006cc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80006d0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80006d4:	4770      	bxne	lr
 80006d6:	f092 0f00 	teq	r2, #0
 80006da:	bf14      	ite	ne
 80006dc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80006e0:	4770      	bxeq	lr
 80006e2:	b530      	push	{r4, r5, lr}
 80006e4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80006e8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80006ec:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80006f0:	e720      	b.n	8000534 <__adddf3+0x138>
 80006f2:	bf00      	nop

080006f4 <__aeabi_ul2d>:
 80006f4:	ea50 0201 	orrs.w	r2, r0, r1
 80006f8:	bf08      	it	eq
 80006fa:	4770      	bxeq	lr
 80006fc:	b530      	push	{r4, r5, lr}
 80006fe:	f04f 0500 	mov.w	r5, #0
 8000702:	e00a      	b.n	800071a <__aeabi_l2d+0x16>

08000704 <__aeabi_l2d>:
 8000704:	ea50 0201 	orrs.w	r2, r0, r1
 8000708:	bf08      	it	eq
 800070a:	4770      	bxeq	lr
 800070c:	b530      	push	{r4, r5, lr}
 800070e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000712:	d502      	bpl.n	800071a <__aeabi_l2d+0x16>
 8000714:	4240      	negs	r0, r0
 8000716:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800071a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800071e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000722:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000726:	f43f aedc 	beq.w	80004e2 <__adddf3+0xe6>
 800072a:	f04f 0203 	mov.w	r2, #3
 800072e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000732:	bf18      	it	ne
 8000734:	3203      	addne	r2, #3
 8000736:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800073a:	bf18      	it	ne
 800073c:	3203      	addne	r2, #3
 800073e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000742:	f1c2 0320 	rsb	r3, r2, #32
 8000746:	fa00 fc03 	lsl.w	ip, r0, r3
 800074a:	fa20 f002 	lsr.w	r0, r0, r2
 800074e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000752:	ea40 000e 	orr.w	r0, r0, lr
 8000756:	fa21 f102 	lsr.w	r1, r1, r2
 800075a:	4414      	add	r4, r2
 800075c:	e6c1      	b.n	80004e2 <__adddf3+0xe6>
 800075e:	bf00      	nop

08000760 <__aeabi_dmul>:
 8000760:	b570      	push	{r4, r5, r6, lr}
 8000762:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000766:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800076a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800076e:	bf1d      	ittte	ne
 8000770:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000774:	ea94 0f0c 	teqne	r4, ip
 8000778:	ea95 0f0c 	teqne	r5, ip
 800077c:	f000 f8de 	bleq	800093c <__aeabi_dmul+0x1dc>
 8000780:	442c      	add	r4, r5
 8000782:	ea81 0603 	eor.w	r6, r1, r3
 8000786:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800078a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800078e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000792:	bf18      	it	ne
 8000794:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000798:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800079c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80007a0:	d038      	beq.n	8000814 <__aeabi_dmul+0xb4>
 80007a2:	fba0 ce02 	umull	ip, lr, r0, r2
 80007a6:	f04f 0500 	mov.w	r5, #0
 80007aa:	fbe1 e502 	umlal	lr, r5, r1, r2
 80007ae:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80007b2:	fbe0 e503 	umlal	lr, r5, r0, r3
 80007b6:	f04f 0600 	mov.w	r6, #0
 80007ba:	fbe1 5603 	umlal	r5, r6, r1, r3
 80007be:	f09c 0f00 	teq	ip, #0
 80007c2:	bf18      	it	ne
 80007c4:	f04e 0e01 	orrne.w	lr, lr, #1
 80007c8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80007cc:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80007d0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80007d4:	d204      	bcs.n	80007e0 <__aeabi_dmul+0x80>
 80007d6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80007da:	416d      	adcs	r5, r5
 80007dc:	eb46 0606 	adc.w	r6, r6, r6
 80007e0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80007e4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80007e8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80007ec:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80007f0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80007f4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80007f8:	bf88      	it	hi
 80007fa:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80007fe:	d81e      	bhi.n	800083e <__aeabi_dmul+0xde>
 8000800:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000804:	bf08      	it	eq
 8000806:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800080a:	f150 0000 	adcs.w	r0, r0, #0
 800080e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000812:	bd70      	pop	{r4, r5, r6, pc}
 8000814:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000818:	ea46 0101 	orr.w	r1, r6, r1
 800081c:	ea40 0002 	orr.w	r0, r0, r2
 8000820:	ea81 0103 	eor.w	r1, r1, r3
 8000824:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000828:	bfc2      	ittt	gt
 800082a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800082e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000832:	bd70      	popgt	{r4, r5, r6, pc}
 8000834:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000838:	f04f 0e00 	mov.w	lr, #0
 800083c:	3c01      	subs	r4, #1
 800083e:	f300 80ab 	bgt.w	8000998 <__aeabi_dmul+0x238>
 8000842:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000846:	bfde      	ittt	le
 8000848:	2000      	movle	r0, #0
 800084a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800084e:	bd70      	pople	{r4, r5, r6, pc}
 8000850:	f1c4 0400 	rsb	r4, r4, #0
 8000854:	3c20      	subs	r4, #32
 8000856:	da35      	bge.n	80008c4 <__aeabi_dmul+0x164>
 8000858:	340c      	adds	r4, #12
 800085a:	dc1b      	bgt.n	8000894 <__aeabi_dmul+0x134>
 800085c:	f104 0414 	add.w	r4, r4, #20
 8000860:	f1c4 0520 	rsb	r5, r4, #32
 8000864:	fa00 f305 	lsl.w	r3, r0, r5
 8000868:	fa20 f004 	lsr.w	r0, r0, r4
 800086c:	fa01 f205 	lsl.w	r2, r1, r5
 8000870:	ea40 0002 	orr.w	r0, r0, r2
 8000874:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000878:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800087c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000880:	fa21 f604 	lsr.w	r6, r1, r4
 8000884:	eb42 0106 	adc.w	r1, r2, r6
 8000888:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800088c:	bf08      	it	eq
 800088e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000892:	bd70      	pop	{r4, r5, r6, pc}
 8000894:	f1c4 040c 	rsb	r4, r4, #12
 8000898:	f1c4 0520 	rsb	r5, r4, #32
 800089c:	fa00 f304 	lsl.w	r3, r0, r4
 80008a0:	fa20 f005 	lsr.w	r0, r0, r5
 80008a4:	fa01 f204 	lsl.w	r2, r1, r4
 80008a8:	ea40 0002 	orr.w	r0, r0, r2
 80008ac:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80008b0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80008b4:	f141 0100 	adc.w	r1, r1, #0
 80008b8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80008bc:	bf08      	it	eq
 80008be:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80008c2:	bd70      	pop	{r4, r5, r6, pc}
 80008c4:	f1c4 0520 	rsb	r5, r4, #32
 80008c8:	fa00 f205 	lsl.w	r2, r0, r5
 80008cc:	ea4e 0e02 	orr.w	lr, lr, r2
 80008d0:	fa20 f304 	lsr.w	r3, r0, r4
 80008d4:	fa01 f205 	lsl.w	r2, r1, r5
 80008d8:	ea43 0302 	orr.w	r3, r3, r2
 80008dc:	fa21 f004 	lsr.w	r0, r1, r4
 80008e0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80008e4:	fa21 f204 	lsr.w	r2, r1, r4
 80008e8:	ea20 0002 	bic.w	r0, r0, r2
 80008ec:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80008f0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80008f4:	bf08      	it	eq
 80008f6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80008fa:	bd70      	pop	{r4, r5, r6, pc}
 80008fc:	f094 0f00 	teq	r4, #0
 8000900:	d10f      	bne.n	8000922 <__aeabi_dmul+0x1c2>
 8000902:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000906:	0040      	lsls	r0, r0, #1
 8000908:	eb41 0101 	adc.w	r1, r1, r1
 800090c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000910:	bf08      	it	eq
 8000912:	3c01      	subeq	r4, #1
 8000914:	d0f7      	beq.n	8000906 <__aeabi_dmul+0x1a6>
 8000916:	ea41 0106 	orr.w	r1, r1, r6
 800091a:	f095 0f00 	teq	r5, #0
 800091e:	bf18      	it	ne
 8000920:	4770      	bxne	lr
 8000922:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000926:	0052      	lsls	r2, r2, #1
 8000928:	eb43 0303 	adc.w	r3, r3, r3
 800092c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000930:	bf08      	it	eq
 8000932:	3d01      	subeq	r5, #1
 8000934:	d0f7      	beq.n	8000926 <__aeabi_dmul+0x1c6>
 8000936:	ea43 0306 	orr.w	r3, r3, r6
 800093a:	4770      	bx	lr
 800093c:	ea94 0f0c 	teq	r4, ip
 8000940:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000944:	bf18      	it	ne
 8000946:	ea95 0f0c 	teqne	r5, ip
 800094a:	d00c      	beq.n	8000966 <__aeabi_dmul+0x206>
 800094c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000950:	bf18      	it	ne
 8000952:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000956:	d1d1      	bne.n	80008fc <__aeabi_dmul+0x19c>
 8000958:	ea81 0103 	eor.w	r1, r1, r3
 800095c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000960:	f04f 0000 	mov.w	r0, #0
 8000964:	bd70      	pop	{r4, r5, r6, pc}
 8000966:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800096a:	bf06      	itte	eq
 800096c:	4610      	moveq	r0, r2
 800096e:	4619      	moveq	r1, r3
 8000970:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000974:	d019      	beq.n	80009aa <__aeabi_dmul+0x24a>
 8000976:	ea94 0f0c 	teq	r4, ip
 800097a:	d102      	bne.n	8000982 <__aeabi_dmul+0x222>
 800097c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000980:	d113      	bne.n	80009aa <__aeabi_dmul+0x24a>
 8000982:	ea95 0f0c 	teq	r5, ip
 8000986:	d105      	bne.n	8000994 <__aeabi_dmul+0x234>
 8000988:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800098c:	bf1c      	itt	ne
 800098e:	4610      	movne	r0, r2
 8000990:	4619      	movne	r1, r3
 8000992:	d10a      	bne.n	80009aa <__aeabi_dmul+0x24a>
 8000994:	ea81 0103 	eor.w	r1, r1, r3
 8000998:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800099c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80009a0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80009a4:	f04f 0000 	mov.w	r0, #0
 80009a8:	bd70      	pop	{r4, r5, r6, pc}
 80009aa:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80009ae:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80009b2:	bd70      	pop	{r4, r5, r6, pc}

080009b4 <__aeabi_ddiv>:
 80009b4:	b570      	push	{r4, r5, r6, lr}
 80009b6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80009ba:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80009be:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80009c2:	bf1d      	ittte	ne
 80009c4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80009c8:	ea94 0f0c 	teqne	r4, ip
 80009cc:	ea95 0f0c 	teqne	r5, ip
 80009d0:	f000 f8a7 	bleq	8000b22 <__aeabi_ddiv+0x16e>
 80009d4:	eba4 0405 	sub.w	r4, r4, r5
 80009d8:	ea81 0e03 	eor.w	lr, r1, r3
 80009dc:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80009e0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80009e4:	f000 8088 	beq.w	8000af8 <__aeabi_ddiv+0x144>
 80009e8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80009ec:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80009f0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80009f4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80009f8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80009fc:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000a00:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000a04:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000a08:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000a0c:	429d      	cmp	r5, r3
 8000a0e:	bf08      	it	eq
 8000a10:	4296      	cmpeq	r6, r2
 8000a12:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000a16:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000a1a:	d202      	bcs.n	8000a22 <__aeabi_ddiv+0x6e>
 8000a1c:	085b      	lsrs	r3, r3, #1
 8000a1e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000a22:	1ab6      	subs	r6, r6, r2
 8000a24:	eb65 0503 	sbc.w	r5, r5, r3
 8000a28:	085b      	lsrs	r3, r3, #1
 8000a2a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000a2e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000a32:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000a36:	ebb6 0e02 	subs.w	lr, r6, r2
 8000a3a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000a3e:	bf22      	ittt	cs
 8000a40:	1ab6      	subcs	r6, r6, r2
 8000a42:	4675      	movcs	r5, lr
 8000a44:	ea40 000c 	orrcs.w	r0, r0, ip
 8000a48:	085b      	lsrs	r3, r3, #1
 8000a4a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000a4e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000a52:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000a56:	bf22      	ittt	cs
 8000a58:	1ab6      	subcs	r6, r6, r2
 8000a5a:	4675      	movcs	r5, lr
 8000a5c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000a60:	085b      	lsrs	r3, r3, #1
 8000a62:	ea4f 0232 	mov.w	r2, r2, rrx
 8000a66:	ebb6 0e02 	subs.w	lr, r6, r2
 8000a6a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000a6e:	bf22      	ittt	cs
 8000a70:	1ab6      	subcs	r6, r6, r2
 8000a72:	4675      	movcs	r5, lr
 8000a74:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000a78:	085b      	lsrs	r3, r3, #1
 8000a7a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000a7e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000a82:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000a86:	bf22      	ittt	cs
 8000a88:	1ab6      	subcs	r6, r6, r2
 8000a8a:	4675      	movcs	r5, lr
 8000a8c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000a90:	ea55 0e06 	orrs.w	lr, r5, r6
 8000a94:	d018      	beq.n	8000ac8 <__aeabi_ddiv+0x114>
 8000a96:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000a9a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000a9e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000aa2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000aa6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000aaa:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000aae:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000ab2:	d1c0      	bne.n	8000a36 <__aeabi_ddiv+0x82>
 8000ab4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000ab8:	d10b      	bne.n	8000ad2 <__aeabi_ddiv+0x11e>
 8000aba:	ea41 0100 	orr.w	r1, r1, r0
 8000abe:	f04f 0000 	mov.w	r0, #0
 8000ac2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000ac6:	e7b6      	b.n	8000a36 <__aeabi_ddiv+0x82>
 8000ac8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000acc:	bf04      	itt	eq
 8000ace:	4301      	orreq	r1, r0
 8000ad0:	2000      	moveq	r0, #0
 8000ad2:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000ad6:	bf88      	it	hi
 8000ad8:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000adc:	f63f aeaf 	bhi.w	800083e <__aeabi_dmul+0xde>
 8000ae0:	ebb5 0c03 	subs.w	ip, r5, r3
 8000ae4:	bf04      	itt	eq
 8000ae6:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000aea:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000aee:	f150 0000 	adcs.w	r0, r0, #0
 8000af2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000af6:	bd70      	pop	{r4, r5, r6, pc}
 8000af8:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000afc:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000b00:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000b04:	bfc2      	ittt	gt
 8000b06:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000b0a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000b0e:	bd70      	popgt	{r4, r5, r6, pc}
 8000b10:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000b14:	f04f 0e00 	mov.w	lr, #0
 8000b18:	3c01      	subs	r4, #1
 8000b1a:	e690      	b.n	800083e <__aeabi_dmul+0xde>
 8000b1c:	ea45 0e06 	orr.w	lr, r5, r6
 8000b20:	e68d      	b.n	800083e <__aeabi_dmul+0xde>
 8000b22:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000b26:	ea94 0f0c 	teq	r4, ip
 8000b2a:	bf08      	it	eq
 8000b2c:	ea95 0f0c 	teqeq	r5, ip
 8000b30:	f43f af3b 	beq.w	80009aa <__aeabi_dmul+0x24a>
 8000b34:	ea94 0f0c 	teq	r4, ip
 8000b38:	d10a      	bne.n	8000b50 <__aeabi_ddiv+0x19c>
 8000b3a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000b3e:	f47f af34 	bne.w	80009aa <__aeabi_dmul+0x24a>
 8000b42:	ea95 0f0c 	teq	r5, ip
 8000b46:	f47f af25 	bne.w	8000994 <__aeabi_dmul+0x234>
 8000b4a:	4610      	mov	r0, r2
 8000b4c:	4619      	mov	r1, r3
 8000b4e:	e72c      	b.n	80009aa <__aeabi_dmul+0x24a>
 8000b50:	ea95 0f0c 	teq	r5, ip
 8000b54:	d106      	bne.n	8000b64 <__aeabi_ddiv+0x1b0>
 8000b56:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000b5a:	f43f aefd 	beq.w	8000958 <__aeabi_dmul+0x1f8>
 8000b5e:	4610      	mov	r0, r2
 8000b60:	4619      	mov	r1, r3
 8000b62:	e722      	b.n	80009aa <__aeabi_dmul+0x24a>
 8000b64:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000b68:	bf18      	it	ne
 8000b6a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000b6e:	f47f aec5 	bne.w	80008fc <__aeabi_dmul+0x19c>
 8000b72:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000b76:	f47f af0d 	bne.w	8000994 <__aeabi_dmul+0x234>
 8000b7a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000b7e:	f47f aeeb 	bne.w	8000958 <__aeabi_dmul+0x1f8>
 8000b82:	e712      	b.n	80009aa <__aeabi_dmul+0x24a>
	...

08000b90 <__gedf2>:
 8000b90:	f04f 3cff 	mov.w	ip, #4294967295
 8000b94:	e006      	b.n	8000ba4 <__cmpdf2+0x4>
 8000b96:	bf00      	nop

08000b98 <__ledf2>:
 8000b98:	f04f 0c01 	mov.w	ip, #1
 8000b9c:	e002      	b.n	8000ba4 <__cmpdf2+0x4>
 8000b9e:	bf00      	nop

08000ba0 <__cmpdf2>:
 8000ba0:	f04f 0c01 	mov.w	ip, #1
 8000ba4:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000ba8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000bac:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000bb0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000bb4:	bf18      	it	ne
 8000bb6:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000bba:	d01b      	beq.n	8000bf4 <__cmpdf2+0x54>
 8000bbc:	b001      	add	sp, #4
 8000bbe:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000bc2:	bf0c      	ite	eq
 8000bc4:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000bc8:	ea91 0f03 	teqne	r1, r3
 8000bcc:	bf02      	ittt	eq
 8000bce:	ea90 0f02 	teqeq	r0, r2
 8000bd2:	2000      	moveq	r0, #0
 8000bd4:	4770      	bxeq	lr
 8000bd6:	f110 0f00 	cmn.w	r0, #0
 8000bda:	ea91 0f03 	teq	r1, r3
 8000bde:	bf58      	it	pl
 8000be0:	4299      	cmppl	r1, r3
 8000be2:	bf08      	it	eq
 8000be4:	4290      	cmpeq	r0, r2
 8000be6:	bf2c      	ite	cs
 8000be8:	17d8      	asrcs	r0, r3, #31
 8000bea:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000bee:	f040 0001 	orr.w	r0, r0, #1
 8000bf2:	4770      	bx	lr
 8000bf4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000bf8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000bfc:	d102      	bne.n	8000c04 <__cmpdf2+0x64>
 8000bfe:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000c02:	d107      	bne.n	8000c14 <__cmpdf2+0x74>
 8000c04:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000c08:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000c0c:	d1d6      	bne.n	8000bbc <__cmpdf2+0x1c>
 8000c0e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000c12:	d0d3      	beq.n	8000bbc <__cmpdf2+0x1c>
 8000c14:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000c18:	4770      	bx	lr
 8000c1a:	bf00      	nop

08000c1c <__aeabi_cdrcmple>:
 8000c1c:	4684      	mov	ip, r0
 8000c1e:	4610      	mov	r0, r2
 8000c20:	4662      	mov	r2, ip
 8000c22:	468c      	mov	ip, r1
 8000c24:	4619      	mov	r1, r3
 8000c26:	4663      	mov	r3, ip
 8000c28:	e000      	b.n	8000c2c <__aeabi_cdcmpeq>
 8000c2a:	bf00      	nop

08000c2c <__aeabi_cdcmpeq>:
 8000c2c:	b501      	push	{r0, lr}
 8000c2e:	f7ff ffb7 	bl	8000ba0 <__cmpdf2>
 8000c32:	2800      	cmp	r0, #0
 8000c34:	bf48      	it	mi
 8000c36:	f110 0f00 	cmnmi.w	r0, #0
 8000c3a:	bd01      	pop	{r0, pc}

08000c3c <__aeabi_dcmpeq>:
 8000c3c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c40:	f7ff fff4 	bl	8000c2c <__aeabi_cdcmpeq>
 8000c44:	bf0c      	ite	eq
 8000c46:	2001      	moveq	r0, #1
 8000c48:	2000      	movne	r0, #0
 8000c4a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c4e:	bf00      	nop

08000c50 <__aeabi_dcmplt>:
 8000c50:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c54:	f7ff ffea 	bl	8000c2c <__aeabi_cdcmpeq>
 8000c58:	bf34      	ite	cc
 8000c5a:	2001      	movcc	r0, #1
 8000c5c:	2000      	movcs	r0, #0
 8000c5e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c62:	bf00      	nop

08000c64 <__aeabi_dcmple>:
 8000c64:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c68:	f7ff ffe0 	bl	8000c2c <__aeabi_cdcmpeq>
 8000c6c:	bf94      	ite	ls
 8000c6e:	2001      	movls	r0, #1
 8000c70:	2000      	movhi	r0, #0
 8000c72:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c76:	bf00      	nop

08000c78 <__aeabi_dcmpge>:
 8000c78:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c7c:	f7ff ffce 	bl	8000c1c <__aeabi_cdrcmple>
 8000c80:	bf94      	ite	ls
 8000c82:	2001      	movls	r0, #1
 8000c84:	2000      	movhi	r0, #0
 8000c86:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c8a:	bf00      	nop

08000c8c <__aeabi_dcmpgt>:
 8000c8c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c90:	f7ff ffc4 	bl	8000c1c <__aeabi_cdrcmple>
 8000c94:	bf34      	ite	cc
 8000c96:	2001      	movcc	r0, #1
 8000c98:	2000      	movcs	r0, #0
 8000c9a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c9e:	bf00      	nop

08000ca0 <__aeabi_d2iz>:
 8000ca0:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000ca4:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000ca8:	d215      	bcs.n	8000cd6 <__aeabi_d2iz+0x36>
 8000caa:	d511      	bpl.n	8000cd0 <__aeabi_d2iz+0x30>
 8000cac:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000cb0:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000cb4:	d912      	bls.n	8000cdc <__aeabi_d2iz+0x3c>
 8000cb6:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000cba:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000cbe:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000cc2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000cc6:	fa23 f002 	lsr.w	r0, r3, r2
 8000cca:	bf18      	it	ne
 8000ccc:	4240      	negne	r0, r0
 8000cce:	4770      	bx	lr
 8000cd0:	f04f 0000 	mov.w	r0, #0
 8000cd4:	4770      	bx	lr
 8000cd6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000cda:	d105      	bne.n	8000ce8 <__aeabi_d2iz+0x48>
 8000cdc:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000ce0:	bf08      	it	eq
 8000ce2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000ce6:	4770      	bx	lr
 8000ce8:	f04f 0000 	mov.w	r0, #0
 8000cec:	4770      	bx	lr
 8000cee:	bf00      	nop

08000cf0 <__aeabi_d2f>:
 8000cf0:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000cf4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000cf8:	bf24      	itt	cs
 8000cfa:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000cfe:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000d02:	d90d      	bls.n	8000d20 <__aeabi_d2f+0x30>
 8000d04:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000d08:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000d0c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000d10:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000d14:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000d18:	bf08      	it	eq
 8000d1a:	f020 0001 	biceq.w	r0, r0, #1
 8000d1e:	4770      	bx	lr
 8000d20:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000d24:	d121      	bne.n	8000d6a <__aeabi_d2f+0x7a>
 8000d26:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000d2a:	bfbc      	itt	lt
 8000d2c:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000d30:	4770      	bxlt	lr
 8000d32:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000d36:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000d3a:	f1c2 0218 	rsb	r2, r2, #24
 8000d3e:	f1c2 0c20 	rsb	ip, r2, #32
 8000d42:	fa10 f30c 	lsls.w	r3, r0, ip
 8000d46:	fa20 f002 	lsr.w	r0, r0, r2
 8000d4a:	bf18      	it	ne
 8000d4c:	f040 0001 	orrne.w	r0, r0, #1
 8000d50:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000d54:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000d58:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000d5c:	ea40 000c 	orr.w	r0, r0, ip
 8000d60:	fa23 f302 	lsr.w	r3, r3, r2
 8000d64:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000d68:	e7cc      	b.n	8000d04 <__aeabi_d2f+0x14>
 8000d6a:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000d6e:	d107      	bne.n	8000d80 <__aeabi_d2f+0x90>
 8000d70:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000d74:	bf1e      	ittt	ne
 8000d76:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000d7a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000d7e:	4770      	bxne	lr
 8000d80:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000d84:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000d88:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000d8c:	4770      	bx	lr
 8000d8e:	bf00      	nop

08000d90 <__late_init>:
 * @note    This function is a weak symbol.
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
void __late_init(void) {}
 8000d90:	4770      	bx	lr
 8000d92:	bf00      	nop
 8000d94:	f3af 8000 	nop.w
 8000d98:	f3af 8000 	nop.w
 8000d9c:	f3af 8000 	nop.w

08000da0 <_default_exit>:
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
void _default_exit(void) {
  while (1)
    ;
 8000da0:	e7fe      	b.n	8000da0 <_default_exit>
 8000da2:	bf00      	nop
 8000da4:	f3af 8000 	nop.w
 8000da8:	f3af 8000 	nop.w
 8000dac:	f3af 8000 	nop.w

08000db0 <Reset_Handler>:
  uint32_t psp, reg;

  /* Process Stack initialization, it is allocated starting from the
     symbol __process_stack_end__ and its lower limit is the symbol
     __process_stack_base__.*/
  asm volatile ("cpsid   i");
 8000db0:	b672      	cpsid	i
  psp = SYMVAL(__process_stack_end__);
 8000db2:	4c37      	ldr	r4, [pc, #220]	; (8000e90 <Reset_Handler+0xe0>)
  asm volatile ("msr     PSP, %0" : : "r" (psp));
 8000db4:	f384 8809 	msr	PSP, r4
#if CORTEX_USE_FPU
  /* Initializing the FPU context save in lazy mode.*/
  SCB_FPCCR = FPCCR_ASPEN | FPCCR_LSPEN;

  /* CP10 and CP11 set to full access.*/
  SCB_CPACR |= 0x00F00000;
 8000db8:	4a36      	ldr	r2, [pc, #216]	; (8000e94 <Reset_Handler+0xe4>)
  psp = SYMVAL(__process_stack_end__);
  asm volatile ("msr     PSP, %0" : : "r" (psp));

#if CORTEX_USE_FPU
  /* Initializing the FPU context save in lazy mode.*/
  SCB_FPCCR = FPCCR_ASPEN | FPCCR_LSPEN;
 8000dba:	4937      	ldr	r1, [pc, #220]	; (8000e98 <Reset_Handler+0xe8>)

  /* CP10 and CP11 set to full access.*/
  SCB_CPACR |= 0x00F00000;
 8000dbc:	6813      	ldr	r3, [r2, #0]
  psp = SYMVAL(__process_stack_end__);
  asm volatile ("msr     PSP, %0" : : "r" (psp));

#if CORTEX_USE_FPU
  /* Initializing the FPU context save in lazy mode.*/
  SCB_FPCCR = FPCCR_ASPEN | FPCCR_LSPEN;
 8000dbe:	f04f 4040 	mov.w	r0, #3221225472	; 0xc0000000

  /* CP10 and CP11 set to full access.*/
  SCB_CPACR |= 0x00F00000;
 8000dc2:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000dc6:	6013      	str	r3, [r2, #0]
  psp = SYMVAL(__process_stack_end__);
  asm volatile ("msr     PSP, %0" : : "r" (psp));

#if CORTEX_USE_FPU
  /* Initializing the FPU context save in lazy mode.*/
  SCB_FPCCR = FPCCR_ASPEN | FPCCR_LSPEN;
 8000dc8:	6008      	str	r0, [r1, #0]
  /* CP10 and CP11 set to full access.*/
  SCB_CPACR |= 0x00F00000;

  /* FPSCR and FPDSCR initially zero.*/
  reg = 0;
  asm volatile ("vmsr    FPSCR, %0" : : "r" (reg) : "memory");
 8000dca:	2300      	movs	r3, #0
 8000dcc:	eee1 3a10 	vmsr	fpscr, r3
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 8000dd0:	2206      	movs	r2, #6
  SCB_CPACR |= 0x00F00000;

  /* FPSCR and FPDSCR initially zero.*/
  reg = 0;
  asm volatile ("vmsr    FPSCR, %0" : : "r" (reg) : "memory");
  SCB_FPDSCR = reg;
 8000dd2:	608b      	str	r3, [r1, #8]
  reg = CRT0_CONTROL_INIT | 4;
#else
  /* CPU mode initialization.*/
  reg = CRT0_CONTROL_INIT;
#endif
  asm volatile ("msr     CONTROL, %0" : : "r" (reg));
 8000dd4:	f382 8814 	msr	CONTROL, r2
  asm volatile ("isb");
 8000dd8:	f3bf 8f6f 	isb	sy

  /* Early initialization hook invocation.*/
  __early_init();
 8000ddc:	f002 fea8 	bl	8003b30 <__early_init>

#if CRT0_INIT_STACKS
  /* Main and Process stacks initialization.*/
  fill32(&__main_stack_base__,
 8000de0:	4b2e      	ldr	r3, [pc, #184]	; (8000e9c <Reset_Handler+0xec>)
 8000de2:	4a2f      	ldr	r2, [pc, #188]	; (8000ea0 <Reset_Handler+0xf0>)
 8000de4:	4293      	cmp	r3, r2
 8000de6:	d20b      	bcs.n	8000e00 <Reset_Handler+0x50>
 8000de8:	43d9      	mvns	r1, r3
 8000dea:	440a      	add	r2, r1
 8000dec:	f022 0203 	bic.w	r2, r2, #3
 8000df0:	3204      	adds	r2, #4
 8000df2:	441a      	add	r2, r3
 8000df4:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000df8:	f843 1b04 	str.w	r1, [r3], #4
 8000dfc:	4293      	cmp	r3, r2
 8000dfe:	d1fb      	bne.n	8000df8 <Reset_Handler+0x48>
         &__main_stack_end__,
         CRT0_STACKS_FILL_PATTERN);
  fill32(&__process_stack_base__,
 8000e00:	4b28      	ldr	r3, [pc, #160]	; (8000ea4 <Reset_Handler+0xf4>)
 8000e02:	42a3      	cmp	r3, r4
 8000e04:	d20c      	bcs.n	8000e20 <Reset_Handler+0x70>
 8000e06:	4a28      	ldr	r2, [pc, #160]	; (8000ea8 <Reset_Handler+0xf8>)
 8000e08:	1d19      	adds	r1, r3, #4
 8000e0a:	1a52      	subs	r2, r2, r1
 8000e0c:	f022 0203 	bic.w	r2, r2, #3
 8000e10:	3204      	adds	r2, #4
 8000e12:	441a      	add	r2, r3
 8000e14:	f04f 3155 	mov.w	r1, #1431655765	; 0x55555555
 8000e18:	f843 1b04 	str.w	r1, [r3], #4
 8000e1c:	4293      	cmp	r3, r2
 8000e1e:	d1fb      	bne.n	8000e18 <Reset_Handler+0x68>
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000e20:	4a22      	ldr	r2, [pc, #136]	; (8000eac <Reset_Handler+0xfc>)
 8000e22:	4b23      	ldr	r3, [pc, #140]	; (8000eb0 <Reset_Handler+0x100>)
 8000e24:	429a      	cmp	r2, r3
 8000e26:	d20c      	bcs.n	8000e42 <Reset_Handler+0x92>
 8000e28:	43d0      	mvns	r0, r2
 8000e2a:	4418      	add	r0, r3
 8000e2c:	f020 0003 	bic.w	r0, r0, #3
 8000e30:	4b20      	ldr	r3, [pc, #128]	; (8000eb4 <Reset_Handler+0x104>)
 8000e32:	3004      	adds	r0, #4
 8000e34:	4418      	add	r0, r3
      *dp++ = *tp++;
 8000e36:	f853 1b04 	ldr.w	r1, [r3], #4
 8000e3a:	f842 1b04 	str.w	r1, [r2], #4
  {
    uint32_t *tp, *dp;

    tp = &_textdata;
    dp = &_data;
    while (dp < &_edata)
 8000e3e:	4283      	cmp	r3, r0
 8000e40:	d1f9      	bne.n	8000e36 <Reset_Handler+0x86>
  }
#endif

#if CRT0_INIT_BSS
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
 8000e42:	4b1d      	ldr	r3, [pc, #116]	; (8000eb8 <Reset_Handler+0x108>)
 8000e44:	4a1d      	ldr	r2, [pc, #116]	; (8000ebc <Reset_Handler+0x10c>)
 8000e46:	4293      	cmp	r3, r2
 8000e48:	d20a      	bcs.n	8000e60 <Reset_Handler+0xb0>
 8000e4a:	43d9      	mvns	r1, r3
 8000e4c:	440a      	add	r2, r1
 8000e4e:	f022 0203 	bic.w	r2, r2, #3
 8000e52:	3204      	adds	r2, #4
 8000e54:	441a      	add	r2, r3
 8000e56:	2100      	movs	r1, #0
 8000e58:	f843 1b04 	str.w	r1, [r3], #4
 8000e5c:	4293      	cmp	r3, r2
 8000e5e:	d1fb      	bne.n	8000e58 <Reset_Handler+0xa8>

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 8000e60:	4d17      	ldr	r5, [pc, #92]	; (8000ec0 <Reset_Handler+0x110>)
 8000e62:	4c18      	ldr	r4, [pc, #96]	; (8000ec4 <Reset_Handler+0x114>)
  /* BSS segment initialization.*/
  fill32(&_bss_start, &_bss_end, 0);
#endif

  /* Late initialization hook invocation.*/
  __late_init();
 8000e64:	f7ff ff94 	bl	8000d90 <__late_init>

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 8000e68:	42ac      	cmp	r4, r5
 8000e6a:	d204      	bcs.n	8000e76 <Reset_Handler+0xc6>
      (*fpp)();
 8000e6c:	f854 3b04 	ldr.w	r3, [r4], #4
 8000e70:	4798      	blx	r3

#if CRT0_CALL_CONSTRUCTORS
  /* Constructors invocation.*/
  {
    funcpp_t fpp = &__init_array_start;
    while (fpp < &__init_array_end) {
 8000e72:	42ac      	cmp	r4, r5
 8000e74:	d3fa      	bcc.n	8000e6c <Reset_Handler+0xbc>

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 8000e76:	4d14      	ldr	r5, [pc, #80]	; (8000ec8 <Reset_Handler+0x118>)
 8000e78:	4c14      	ldr	r4, [pc, #80]	; (8000ecc <Reset_Handler+0x11c>)
    }
  }
#endif

  /* Invoking application main() function.*/
  main();
 8000e7a:	f7ff f991 	bl	80001a0 <main>

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 8000e7e:	42ac      	cmp	r4, r5
 8000e80:	d204      	bcs.n	8000e8c <Reset_Handler+0xdc>
      (*fpp)();
 8000e82:	f854 3b04 	ldr.w	r3, [r4], #4
 8000e86:	4798      	blx	r3

#if CRT0_CALL_DESTRUCTORS
  /* Destructors invocation.*/
  {
    funcpp_t fpp = &__fini_array_start;
    while (fpp < &__fini_array_end) {
 8000e88:	42ac      	cmp	r4, r5
 8000e8a:	d3fa      	bcc.n	8000e82 <Reset_Handler+0xd2>
    }
  }
#endif

  /* Invoking the exit handler.*/
  _default_exit();
 8000e8c:	f7ff ff88 	bl	8000da0 <_default_exit>
 8000e90:	20000800 	.word	0x20000800
 8000e94:	e000ed88 	.word	0xe000ed88
 8000e98:	e000ef34 	.word	0xe000ef34
 8000e9c:	20000000 	.word	0x20000000
 8000ea0:	20000400 	.word	0x20000400
 8000ea4:	20000400 	.word	0x20000400
 8000ea8:	20000803 	.word	0x20000803
 8000eac:	20000800 	.word	0x20000800
 8000eb0:	20000ef0 	.word	0x20000ef0
 8000eb4:	08007048 	.word	0x08007048
 8000eb8:	20000ef0 	.word	0x20000ef0
 8000ebc:	20001630 	.word	0x20001630
 8000ec0:	080001a0 	.word	0x080001a0
 8000ec4:	080001a0 	.word	0x080001a0
 8000ec8:	080001a0 	.word	0x080001a0
 8000ecc:	080001a0 	.word	0x080001a0

08000ed0 <_unhandled_exception>:
 * @notapi
 */
void _unhandled_exception(void) {

  while (true)
    ;
 8000ed0:	e7fe      	b.n	8000ed0 <_unhandled_exception>
 8000ed2:	bf00      	nop
 8000ed4:	f3af 8000 	nop.w
 8000ed8:	f3af 8000 	nop.w
 8000edc:	f3af 8000 	nop.w

08000ee0 <SVC_Handler>:
void SVC_Handler(void) {
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8000ee0:	4a06      	ldr	r2, [pc, #24]	; (8000efc <SVC_Handler+0x1c>)
 8000ee2:	6853      	ldr	r3, [r2, #4]
 8000ee4:	f023 0301 	bic.w	r3, r3, #1
 8000ee8:	6053      	str	r3, [r2, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000eea:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8000eee:	3368      	adds	r3, #104	; 0x68

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000ef0:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000ef4:	2300      	movs	r3, #0
 8000ef6:	f383 8811 	msr	BASEPRI, r3
 8000efa:	4770      	bx	lr
 8000efc:	e000ef30 	.word	0xe000ef30

08000f00 <_port_irq_epilogue>:
 8000f00:	2320      	movs	r3, #32
 8000f02:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0) {
 8000f06:	4b12      	ldr	r3, [pc, #72]	; (8000f50 <_port_irq_epilogue+0x50>)
 8000f08:	685b      	ldr	r3, [r3, #4]
 8000f0a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8000f0e:	d102      	bne.n	8000f16 <_port_irq_epilogue+0x16>
 8000f10:	f383 8811 	msr	BASEPRI, r3
 8000f14:	4770      	bx	lr
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8000f16:	b510      	push	{r4, lr}
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8000f18:	eef1 3a10 	vmrs	r3, fpscr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000f1c:	f3ef 8409 	mrs	r4, PSP
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
#if CORTEX_USE_FPU
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8000f20:	4b0c      	ldr	r3, [pc, #48]	; (8000f54 <_port_irq_epilogue+0x54>)
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000f22:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
#if CORTEX_USE_FPU
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8000f26:	68db      	ldr	r3, [r3, #12]
 8000f28:	f844 3c08 	str.w	r3, [r4, #-8]
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000f2c:	f844 2c4c 	str.w	r2, [r4, #-76]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000f30:	f1a4 0368 	sub.w	r3, r4, #104	; 0x68

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000f34:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000f38:	f000 fa0a 	bl	8001350 <chSchIsPreemptionRequired>
 8000f3c:	b118      	cbz	r0, 8000f46 <_port_irq_epilogue+0x46>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000f3e:	4b06      	ldr	r3, [pc, #24]	; (8000f58 <_port_irq_epilogue+0x58>)
 8000f40:	f844 3c50 	str.w	r3, [r4, #-80]
 8000f44:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000f46:	4b05      	ldr	r3, [pc, #20]	; (8000f5c <_port_irq_epilogue+0x5c>)
 8000f48:	f844 3c50 	str.w	r3, [r4, #-80]
 8000f4c:	bd10      	pop	{r4, pc}
 8000f4e:	bf00      	nop
 8000f50:	e000ed00 	.word	0xe000ed00
 8000f54:	e000ef30 	.word	0xe000ef30
 8000f58:	080003e7 	.word	0x080003e7
 8000f5c:	080003ea 	.word	0x080003ea

08000f60 <_idle_thread>:
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {

  (void)p;
  chRegSetThreadName("idle");
 8000f60:	4b02      	ldr	r3, [pc, #8]	; (8000f6c <_idle_thread+0xc>)
 8000f62:	4a03      	ldr	r2, [pc, #12]	; (8000f70 <_idle_thread+0x10>)
 8000f64:	699b      	ldr	r3, [r3, #24]
 8000f66:	619a      	str	r2, [r3, #24]
 8000f68:	e7fe      	b.n	8000f68 <_idle_thread+0x8>
 8000f6a:	bf00      	nop
 8000f6c:	20000ef0 	.word	0x20000ef0
 8000f70:	080068b0 	.word	0x080068b0
 8000f74:	f3af 8000 	nop.w
 8000f78:	f3af 8000 	nop.w
 8000f7c:	f3af 8000 	nop.w

08000f80 <chSysInit>:
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000f80:	4b1f      	ldr	r3, [pc, #124]	; (8001000 <chSysInit+0x80>)
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 8000f82:	4a20      	ldr	r2, [pc, #128]	; (8001004 <chSysInit+0x84>)
  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000f84:	4820      	ldr	r0, [pc, #128]	; (8001008 <chSysInit+0x88>)
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8000f86:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000f88:	2400      	movs	r4, #0
 8000f8a:	609c      	str	r4, [r3, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000f8c:	68df      	ldr	r7, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8000f8e:	4e1f      	ldr	r6, [pc, #124]	; (800100c <chSysInit+0x8c>)
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8000f90:	4d1f      	ldr	r5, [pc, #124]	; (8001010 <chSysInit+0x90>)
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 8000f92:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 8000f96:	4039      	ands	r1, r7
  reg_value  =  (reg_value                                 |
 8000f98:	430a      	orrs	r2, r1
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000f9a:	60da      	str	r2, [r3, #12]
 8000f9c:	68f2      	ldr	r2, [r6, #12]
 8000f9e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000fa2:	60f2      	str	r2, [r6, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000fa4:	6802      	ldr	r2, [r0, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8000fa6:	2120      	movs	r1, #32
 8000fa8:	f042 0201 	orr.w	r2, r2, #1
 8000fac:	2610      	movs	r6, #16
 8000fae:	6002      	str	r2, [r0, #0]
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8000fb0:	b083      	sub	sp, #12
 8000fb2:	77de      	strb	r6, [r3, #31]
 8000fb4:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
#if CH_DBG_ENABLE_STACK_CHECK
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
  _scheduler_init();
 8000fb8:	f000 f932 	bl	8001220 <_scheduler_init>
  _vt_init();
 8000fbc:	f000 fa10 	bl	80013e0 <_vt_init>
#if CH_CFG_USE_TM
  _tm_init();
 8000fc0:	f000 f8d6 	bl	8001170 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE
  _core_init();
 8000fc4:	f000 fe74 	bl	8001cb0 <_core_init>
#endif
#if CH_CFG_USE_HEAP
  _heap_init();
 8000fc8:	f000 feaa 	bl	8001d20 <_heap_init>
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8000fcc:	4628      	mov	r0, r5
 8000fce:	2140      	movs	r1, #64	; 0x40
 8000fd0:	f000 fa76 	bl	80014c0 <_thread_init>
 8000fd4:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8000fd8:	2201      	movs	r2, #1
  _dbg_trace_init();
#endif

#if !CH_CFG_NO_IDLE_THREAD
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8000fda:	6198      	str	r0, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8000fdc:	7702      	strb	r2, [r0, #28]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000fde:	f384 8811 	msr	BASEPRI, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000fe2:	b662      	cpsie	i
#endif
  chSysEnable();

  /* Note, &ch_debug points to the string "main" if the registry is
     active, else the parameter is ignored.*/
  chRegSetThreadName((const char *)&ch_debug);
 8000fe4:	699b      	ldr	r3, [r3, #24]
 8000fe6:	490b      	ldr	r1, [pc, #44]	; (8001014 <chSysInit+0x94>)
 8000fe8:	6199      	str	r1, [r3, #24]

#if !CH_CFG_NO_IDLE_THREAD
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
  chThdCreateStatic(ch.idle_thread_wa, sizeof(ch.idle_thread_wa), IDLEPRIO,
 8000fea:	f105 0048 	add.w	r0, r5, #72	; 0x48
 8000fee:	9400      	str	r4, [sp, #0]
 8000ff0:	f44f 71b0 	mov.w	r1, #352	; 0x160
 8000ff4:	4b08      	ldr	r3, [pc, #32]	; (8001018 <chSysInit+0x98>)
 8000ff6:	f000 fabb 	bl	8001570 <chThdCreateStatic>
                    (tfunc_t)_idle_thread, NULL);
#endif
}
 8000ffa:	b003      	add	sp, #12
 8000ffc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000ffe:	bf00      	nop
 8001000:	e000ed00 	.word	0xe000ed00
 8001004:	05fa0300 	.word	0x05fa0300
 8001008:	e0001000 	.word	0xe0001000
 800100c:	e000edf0 	.word	0xe000edf0
 8001010:	20000f20 	.word	0x20000f20
 8001014:	080068c0 	.word	0x080068c0
 8001018:	08000f61 	.word	0x08000f61
 800101c:	f3af 8000 	nop.w

08001020 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8001020:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8001024:	4c1b      	ldr	r4, [pc, #108]	; (8001094 <chSysTimerHandlerI+0x74>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001026:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 800102a:	69e3      	ldr	r3, [r4, #28]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 800102c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800102e:	6a69      	ldr	r1, [r5, #36]	; 0x24

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8001030:	6898      	ldr	r0, [r3, #8]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8001032:	1a8e      	subs	r6, r1, r2

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8001034:	4286      	cmp	r6, r0
 8001036:	f104 061c 	add.w	r6, r4, #28
 800103a:	d319      	bcc.n	8001070 <chSysTimerHandlerI+0x50>

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = (vtfunc_t)NULL;
 800103c:	f04f 0800 	mov.w	r8, #0

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001040:	2720      	movs	r7, #32
    /* The "last time" becomes this timer's expiration time.*/
    delta -= vtp->vt_delta;
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001042:	6819      	ldr	r1, [r3, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 8001044:	f8d3 c00c 	ldr.w	ip, [r3, #12]
      break;
    }

    /* The "last time" becomes this timer's expiration time.*/
    delta -= vtp->vt_delta;
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8001048:	4402      	add	r2, r0
 800104a:	62a2      	str	r2, [r4, #40]	; 0x28

    /* The timer is removed from the list and marked as non-armed.*/
    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800104c:	604e      	str	r6, [r1, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 800104e:	61e1      	str	r1, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = (vtfunc_t)NULL;
 8001050:	f8c3 800c 	str.w	r8, [r3, #12]
 8001054:	f388 8811 	msr	BASEPRI, r8

    /* The callback is invoked outside the kernel critical zone.*/
    chSysUnlockFromISR();
    fn(vtp->vt_par);
 8001058:	6918      	ldr	r0, [r3, #16]
 800105a:	47e0      	blx	ip
 800105c:	f387 8811 	msr	BASEPRI, r7
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8001060:	69e3      	ldr	r3, [r4, #28]
 8001062:	6a69      	ldr	r1, [r5, #36]	; 0x24
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8001064:	6aa2      	ldr	r2, [r4, #40]	; 0x28

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 8001066:	6898      	ldr	r0, [r3, #8]
    systime_t delta;

    /* Getting the current system time and calculating the time window since
       the last time has expired.*/
    now = chVTGetSystemTimeX();
    delta = now - ch.vtlist.vt_lasttime;
 8001068:	ebc2 0e01 	rsb	lr, r2, r1

    /* The next element is outside the current time window, the loop
       is stopped here.*/
    if ((vtp = ch.vtlist.vt_next)->vt_delta > delta) {
 800106c:	4586      	cmp	lr, r0
 800106e:	d2e8      	bcs.n	8001042 <chSysTimerHandlerI+0x22>
    /* The callback is invoked outside the kernel critical zone.*/
    chSysUnlockFromISR();
    fn(vtp->vt_par);
    chSysLockFromISR();
  }
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001070:	42b3      	cmp	r3, r6
 8001072:	d00b      	beq.n	800108c <chSysTimerHandlerI+0x6c>
    port_timer_stop_alarm();
  }
  else {
    /* Updating the alarm to the next deadline, deadline that must not be
       closer in time than the minimum time delta.*/
    if (vtp->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 8001074:	2801      	cmp	r0, #1
 8001076:	d004      	beq.n	8001082 <chSysTimerHandlerI+0x62>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8001078:	4408      	add	r0, r1
#endif
  chVTDoTickI();
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 800107a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800107e:	f001 b83f 	b.w	8002100 <stSetAlarm>
 8001082:	1c88      	adds	r0, r1, #2
 8001084:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8001088:	f001 b83a 	b.w	8002100 <stSetAlarm>
 800108c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 8001090:	f001 b82e 	b.w	80020f0 <stStopAlarm>
 8001094:	20000ef0 	.word	0x20000ef0
 8001098:	f3af 8000 	nop.w
 800109c:	f3af 8000 	nop.w

080010a0 <chSysGetStatusAndLockX>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
 80010a0:	f3ef 8012 	mrs	r0, BASEPRI_MAX
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 80010a4:	b920      	cbnz	r0, 80010b0 <chSysGetStatusAndLockX+0x10>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80010a6:	f3ef 8305 	mrs	r3, IPSR

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80010aa:	2320      	movs	r3, #32
 80010ac:	f383 8811 	msr	BASEPRI, r3
    else {
      chSysLock();
    }
  }
  return sts;
}
 80010b0:	4770      	bx	lr
 80010b2:	bf00      	nop
 80010b4:	f3af 8000 	nop.w
 80010b8:	f3af 8000 	nop.w
 80010bc:	f3af 8000 	nop.w

080010c0 <chSysRestoreStatusX>:
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 80010c0:	b968      	cbnz	r0, 80010de <chSysRestoreStatusX+0x1e>
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 80010c2:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80010c4:	f3ef 8405 	mrs	r4, IPSR
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {

  return (bool)((__get_IPSR() & 0x1FF) != 0);
 80010c8:	f3c4 0408 	ubfx	r4, r4, #0, #9

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 80010cc:	b114      	cbz	r4, 80010d4 <chSysRestoreStatusX+0x14>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80010ce:	f380 8811 	msr	BASEPRI, r0
 80010d2:	bd10      	pop	{r4, pc}
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 80010d4:	f000 f96c 	bl	80013b0 <chSchRescheduleS>
 80010d8:	f384 8811 	msr	BASEPRI, r4
 80010dc:	bd10      	pop	{r4, pc}
 80010de:	4770      	bx	lr

080010e0 <chSysPolledDelayX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80010e0:	4908      	ldr	r1, [pc, #32]	; (8001104 <chSysPolledDelayX+0x24>)
 80010e2:	684a      	ldr	r2, [r1, #4]
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;
 80010e4:	4410      	add	r0, r2
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return end > start ? (cnt >= start) && (cnt < end) :
 80010e6:	4290      	cmp	r0, r2
 80010e8:	684b      	ldr	r3, [r1, #4]
 80010ea:	d902      	bls.n	80010f2 <chSysPolledDelayX+0x12>
 80010ec:	4293      	cmp	r3, r2
 80010ee:	d202      	bcs.n	80010f6 <chSysPolledDelayX+0x16>
 80010f0:	4770      	bx	lr
                       (cnt >= start) || (cnt < end);
 80010f2:	4293      	cmp	r3, r2
 80010f4:	d2f7      	bcs.n	80010e6 <chSysPolledDelayX+0x6>
 80010f6:	4283      	cmp	r3, r0
 80010f8:	bf2c      	ite	cs
 80010fa:	2300      	movcs	r3, #0
 80010fc:	2301      	movcc	r3, #1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 80010fe:	2b00      	cmp	r3, #0
 8001100:	d1f1      	bne.n	80010e6 <chSysPolledDelayX+0x6>
 8001102:	4770      	bx	lr
 8001104:	e0001000 	.word	0xe0001000
 8001108:	f3af 8000 	nop.w
 800110c:	f3af 8000 	nop.w

08001110 <chTMStartMeasurementX>:
 8001110:	4b01      	ldr	r3, [pc, #4]	; (8001118 <chTMStartMeasurementX+0x8>)
 8001112:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8001114:	6083      	str	r3, [r0, #8]
 8001116:	4770      	bx	lr
 8001118:	e0001000 	.word	0xe0001000
 800111c:	f3af 8000 	nop.w

08001120 <chTMStopMeasurementX>:
 8001120:	4b0f      	ldr	r3, [pc, #60]	; (8001160 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8001122:	4910      	ldr	r1, [pc, #64]	; (8001164 <chTMStopMeasurementX+0x44>)
 8001124:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
 8001126:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8001128:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800112a:	6f4f      	ldr	r7, [r1, #116]	; 0x74

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800112c:	68c6      	ldr	r6, [r0, #12]
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 800112e:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8001130:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = now - tmp->last - offset;
 8001134:	1ad3      	subs	r3, r2, r3
 8001136:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 8001138:	18e4      	adds	r4, r4, r3
 800113a:	f145 0500 	adc.w	r5, r5, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800113e:	3601      	adds	r6, #1
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8001140:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8001142:	60c6      	str	r6, [r0, #12]
  tmp->last = now - tmp->last - offset;
 8001144:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8001146:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
 800114a:	d805      	bhi.n	8001158 <chTMStopMeasurementX+0x38>
    tmp->worst = tmp->last;
  }
  else if (tmp->last < tmp->best) {
 800114c:	6802      	ldr	r2, [r0, #0]
 800114e:	4293      	cmp	r3, r2
    tmp->best = tmp->last;
 8001150:	bf38      	it	cc
 8001152:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8001154:	bcf0      	pop	{r4, r5, r6, r7}
 8001156:	4770      	bx	lr

  tmp->n++;
  tmp->last = now - tmp->last - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8001158:	6043      	str	r3, [r0, #4]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 800115a:	bcf0      	pop	{r4, r5, r6, r7}
 800115c:	4770      	bx	lr
 800115e:	bf00      	nop
 8001160:	e0001000 	.word	0xe0001000
 8001164:	20000ef0 	.word	0x20000ef0
 8001168:	f3af 8000 	nop.w
 800116c:	f3af 8000 	nop.w

08001170 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001170:	b5d0      	push	{r4, r6, r7, lr}
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 8001172:	4c0c      	ldr	r4, [pc, #48]	; (80011a4 <_tm_init+0x34>)
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001174:	b086      	sub	sp, #24
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 8001176:	2300      	movs	r3, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8001178:	f04f 32ff 	mov.w	r2, #4294967295
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 800117c:	4668      	mov	r0, sp

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800117e:	2600      	movs	r6, #0
 8001180:	2700      	movs	r7, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
 8001182:	6763      	str	r3, [r4, #116]	; 0x74
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8001184:	9301      	str	r3, [sp, #4]
  tmp->last       = (rtcnt_t)0;
 8001186:	9302      	str	r3, [sp, #8]
  tmp->n          = (ucnt_t)0;
 8001188:	9303      	str	r3, [sp, #12]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 800118a:	9200      	str	r2, [sp, #0]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800118c:	e9cd 6704 	strd	r6, r7, [sp, #16]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = 0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8001190:	f7ff ffbe 	bl	8001110 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8001194:	4668      	mov	r0, sp
 8001196:	f7ff ffc3 	bl	8001120 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 800119a:	9b02      	ldr	r3, [sp, #8]
 800119c:	6763      	str	r3, [r4, #116]	; 0x74
}
 800119e:	b006      	add	sp, #24
 80011a0:	bdd0      	pop	{r4, r6, r7, pc}
 80011a2:	bf00      	nop
 80011a4:	20000ef0 	.word	0x20000ef0
 80011a8:	f3af 8000 	nop.w
 80011ac:	f3af 8000 	nop.w

080011b0 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80011b0:	b410      	push	{r4}
 80011b2:	2320      	movs	r3, #32
 80011b4:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 80011b8:	7f03      	ldrb	r3, [r0, #28]
 80011ba:	2b07      	cmp	r3, #7
 80011bc:	d80e      	bhi.n	80011dc <wakeup+0x2c>
 80011be:	e8df f003 	tbb	[pc, r3]
 80011c2:	0d27      	.short	0x0d27
 80011c4:	0408230d 	.word	0x0408230d
 80011c8:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *(thread_reference_t *)tp->p_u.wtobjp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES
  case CH_STATE_WTSEM:
    chSemFastSignalI((semaphore_t *)tp->p_u.wtobjp);
 80011ca:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 80011cc:	6893      	ldr	r3, [r2, #8]
 80011ce:	3301      	adds	r3, #1
 80011d0:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80011d2:	e890 000c 	ldmia.w	r0, {r2, r3}
 80011d6:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80011d8:	6802      	ldr	r2, [r0, #0]
 80011da:	6053      	str	r3, [r2, #4]
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80011dc:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80011e0:	2200      	movs	r2, #0
 80011e2:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 80011e4:	4b0d      	ldr	r3, [pc, #52]	; (800121c <wakeup+0x6c>)
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80011e6:	6204      	str	r4, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80011e8:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 80011ea:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80011ec:	689a      	ldr	r2, [r3, #8]
 80011ee:	428a      	cmp	r2, r1
 80011f0:	d2fb      	bcs.n	80011ea <wakeup+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80011f2:	685a      	ldr	r2, [r3, #4]
 80011f4:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80011f6:	6003      	str	r3, [r0, #0]
 80011f8:	2100      	movs	r1, #0
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 80011fa:	6058      	str	r0, [r3, #4]
 80011fc:	6010      	str	r0, [r2, #0]
 80011fe:	f381 8811 	msr	BASEPRI, r1
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001202:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001206:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *(thread_reference_t *)tp->p_u.wtobjp = NULL;
 8001208:	6a03      	ldr	r3, [r0, #32]
 800120a:	2200      	movs	r2, #0
 800120c:	601a      	str	r2, [r3, #0]
    break;
 800120e:	e7e5      	b.n	80011dc <wakeup+0x2c>
 8001210:	2300      	movs	r3, #0
 8001212:	f383 8811 	msr	BASEPRI, r3
    queue_dequeue(tp);
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001216:	f85d 4b04 	ldr.w	r4, [sp], #4
 800121a:	4770      	bx	lr
 800121c:	20000ef0 	.word	0x20000ef0

08001220 <_scheduler_init>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8001220:	4b03      	ldr	r3, [pc, #12]	; (8001230 <_scheduler_init+0x10>)
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8001222:	2200      	movs	r2, #0
 8001224:	605b      	str	r3, [r3, #4]
 8001226:	601b      	str	r3, [r3, #0]
#if CH_CFG_USE_REGISTRY
  ch.rlist.r_newer = ch.rlist.r_older = (thread_t *)&ch.rlist;
 8001228:	615b      	str	r3, [r3, #20]
 800122a:	611b      	str	r3, [r3, #16]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 800122c:	609a      	str	r2, [r3, #8]
 800122e:	4770      	bx	lr
 8001230:	20000ef0 	.word	0x20000ef0
 8001234:	f3af 8000 	nop.w
 8001238:	f3af 8000 	nop.w
 800123c:	f3af 8000 	nop.w

08001240 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001240:	2200      	movs	r2, #0
 8001242:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001244:	4b08      	ldr	r3, [pc, #32]	; (8001268 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8001246:	b410      	push	{r4}
 8001248:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800124a:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800124c:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800124e:	689a      	ldr	r2, [r3, #8]
 8001250:	428a      	cmp	r2, r1
 8001252:	d2fb      	bcs.n	800124c <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001254:	685a      	ldr	r2, [r3, #4]
 8001256:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001258:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;

  return tp;
}
 800125a:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 800125c:	605c      	str	r4, [r3, #4]
 800125e:	6014      	str	r4, [r2, #0]

  return tp;
}
 8001260:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001264:	4770      	bx	lr
 8001266:	bf00      	nop
 8001268:	20000ef0 	.word	0x20000ef0
 800126c:	f3af 8000 	nop.w

08001270 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8001270:	4b07      	ldr	r3, [pc, #28]	; (8001290 <chSchGoSleepS+0x20>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8001272:	b430      	push	{r4, r5}
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001274:	681a      	ldr	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  (otp = currp)->p_state = newstate;
 8001276:	6999      	ldr	r1, [r3, #24]

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8001278:	6814      	ldr	r4, [r2, #0]
 800127a:	7708      	strb	r0, [r1, #28]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800127c:	2501      	movs	r5, #1
 800127e:	6063      	str	r3, [r4, #4]
 8001280:	7715      	strb	r5, [r2, #28]
 8001282:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 8001284:	4610      	mov	r0, r2
}
 8001286:	bc30      	pop	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001288:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 800128a:	f7ff b899 	b.w	80003c0 <_port_switch>
 800128e:	bf00      	nop
 8001290:	20000ef0 	.word	0x20000ef0
 8001294:	f3af 8000 	nop.w
 8001298:	f3af 8000 	nop.w
 800129c:	f3af 8000 	nop.w

080012a0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80012a0:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80012a2:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80012a4:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80012a6:	d012      	beq.n	80012ce <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80012a8:	4c0c      	ldr	r4, [pc, #48]	; (80012dc <chSchGoSleepTimeoutS+0x3c>)
 80012aa:	4a0d      	ldr	r2, [pc, #52]	; (80012e0 <chSchGoSleepTimeoutS+0x40>)
 80012ac:	69a3      	ldr	r3, [r4, #24]
 80012ae:	4605      	mov	r5, r0
 80012b0:	a801      	add	r0, sp, #4
 80012b2:	f000 f8a5 	bl	8001400 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80012b6:	4628      	mov	r0, r5
 80012b8:	f7ff ffda 	bl	8001270 <chSchGoSleepS>
    if (chVTIsArmedI(&vt))
 80012bc:	9b04      	ldr	r3, [sp, #16]
 80012be:	b113      	cbz	r3, 80012c6 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 80012c0:	a801      	add	r0, sp, #4
 80012c2:	f000 f8d5 	bl	8001470 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 80012c6:	69a3      	ldr	r3, [r4, #24]
}
 80012c8:	6a18      	ldr	r0, [r3, #32]
 80012ca:	b007      	add	sp, #28
 80012cc:	bd30      	pop	{r4, r5, pc}
 80012ce:	4c03      	ldr	r4, [pc, #12]	; (80012dc <chSchGoSleepTimeoutS+0x3c>)
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt))
      chVTDoResetI(&vt);
  }
  else {
    chSchGoSleepS(newstate);
 80012d0:	f7ff ffce 	bl	8001270 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 80012d4:	69a3      	ldr	r3, [r4, #24]
}
 80012d6:	6a18      	ldr	r0, [r3, #32]
 80012d8:	b007      	add	sp, #28
 80012da:	bd30      	pop	{r4, r5, pc}
 80012dc:	20000ef0 	.word	0x20000ef0
 80012e0:	080011b1 	.word	0x080011b1
 80012e4:	f3af 8000 	nop.w
 80012e8:	f3af 8000 	nop.w
 80012ec:	f3af 8000 	nop.w

080012f0 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80012f0:	4b14      	ldr	r3, [pc, #80]	; (8001344 <chSchWakeupS+0x54>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80012f2:	b4f0      	push	{r4, r5, r6, r7}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80012f4:	699e      	ldr	r6, [r3, #24]
 80012f6:	6884      	ldr	r4, [r0, #8]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80012f8:	4605      	mov	r5, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80012fa:	68b0      	ldr	r0, [r6, #8]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 80012fc:	6229      	str	r1, [r5, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80012fe:	4284      	cmp	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001300:	f04f 0200 	mov.w	r2, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001304:	d80b      	bhi.n	800131e <chSchWakeupS+0x2e>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001306:	772a      	strb	r2, [r5, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8001308:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800130a:	689a      	ldr	r2, [r3, #8]
 800130c:	4294      	cmp	r4, r2
 800130e:	d9fb      	bls.n	8001308 <chSchWakeupS+0x18>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001310:	685a      	ldr	r2, [r3, #4]
 8001312:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001314:	602b      	str	r3, [r5, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8001316:	605d      	str	r5, [r3, #4]
 8001318:	6015      	str	r5, [r2, #0]
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 800131a:	bcf0      	pop	{r4, r5, r6, r7}
 800131c:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800131e:	7732      	strb	r2, [r6, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001320:	461a      	mov	r2, r3
  do {
    cp = cp->p_next;
 8001322:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 8001324:	6891      	ldr	r1, [r2, #8]
 8001326:	4288      	cmp	r0, r1
 8001328:	d9fb      	bls.n	8001322 <chSchWakeupS+0x32>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800132a:	6854      	ldr	r4, [r2, #4]
 800132c:	6074      	str	r4, [r6, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800132e:	2701      	movs	r7, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001330:	6032      	str	r2, [r6, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8001332:	6056      	str	r6, [r2, #4]
 8001334:	6026      	str	r6, [r4, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8001336:	772f      	strb	r7, [r5, #28]
    chSysSwitch(ntp, otp);
 8001338:	4631      	mov	r1, r6
 800133a:	4628      	mov	r0, r5
  if (ntp->p_prio <= currp->p_prio) {
    chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 800133c:	619d      	str	r5, [r3, #24]
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 800133e:	bcf0      	pop	{r4, r5, r6, r7}
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8001340:	f7ff b83e 	b.w	80003c0 <_port_switch>
 8001344:	20000ef0 	.word	0x20000ef0
 8001348:	f3af 8000 	nop.w
 800134c:	f3af 8000 	nop.w

08001350 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8001350:	4b04      	ldr	r3, [pc, #16]	; (8001364 <chSchIsPreemptionRequired+0x14>)
 8001352:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = currp->p_prio;
 8001354:	699b      	ldr	r3, [r3, #24]
     if the first thread on the ready queue has equal or higher priority.*/
  return currp->p_preempt ? p1 > p2 : p1 >= p2;
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8001356:	6890      	ldr	r0, [r2, #8]
 8001358:	689b      	ldr	r3, [r3, #8]
#endif
}
 800135a:	4298      	cmp	r0, r3
 800135c:	bf94      	ite	ls
 800135e:	2000      	movls	r0, #0
 8001360:	2001      	movhi	r0, #1
 8001362:	4770      	bx	lr
 8001364:	20000ef0 	.word	0x20000ef0
 8001368:	f3af 8000 	nop.w
 800136c:	f3af 8000 	nop.w

08001370 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8001370:	4a0d      	ldr	r2, [pc, #52]	; (80013a8 <chSchDoRescheduleAhead+0x38>)
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001372:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8001374:	b470      	push	{r4, r5, r6}

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8001376:	6803      	ldr	r3, [r0, #0]
  thread_t *otp, *cp;

  otp = currp;
 8001378:	6994      	ldr	r4, [r2, #24]
 800137a:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800137c:	2601      	movs	r6, #1

  otp->p_state = CH_STATE_READY;
 800137e:	2500      	movs	r5, #0
 8001380:	68a1      	ldr	r1, [r4, #8]
 8001382:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001384:	7706      	strb	r6, [r0, #28]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001386:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8001388:	7725      	strb	r5, [r4, #28]
 800138a:	e000      	b.n	800138e <chSchDoRescheduleAhead+0x1e>
 800138c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 800138e:	689a      	ldr	r2, [r3, #8]
 8001390:	428a      	cmp	r2, r1
 8001392:	d8fb      	bhi.n	800138c <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8001394:	685a      	ldr	r2, [r3, #4]
 8001396:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8001398:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 800139a:	4621      	mov	r1, r4
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;
 800139c:	605c      	str	r4, [r3, #4]
 800139e:	6014      	str	r4, [r2, #0]

  chSysSwitch(currp, otp);
}
 80013a0:	bc70      	pop	{r4, r5, r6}
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = cp->p_prev = otp;

  chSysSwitch(currp, otp);
 80013a2:	f7ff b80d 	b.w	80003c0 <_port_switch>
 80013a6:	bf00      	nop
 80013a8:	20000ef0 	.word	0x20000ef0
 80013ac:	f3af 8000 	nop.w

080013b0 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 80013b0:	4b04      	ldr	r3, [pc, #16]	; (80013c4 <chSchRescheduleS+0x14>)
 80013b2:	681a      	ldr	r2, [r3, #0]
 80013b4:	699b      	ldr	r3, [r3, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 80013b6:	6892      	ldr	r2, [r2, #8]
 80013b8:	689b      	ldr	r3, [r3, #8]
 80013ba:	429a      	cmp	r2, r3
 80013bc:	d800      	bhi.n	80013c0 <chSchRescheduleS+0x10>
 80013be:	4770      	bx	lr
    chSchDoRescheduleAhead();
 80013c0:	f7ff bfd6 	b.w	8001370 <chSchDoRescheduleAhead>
 80013c4:	20000ef0 	.word	0x20000ef0
 80013c8:	f3af 8000 	nop.w
 80013cc:	f3af 8000 	nop.w

080013d0 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 80013d0:	f7ff bfce 	b.w	8001370 <chSchDoRescheduleAhead>
 80013d4:	f3af 8000 	nop.w
 80013d8:	f3af 8000 	nop.w
 80013dc:	f3af 8000 	nop.w

080013e0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 80013e0:	4b05      	ldr	r3, [pc, #20]	; (80013f8 <_vt_init+0x18>)
  ch.vtlist.vt_delta = (systime_t)-1;
 80013e2:	f04f 30ff 	mov.w	r0, #4294967295
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 80013e6:	f103 021c 	add.w	r2, r3, #28
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = 0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = 0;
 80013ea:	2100      	movs	r1, #0
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 80013ec:	6258      	str	r0, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = 0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = 0;
 80013ee:	6299      	str	r1, [r3, #40]	; 0x28
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = ch.vtlist.vt_prev = (void *)&ch.vtlist;
 80013f0:	621a      	str	r2, [r3, #32]
 80013f2:	61da      	str	r2, [r3, #28]
 80013f4:	4770      	bx	lr
 80013f6:	bf00      	nop
 80013f8:	20000ef0 	.word	0x20000ef0
 80013fc:	f3af 8000 	nop.w

08001400 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8001400:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = ch.vtlist.vt_next;
 8001402:	4f1a      	ldr	r7, [pc, #104]	; (800146c <chVTDoSetI+0x6c>)
 8001404:	46be      	mov	lr, r7
    systime_t now = port_timer_get_time();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
 8001406:	2901      	cmp	r1, #1
 8001408:	bf8c      	ite	hi
 800140a:	460d      	movhi	r5, r1
 800140c:	2502      	movls	r5, #2
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
  p = ch.vtlist.vt_next;
 800140e:	f85e 4f1c 	ldr.w	r4, [lr, #28]!
  virtual_timer_t *p;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8001412:	6103      	str	r3, [r0, #16]
 8001414:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
 8001418:	4574      	cmp	r4, lr

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 800141a:	60c2      	str	r2, [r0, #12]
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 800141c:	4606      	mov	r6, r0
 800141e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
       is raised to the minimum safe value.*/
    if (delay < CH_CFG_ST_TIMEDELTA) {
      delay = CH_CFG_ST_TIMEDELTA;
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
 8001420:	d01d      	beq.n	800145e <chVTDoSetI+0x5e>
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
    }
    else {
      /* Now the delay is calculated as delta from the last tick interrupt
         time.*/
      delay += now - ch.vtlist.vt_lasttime;
 8001422:	6ab8      	ldr	r0, [r7, #40]	; 0x28

      /* If the specified delay is closer in time than the first element
         in the delta list then it becomes the next alarm event in time.*/
      if (delay < p->vt_delta) {
 8001424:	68a3      	ldr	r3, [r4, #8]
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
    }
    else {
      /* Now the delay is calculated as delta from the last tick interrupt
         time.*/
      delay += now - ch.vtlist.vt_lasttime;
 8001426:	1a12      	subs	r2, r2, r0
 8001428:	4415      	add	r5, r2

      /* If the specified delay is closer in time than the first element
         in the delta list then it becomes the next alarm event in time.*/
      if (delay < p->vt_delta) {
 800142a:	429d      	cmp	r5, r3
 800142c:	d203      	bcs.n	8001436 <chVTDoSetI+0x36>
 800142e:	e011      	b.n	8001454 <chVTDoSetI+0x54>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
    delay -= p->vt_delta;
    p = p->vt_next;
 8001430:	6824      	ldr	r4, [r4, #0]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
    delay -= p->vt_delta;
 8001432:	1aed      	subs	r5, r5, r3
  }
#endif /* CH_CFG_ST_TIMEDELTA > 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delay) {
 8001434:	68a3      	ldr	r3, [r4, #8]
 8001436:	42ab      	cmp	r3, r5
 8001438:	d3fa      	bcc.n	8001430 <chVTDoSetI+0x30>
    delay -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_prev = (vtp->vt_next = p)->vt_prev;
 800143a:	6863      	ldr	r3, [r4, #4]
 800143c:	6073      	str	r3, [r6, #4]
 800143e:	6034      	str	r4, [r6, #0]
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
 8001440:	6066      	str	r6, [r4, #4]
 8001442:	601e      	str	r6, [r3, #0]
  vtp->vt_delta = delay
 8001444:	60b5      	str	r5, [r6, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delay;
 8001446:	68a1      	ldr	r1, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8001448:	f04f 33ff 	mov.w	r3, #4294967295
  vtp->vt_prev->vt_next = p->vt_prev = vtp;
  vtp->vt_delta = delay

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delay;
 800144c:	1b49      	subs	r1, r1, r5
 800144e:	60a1      	str	r1, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8001450:	627b      	str	r3, [r7, #36]	; 0x24
 8001452:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8001454:	4428      	add	r0, r5
 8001456:	f000 fe53 	bl	8002100 <stSetAlarm>
 800145a:	68a3      	ldr	r3, [r4, #8]
 800145c:	e7eb      	b.n	8001436 <chVTDoSetI+0x36>
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {

  stStartAlarm(time);
 800145e:	18a8      	adds	r0, r5, r2
    }

    if (&ch.vtlist == (virtual_timers_list_t *)p) {
      /* The delta list is empty, the current time becomes the new
         delta list base time.*/
      ch.vtlist.vt_lasttime = now;
 8001460:	62ba      	str	r2, [r7, #40]	; 0x28
 8001462:	f000 fe3d 	bl	80020e0 <stStartAlarm>
 8001466:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001468:	e7e5      	b.n	8001436 <chVTDoSetI+0x36>
 800146a:	bf00      	nop
 800146c:	20000ef0 	.word	0x20000ef0

08001470 <chVTDoResetI>:
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8001470:	6802      	ldr	r2, [r0, #0]
 8001472:	6883      	ldr	r3, [r0, #8]
 8001474:	6891      	ldr	r1, [r2, #8]
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8001476:	b430      	push	{r4, r5}
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8001478:	4c10      	ldr	r4, [pc, #64]	; (80014bc <chVTDoResetI+0x4c>)
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
 800147a:	6845      	ldr	r5, [r0, #4]
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 800147c:	4419      	add	r1, r3
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800147e:	4623      	mov	r3, r4
  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8001480:	6091      	str	r1, [r2, #8]
  vtp->vt_prev->vt_next = vtp->vt_next;
 8001482:	602a      	str	r2, [r5, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8001484:	6801      	ldr	r1, [r0, #0]
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001486:	f853 2f1c 	ldr.w	r2, [r3, #28]!
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
 800148a:	604d      	str	r5, [r1, #4]
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800148c:	429a      	cmp	r2, r3

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;
 800148e:	f04f 0500 	mov.w	r5, #0

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8001492:	f04f 31ff 	mov.w	r1, #4294967295

  /* Removing the element from the delta list.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
  vtp->vt_prev->vt_next = vtp->vt_next;
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = (vtfunc_t)NULL;
 8001496:	60c5      	str	r5, [r0, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8001498:	6261      	str	r1, [r4, #36]	; 0x24

#if CH_CFG_ST_TIMEDELTA > 0 || defined(__DOXYGEN__)
  {
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800149a:	d00b      	beq.n	80014b4 <chVTDoResetI+0x44>
      port_timer_stop_alarm();
    }
    else {
      /* Updating the alarm to the next deadline, deadline that must not be
         closer in time than the minimum time delta.*/
      if (ch.vtlist.vt_next->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 800149c:	6893      	ldr	r3, [r2, #8]
        port_timer_set_alarm(ch.vtlist.vt_lasttime +
 800149e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
      port_timer_stop_alarm();
    }
    else {
      /* Updating the alarm to the next deadline, deadline that must not be
         closer in time than the minimum time delta.*/
      if (ch.vtlist.vt_next->vt_delta >= CH_CFG_ST_TIMEDELTA) {
 80014a0:	2b01      	cmp	r3, #1
 80014a2:	d903      	bls.n	80014ac <chVTDoResetI+0x3c>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 80014a4:	4418      	add	r0, r3
                             CH_CFG_ST_TIMEDELTA);
      }
    }
  }
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80014a6:	bc30      	pop	{r4, r5}
 80014a8:	f000 be2a 	b.w	8002100 <stSetAlarm>
 80014ac:	3002      	adds	r0, #2
 80014ae:	bc30      	pop	{r4, r5}
 80014b0:	f000 be26 	b.w	8002100 <stSetAlarm>
 80014b4:	bc30      	pop	{r4, r5}
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 80014b6:	f000 be1b 	b.w	80020f0 <stStopAlarm>
 80014ba:	bf00      	nop
 80014bc:	20000ef0 	.word	0x20000ef0

080014c0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 80014c0:	b5f0      	push	{r4, r5, r6, r7, lr}
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80014c2:	4c0e      	ldr	r4, [pc, #56]	; (80014fc <_thread_init+0x3c>)
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
 80014c4:	63c1      	str	r1, [r0, #60]	; 0x3c
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80014c6:	6966      	ldr	r6, [r4, #20]
 80014c8:	6146      	str	r6, [r0, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80014ca:	2200      	movs	r2, #0
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 80014cc:	f100 0528 	add.w	r5, r0, #40	; 0x28
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80014d0:	f04f 0c02 	mov.w	ip, #2
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 80014d4:	f04f 0e01 	mov.w	lr, #1
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
 80014d8:	f100 0724 	add.w	r7, r0, #36	; 0x24
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80014dc:	6081      	str	r1, [r0, #8]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80014de:	6104      	str	r4, [r0, #16]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80014e0:	f880 c01c 	strb.w	ip, [r0, #28]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80014e4:	6160      	str	r0, [r4, #20]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 80014e6:	f880 e01e 	strb.w	lr, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80014ea:	7742      	strb	r2, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80014ec:	6382      	str	r2, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS
  tp->p_epending = 0;
 80014ee:	6342      	str	r2, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
 80014f0:	6182      	str	r2, [r0, #24]
  REG_INSERT(tp);
 80014f2:	6130      	str	r0, [r6, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80014f4:	6247      	str	r7, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 80014f6:	62c5      	str	r5, [r0, #44]	; 0x2c
 80014f8:	6285      	str	r5, [r0, #40]	; 0x28
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
 80014fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80014fc:	20000ef0 	.word	0x20000ef0

08001500 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8001500:	e92d 4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001504:	3964      	subs	r1, #100	; 0x64
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001506:	4f16      	ldr	r7, [pc, #88]	; (8001560 <chThdCreateI+0x60>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001508:	f8df 9058 	ldr.w	r9, [pc, #88]	; 8001564 <chThdCreateI+0x64>
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 800150c:	f8d7 e014 	ldr.w	lr, [r7, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001510:	4401      	add	r1, r0
 8001512:	60c1      	str	r1, [r0, #12]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001514:	2500      	movs	r5, #0

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001516:	640b      	str	r3, [r1, #64]	; 0x40
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8001518:	4694      	mov	ip, r2
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800151a:	f04f 0b02 	mov.w	fp, #2
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 800151e:	f100 0228 	add.w	r2, r0, #40	; 0x28
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8001522:	f04f 0a01 	mov.w	sl, #1
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
 8001526:	f100 0624 	add.w	r6, r0, #36	; 0x24

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800152a:	9b08      	ldr	r3, [sp, #32]
 800152c:	644b      	str	r3, [r1, #68]	; 0x44
 800152e:	f8c1 9060 	str.w	r9, [r1, #96]	; 0x60
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001532:	f8c0 c008 	str.w	ip, [r0, #8]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001536:	6107      	str	r7, [r0, #16]
 8001538:	f8c0 e014 	str.w	lr, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
 800153c:	f8c0 c03c 	str.w	ip, [r0, #60]	; 0x3c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001540:	f880 b01c 	strb.w	fp, [r0, #28]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8001544:	f880 a01e 	strb.w	sl, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001548:	7745      	strb	r5, [r0, #29]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 800154a:	6178      	str	r0, [r7, #20]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800154c:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS
  tp->p_epending = 0;
 800154e:	6345      	str	r5, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
 8001550:	6185      	str	r5, [r0, #24]
  REG_INSERT(tp);
 8001552:	f8ce 0010 	str.w	r0, [lr, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001556:	6246      	str	r6, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8001558:	62c2      	str	r2, [r0, #44]	; 0x2c
 800155a:	6282      	str	r2, [r0, #40]	; 0x28
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);

  return _thread_init(tp, prio);
}
 800155c:	e8bd 8ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
 8001560:	20000ef0 	.word	0x20000ef0
 8001564:	080003d9 	.word	0x080003d9
 8001568:	f3af 8000 	nop.w
 800156c:	f3af 8000 	nop.w

08001570 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8001570:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001574:	469a      	mov	sl, r3
 8001576:	4604      	mov	r4, r0
 8001578:	2320      	movs	r3, #32
 800157a:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 800157e:	4e19      	ldr	r6, [pc, #100]	; (80015e4 <chThdCreateStatic+0x74>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001580:	9b0a      	ldr	r3, [sp, #40]	; 0x28
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001582:	f8d6 b014 	ldr.w	fp, [r6, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001586:	f8df 9060 	ldr.w	r9, [pc, #96]	; 80015e8 <chThdCreateStatic+0x78>
 800158a:	3964      	subs	r1, #100	; 0x64
 800158c:	4401      	add	r1, r0
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800158e:	2500      	movs	r5, #0
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES
  queue_init(&tp->p_msgqueue);
 8001590:	f100 0728 	add.w	r7, r0, #40	; 0x28
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 8001594:	f04f 0c01 	mov.w	ip, #1
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  list_init(&tp->p_waiting);
 8001598:	f100 0e24 	add.w	lr, r0, #36	; 0x24
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800159c:	f04f 0802 	mov.w	r8, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80015a0:	60c1      	str	r1, [r0, #12]
 80015a2:	f8c1 a040 	str.w	sl, [r1, #64]	; 0x40
 80015a6:	644b      	str	r3, [r1, #68]	; 0x44
 80015a8:	f8c1 9060 	str.w	r9, [r1, #96]	; 0x60
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80015ac:	6082      	str	r2, [r0, #8]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80015ae:	6106      	str	r6, [r0, #16]
 80015b0:	f8c0 b014 	str.w	fp, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
 80015b4:	63c2      	str	r2, [r0, #60]	; 0x3c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80015b6:	f880 801c 	strb.w	r8, [r0, #28]
#endif
#if CH_DBG_THREADS_PROFILING
  tp->p_time = 0;
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
 80015ba:	f880 c01e 	strb.w	ip, [r0, #30]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80015be:	7745      	strb	r5, [r0, #29]
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80015c0:	6170      	str	r0, [r6, #20]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80015c2:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS
  tp->p_epending = 0;
 80015c4:	6345      	str	r5, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
 80015c6:	6185      	str	r5, [r0, #24]
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), MSG_OK);
 80015c8:	4629      	mov	r1, r5
#if CH_CFG_USE_DYNAMIC
  tp->p_refs = 1;
#endif
#if CH_CFG_USE_REGISTRY
  tp->p_name = NULL;
  REG_INSERT(tp);
 80015ca:	f8cb 0010 	str.w	r0, [fp, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80015ce:	f8c0 e024 	str.w	lr, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 80015d2:	62c7      	str	r7, [r0, #44]	; 0x2c
 80015d4:	6287      	str	r7, [r0, #40]	; 0x28
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  chSchWakeupS(tp = chThdCreateI(wsp, size, prio, pf, arg), MSG_OK);
 80015d6:	f7ff fe8b 	bl	80012f0 <chSchWakeupS>
 80015da:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 80015de:	4620      	mov	r0, r4
 80015e0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80015e4:	20000ef0 	.word	0x20000ef0
 80015e8:	080003d9 	.word	0x080003d9
 80015ec:	f3af 8000 	nop.w

080015f0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80015f0:	b508      	push	{r3, lr}
 80015f2:	4601      	mov	r1, r0
 80015f4:	2320      	movs	r3, #32
 80015f6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80015fa:	2008      	movs	r0, #8
 80015fc:	f7ff fe50 	bl	80012a0 <chSchGoSleepTimeoutS>
 8001600:	2300      	movs	r3, #0
 8001602:	f383 8811 	msr	BASEPRI, r3
 8001606:	bd08      	pop	{r3, pc}
 8001608:	f3af 8000 	nop.w
 800160c:	f3af 8000 	nop.w

08001610 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001610:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8001612:	4b0e      	ldr	r3, [pc, #56]	; (800164c <chThdExitS+0x3c>)
 8001614:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001616:	6a63      	ldr	r3, [r4, #36]	; 0x24

  tp->p_u.exitcode = msg;
 8001618:	6220      	str	r0, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  while (list_notempty(&tp->p_waiting)) {
 800161a:	f104 0524 	add.w	r5, r4, #36	; 0x24
 800161e:	429d      	cmp	r5, r3
 8001620:	d007      	beq.n	8001632 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8001622:	681a      	ldr	r2, [r3, #0]
 8001624:	6262      	str	r2, [r4, #36]	; 0x24
    chSchReadyI(list_remove(&tp->p_waiting));
 8001626:	4618      	mov	r0, r3
 8001628:	f7ff fe0a 	bl	8001240 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800162c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT
  while (list_notempty(&tp->p_waiting)) {
 800162e:	42ab      	cmp	r3, r5
 8001630:	d1f7      	bne.n	8001622 <chThdExitS+0x12>
  }
#endif
#if CH_CFG_USE_REGISTRY
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8001632:	7f63      	ldrb	r3, [r4, #29]
 8001634:	079b      	lsls	r3, r3, #30
 8001636:	d104      	bne.n	8001642 <chThdExitS+0x32>
    REG_REMOVE(tp);
 8001638:	6963      	ldr	r3, [r4, #20]
 800163a:	6922      	ldr	r2, [r4, #16]
 800163c:	611a      	str	r2, [r3, #16]
 800163e:	6922      	ldr	r2, [r4, #16]
 8001640:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001642:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8001644:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001648:	f7ff be12 	b.w	8001270 <chSchGoSleepS>
 800164c:	20000ef0 	.word	0x20000ef0

08001650 <chThdExit>:
 8001650:	2320      	movs	r3, #32
 8001652:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 8001656:	f7ff bfdb 	b.w	8001610 <chThdExitS>
 800165a:	bf00      	nop
 800165c:	f3af 8000 	nop.w

08001660 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8001660:	b538      	push	{r3, r4, r5, lr}
 8001662:	4604      	mov	r4, r0
 8001664:	2320      	movs	r3, #32
 8001666:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_DYNAMIC
  chDbgAssert(tp->p_refs > 0, "not referenced");
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 800166a:	7f03      	ldrb	r3, [r0, #28]
 800166c:	2b0f      	cmp	r3, #15
 800166e:	d007      	beq.n	8001680 <chThdWait+0x20>
    list_insert(currp, &tp->p_waiting);
 8001670:	4b08      	ldr	r3, [pc, #32]	; (8001694 <chThdWait+0x34>)
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->p_next = tlp->p_next;
 8001672:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001674:	699b      	ldr	r3, [r3, #24]
    chSchGoSleepS(CH_STATE_WTEXIT);
 8001676:	2009      	movs	r0, #9
 8001678:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 800167a:	6263      	str	r3, [r4, #36]	; 0x24
 800167c:	f7ff fdf8 	bl	8001270 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 8001680:	6a25      	ldr	r5, [r4, #32]
 8001682:	2300      	movs	r3, #0
 8001684:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

#if CH_CFG_USE_DYNAMIC
  chThdRelease(tp);
 8001688:	4620      	mov	r0, r4
 800168a:	f000 f859 	bl	8001740 <chThdRelease>
#endif

  return msg;
}
 800168e:	4628      	mov	r0, r5
 8001690:	bd38      	pop	{r3, r4, r5, pc}
 8001692:	bf00      	nop
 8001694:	20000ef0 	.word	0x20000ef0
 8001698:	f3af 8000 	nop.w
 800169c:	f3af 8000 	nop.w

080016a0 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 80016a0:	6803      	ldr	r3, [r0, #0]
 80016a2:	b12b      	cbz	r3, 80016b0 <chThdResumeI+0x10>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 80016a4:	2200      	movs	r2, #0
 80016a6:	6002      	str	r2, [r0, #0]
    tp->p_u.rdymsg = msg;
    chSchReadyI(tp);
 80016a8:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 80016aa:	6219      	str	r1, [r3, #32]
    chSchReadyI(tp);
 80016ac:	f7ff bdc8 	b.w	8001240 <chSchReadyI>
 80016b0:	4770      	bx	lr
 80016b2:	bf00      	nop
 80016b4:	f3af 8000 	nop.w
 80016b8:	f3af 8000 	nop.w
 80016bc:	f3af 8000 	nop.w

080016c0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 80016c0:	b169      	cbz	r1, 80016de <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80016c2:	4b08      	ldr	r3, [pc, #32]	; (80016e4 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80016c4:	b410      	push	{r4}
 80016c6:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80016c8:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80016ca:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80016cc:	2004      	movs	r0, #4
 80016ce:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tqp->p_prev = tp;
 80016d2:	6053      	str	r3, [r2, #4]
 80016d4:	6023      	str	r3, [r4, #0]
}
 80016d6:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80016da:	f7ff bde1 	b.w	80012a0 <chSchGoSleepTimeoutS>
}
 80016de:	f04f 30ff 	mov.w	r0, #4294967295
 80016e2:	4770      	bx	lr
 80016e4:	20000ef0 	.word	0x20000ef0
 80016e8:	f3af 8000 	nop.w
 80016ec:	f3af 8000 	nop.w

080016f0 <chThdDequeueNextI>:
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 80016f0:	6802      	ldr	r2, [r0, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 80016f2:	4290      	cmp	r0, r2
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80016f4:	4603      	mov	r3, r0

  if (queue_notempty(tqp)) {
 80016f6:	d009      	beq.n	800170c <chThdDequeueNextI+0x1c>
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80016f8:	b410      	push	{r4}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 80016fa:	6814      	ldr	r4, [r2, #0]
 80016fc:	6004      	str	r4, [r0, #0]
 80016fe:	6063      	str	r3, [r4, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001700:	6211      	str	r1, [r2, #32]
  chSchReadyI(tp);
 8001702:	4610      	mov	r0, r2

  if (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
  }
}
 8001704:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001708:	f7ff bd9a 	b.w	8001240 <chSchReadyI>
 800170c:	4770      	bx	lr
 800170e:	bf00      	nop

08001710 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001710:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 8001712:	6803      	ldr	r3, [r0, #0]

  while (queue_notempty(tqp)) {
 8001714:	4298      	cmp	r0, r3
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001716:	4604      	mov	r4, r0
 8001718:	460d      	mov	r5, r1

  while (queue_notempty(tqp)) {
 800171a:	d009      	beq.n	8001730 <chThdDequeueAllI+0x20>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 800171c:	681a      	ldr	r2, [r3, #0]
 800171e:	6022      	str	r2, [r4, #0]
 8001720:	4618      	mov	r0, r3
 8001722:	6054      	str	r4, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001724:	621d      	str	r5, [r3, #32]
  chSchReadyI(tp);
 8001726:	f7ff fd8b 	bl	8001240 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 800172a:	6823      	ldr	r3, [r4, #0]
 800172c:	429c      	cmp	r4, r3
 800172e:	d1f5      	bne.n	800171c <chThdDequeueAllI+0xc>
 8001730:	bd38      	pop	{r3, r4, r5, pc}
 8001732:	bf00      	nop
 8001734:	f3af 8000 	nop.w
 8001738:	f3af 8000 	nop.w
 800173c:	f3af 8000 	nop.w

08001740 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8001740:	4601      	mov	r1, r0
 8001742:	2320      	movs	r3, #32
 8001744:	f383 8811 	msr	BASEPRI, r3
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > 0, "not referenced");
  refs = --tp->p_refs;
 8001748:	7f83      	ldrb	r3, [r0, #30]
 800174a:	3b01      	subs	r3, #1
 800174c:	b2db      	uxtb	r3, r3
 800174e:	7783      	strb	r3, [r0, #30]
 8001750:	2200      	movs	r2, #0
 8001752:	f382 8811 	msr	BASEPRI, r2
  chSysUnlock();

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == 0) && (tp->p_state == CH_STATE_FINAL)) {
 8001756:	b913      	cbnz	r3, 800175e <chThdRelease+0x1e>
 8001758:	7f03      	ldrb	r3, [r0, #28]
 800175a:	2b0f      	cmp	r3, #15
 800175c:	d000      	beq.n	8001760 <chThdRelease+0x20>
 800175e:	4770      	bx	lr
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 8001760:	7f43      	ldrb	r3, [r0, #29]
 8001762:	f003 0303 	and.w	r3, r3, #3
 8001766:	2b01      	cmp	r3, #1
 8001768:	d002      	beq.n	8001770 <chThdRelease+0x30>
 800176a:	2b02      	cmp	r3, #2
 800176c:	d007      	beq.n	800177e <chThdRelease+0x3e>
 800176e:	4770      	bx	lr
#if CH_CFG_USE_HEAP
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY
      REG_REMOVE(tp);
 8001770:	6943      	ldr	r3, [r0, #20]
 8001772:	6902      	ldr	r2, [r0, #16]
 8001774:	611a      	str	r2, [r3, #16]
 8001776:	6902      	ldr	r2, [r0, #16]
 8001778:	6153      	str	r3, [r2, #20]
#endif
      chHeapFree(tp);
 800177a:	f000 bb29 	b.w	8001dd0 <chHeapFree>
      break;
#endif
#if CH_CFG_USE_MEMPOOLS
    case CH_FLAG_MODE_MEMPOOL:
#if CH_CFG_USE_REGISTRY
      REG_REMOVE(tp);
 800177e:	6943      	ldr	r3, [r0, #20]
 8001780:	6902      	ldr	r2, [r0, #16]
 8001782:	611a      	str	r2, [r3, #16]
 8001784:	6902      	ldr	r2, [r0, #16]
#endif
      chPoolFree(tp->p_mpool, tp);
 8001786:	6c00      	ldr	r0, [r0, #64]	; 0x40
      break;
#endif
#if CH_CFG_USE_MEMPOOLS
    case CH_FLAG_MODE_MEMPOOL:
#if CH_CFG_USE_REGISTRY
      REG_REMOVE(tp);
 8001788:	6153      	str	r3, [r2, #20]
#endif
      chPoolFree(tp->p_mpool, tp);
 800178a:	f000 bb71 	b.w	8001e70 <chPoolFree>
 800178e:	bf00      	nop

08001790 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              tprio_t prio, tfunc_t pf, void *arg) {
 8001790:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001792:	b083      	sub	sp, #12
 8001794:	4616      	mov	r6, r2
 8001796:	461d      	mov	r5, r3
 8001798:	460f      	mov	r7, r1
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 800179a:	f000 fad1 	bl	8001d40 <chHeapAlloc>
  if (wsp == NULL) {
 800179e:	b198      	cbz	r0, 80017c8 <chThdCreateFromHeap+0x38>
 80017a0:	2320      	movs	r3, #32
 80017a2:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 80017a6:	9b08      	ldr	r3, [sp, #32]
 80017a8:	9300      	str	r3, [sp, #0]
 80017aa:	4639      	mov	r1, r7
 80017ac:	4632      	mov	r2, r6
 80017ae:	462b      	mov	r3, r5
 80017b0:	f7ff fea6 	bl	8001500 <chThdCreateI>
  tp->p_flags = CH_FLAG_MODE_HEAP;
 80017b4:	2301      	movs	r3, #1
 80017b6:	7743      	strb	r3, [r0, #29]
  chSchWakeupS(tp, MSG_OK);
 80017b8:	2100      	movs	r1, #0
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 80017ba:	4604      	mov	r4, r0
  tp->p_flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 80017bc:	f7ff fd98 	bl	80012f0 <chSchWakeupS>
 80017c0:	2300      	movs	r3, #0
 80017c2:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
 80017c6:	4620      	mov	r0, r4
}
 80017c8:	b003      	add	sp, #12
 80017ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80017cc:	f3af 8000 	nop.w

080017d0 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 80017d0:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 80017d2:	6040      	str	r0, [r0, #4]
 80017d4:	6000      	str	r0, [r0, #0]
 80017d6:	6083      	str	r3, [r0, #8]
 80017d8:	4770      	bx	lr
 80017da:	bf00      	nop
 80017dc:	f3af 8000 	nop.w

080017e0 <chMtxLockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 80017e0:	4b30      	ldr	r3, [pc, #192]	; (80018a4 <chMtxLockS+0xc4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 80017e2:	6882      	ldr	r2, [r0, #8]
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 80017e4:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 80017e6:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 80017e8:	2a00      	cmp	r2, #0
 80017ea:	d055      	beq.n	8001898 <chMtxLockS+0xb8>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 80017ec:	68a1      	ldr	r1, [r4, #8]
 80017ee:	6893      	ldr	r3, [r2, #8]
 80017f0:	4299      	cmp	r1, r3
 80017f2:	4605      	mov	r5, r0
 80017f4:	d906      	bls.n	8001804 <chMtxLockS+0x24>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 80017f6:	7f13      	ldrb	r3, [r2, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 80017f8:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 80017fa:	2b06      	cmp	r3, #6
 80017fc:	d033      	beq.n	8001866 <chMtxLockS+0x86>
 80017fe:	2b07      	cmp	r3, #7
 8001800:	d01d      	beq.n	800183e <chMtxLockS+0x5e>
 8001802:	b19b      	cbz	r3, 800182c <chMtxLockS+0x4c>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001804:	462b      	mov	r3, r5
 8001806:	e003      	b.n	8001810 <chMtxLockS+0x30>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001808:	6899      	ldr	r1, [r3, #8]
 800180a:	68a2      	ldr	r2, [r4, #8]
 800180c:	4291      	cmp	r1, r2
 800180e:	d302      	bcc.n	8001816 <chMtxLockS+0x36>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001810:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001812:	429d      	cmp	r5, r3
 8001814:	d1f8      	bne.n	8001808 <chMtxLockS+0x28>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001816:	685a      	ldr	r2, [r3, #4]
 8001818:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800181a:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 800181c:	605c      	str	r4, [r3, #4]
 800181e:	6014      	str	r4, [r2, #0]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtobjp = mp;
 8001820:	6225      	str	r5, [r4, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8001822:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 8001824:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtobjp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8001828:	f7ff bd22 	b.w	8001270 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800182c:	e892 000a 	ldmia.w	r2, {r1, r3}
 8001830:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001832:	6811      	ldr	r1, [r2, #0]
  #if CH_DBG_ENABLE_ASSERTS
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
  #endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          chSchReadyI(queue_dequeue(tp));
 8001834:	4610      	mov	r0, r2
 8001836:	604b      	str	r3, [r1, #4]
 8001838:	f7ff fd02 	bl	8001240 <chSchReadyI>
          break;
 800183c:	e7e2      	b.n	8001804 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800183e:	e892 0009 	ldmia.w	r2, {r0, r3}
 8001842:	6018      	str	r0, [r3, #0]
  #if CH_CFG_USE_MESSAGES && CH_CFG_USE_MESSAGES_PRIORITY
        case CH_STATE_SNDMSGQ:
  #endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp),
                            (threads_queue_t *)tp->p_u.wtobjp);
 8001844:	6a16      	ldr	r6, [r2, #32]
  tp->p_next->p_prev = tp->p_prev;
 8001846:	6810      	ldr	r0, [r2, #0]
 8001848:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800184a:	4633      	mov	r3, r6
 800184c:	e002      	b.n	8001854 <chMtxLockS+0x74>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800184e:	6898      	ldr	r0, [r3, #8]
 8001850:	4288      	cmp	r0, r1
 8001852:	d302      	bcc.n	800185a <chMtxLockS+0x7a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001854:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001856:	429e      	cmp	r6, r3
 8001858:	d1f9      	bne.n	800184e <chMtxLockS+0x6e>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800185a:	6859      	ldr	r1, [r3, #4]
 800185c:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800185e:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8001860:	605a      	str	r2, [r3, #4]
 8001862:	600a      	str	r2, [r1, #0]
 8001864:	e7ce      	b.n	8001804 <chMtxLockS+0x24>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001866:	e892 0009 	ldmia.w	r2, {r0, r3}
 800186a:	6018      	str	r0, [r3, #0]
        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp),
                            (threads_queue_t *)tp->p_u.wtobjp);
 800186c:	6a16      	ldr	r6, [r2, #32]
  tp->p_next->p_prev = tp->p_prev;
 800186e:	6810      	ldr	r0, [r2, #0]
 8001870:	6043      	str	r3, [r0, #4]
 8001872:	4633      	mov	r3, r6
 8001874:	e002      	b.n	800187c <chMtxLockS+0x9c>
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001876:	6898      	ldr	r0, [r3, #8]
 8001878:	4288      	cmp	r0, r1
 800187a:	d302      	bcc.n	8001882 <chMtxLockS+0xa2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800187c:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800187e:	429e      	cmp	r6, r3
 8001880:	d1f9      	bne.n	8001876 <chMtxLockS+0x96>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001882:	6859      	ldr	r1, [r3, #4]
 8001884:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8001886:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = cp->p_prev = tp;
 8001888:	605a      	str	r2, [r3, #4]
 800188a:	600a      	str	r2, [r1, #0]
          tp = ((mutex_t *)tp->p_u.wtobjp)->m_owner;
 800188c:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800188e:	68a1      	ldr	r1, [r4, #8]
 8001890:	6893      	ldr	r3, [r2, #8]
 8001892:	428b      	cmp	r3, r1
 8001894:	d3af      	bcc.n	80017f6 <chMtxLockS+0x16>
 8001896:	e7b5      	b.n	8001804 <chMtxLockS+0x24>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 8001898:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800189a:	60c3      	str	r3, [r0, #12]
    chDbgAssert(mp->m_cnt == 0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 800189c:	6084      	str	r4, [r0, #8]
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
 800189e:	63a0      	str	r0, [r4, #56]	; 0x38
 80018a0:	bd70      	pop	{r4, r5, r6, pc}
 80018a2:	bf00      	nop
 80018a4:	20000ef0 	.word	0x20000ef0
 80018a8:	f3af 8000 	nop.w
 80018ac:	f3af 8000 	nop.w

080018b0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80018b0:	b508      	push	{r3, lr}
 80018b2:	2320      	movs	r3, #32
 80018b4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxLockS(mp);
 80018b8:	f7ff ff92 	bl	80017e0 <chMtxLockS>
 80018bc:	2300      	movs	r3, #0
 80018be:	f383 8811 	msr	BASEPRI, r3
 80018c2:	bd08      	pop	{r3, pc}
 80018c4:	f3af 8000 	nop.w
 80018c8:	f3af 8000 	nop.w
 80018cc:	f3af 8000 	nop.w

080018d0 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 80018d0:	4b16      	ldr	r3, [pc, #88]	; (800192c <chMtxUnlock+0x5c>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 80018d2:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 80018d4:	699d      	ldr	r5, [r3, #24]
 80018d6:	2320      	movs	r3, #32
 80018d8:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (thread_t *)tqp);
 80018dc:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 80018de:	68c3      	ldr	r3, [r0, #12]
 80018e0:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80018e2:	42a0      	cmp	r0, r4
 80018e4:	d01c      	beq.n	8001920 <chMtxUnlock+0x50>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 80018e6:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80018e8:	b14b      	cbz	r3, 80018fe <chMtxUnlock+0x2e>
 80018ea:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80018ec:	4293      	cmp	r3, r2
 80018ee:	d003      	beq.n	80018f8 <chMtxUnlock+0x28>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 80018f0:	6892      	ldr	r2, [r2, #8]
 80018f2:	4291      	cmp	r1, r2
 80018f4:	bf38      	it	cc
 80018f6:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 80018f8:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80018fa:	2b00      	cmp	r3, #0
 80018fc:	d1f5      	bne.n	80018ea <chMtxUnlock+0x1a>
 80018fe:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  (tqp->p_next = tp->p_next)->p_prev = (thread_t *)tqp;
 8001900:	6822      	ldr	r2, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE
      mp->m_cnt = 1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8001902:	6ba6      	ldr	r6, [r4, #56]	; 0x38
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8001904:	60a9      	str	r1, [r5, #8]
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      chSchWakeupS(tp, MSG_OK);
 8001906:	4620      	mov	r0, r4
 8001908:	601a      	str	r2, [r3, #0]
 800190a:	2100      	movs	r1, #0
 800190c:	6053      	str	r3, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE
      mp->m_cnt = 1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 800190e:	609c      	str	r4, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 8001910:	60de      	str	r6, [r3, #12]
      tp->p_mtxlist = mp;
 8001912:	63a3      	str	r3, [r4, #56]	; 0x38
      chSchWakeupS(tp, MSG_OK);
 8001914:	f7ff fcec 	bl	80012f0 <chSchWakeupS>
 8001918:	2300      	movs	r3, #0
 800191a:	f383 8811 	msr	BASEPRI, r3
 800191e:	bd70      	pop	{r4, r5, r6, pc}
    }
    else {
      mp->m_owner = NULL;
 8001920:	2300      	movs	r3, #0
 8001922:	6083      	str	r3, [r0, #8]
 8001924:	2300      	movs	r3, #0
 8001926:	f383 8811 	msr	BASEPRI, r3
 800192a:	bd70      	pop	{r4, r5, r6, pc}
 800192c:	20000ef0 	.word	0x20000ef0

08001930 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 8001930:	b430      	push	{r4, r5}
 8001932:	2420      	movs	r4, #32
 8001934:	f384 8811 	msr	BASEPRI, r4
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 8001938:	4d06      	ldr	r5, [pc, #24]	; (8001954 <chEvtRegisterMaskWithFlags+0x24>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 800193a:	6804      	ldr	r4, [r0, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
 800193c:	69ad      	ldr	r5, [r5, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 800193e:	600c      	str	r4, [r1, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = 0;
 8001940:	2400      	movs	r4, #0

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 8001942:	6001      	str	r1, [r0, #0]
  elp->el_listener = currp;
 8001944:	604d      	str	r5, [r1, #4]
  elp->el_events   = events;
 8001946:	608a      	str	r2, [r1, #8]
  elp->el_flags    = 0;
  elp->el_wflags   = wflags;
 8001948:	610b      	str	r3, [r1, #16]
  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = 0;
 800194a:	60cc      	str	r4, [r1, #12]
 800194c:	f384 8811 	msr	BASEPRI, r4
  elp->el_wflags   = wflags;
  chSysUnlock();
}
 8001950:	bc30      	pop	{r4, r5}
 8001952:	4770      	bx	lr
 8001954:	20000ef0 	.word	0x20000ef0
 8001958:	f3af 8000 	nop.w
 800195c:	f3af 8000 	nop.w

08001960 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001960:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001962:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001964:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001966:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001968:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 800196a:	d00a      	beq.n	8001982 <chEvtSignalI+0x22>
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 800196c:	2a0b      	cmp	r2, #11
 800196e:	d000      	beq.n	8001972 <chEvtSignalI+0x12>
 8001970:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8001972:	6a03      	ldr	r3, [r0, #32]
 8001974:	4019      	ands	r1, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8001976:	428b      	cmp	r3, r1
 8001978:	d1fa      	bne.n	8001970 <chEvtSignalI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 800197a:	2300      	movs	r3, #0
 800197c:	6203      	str	r3, [r0, #32]
    chSchReadyI(tp);
 800197e:	f7ff bc5f 	b.w	8001240 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != 0)) ||
 8001982:	6a03      	ldr	r3, [r0, #32]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001984:	4219      	tst	r1, r3
 8001986:	d1f8      	bne.n	800197a <chEvtSignalI+0x1a>
 8001988:	4770      	bx	lr
 800198a:	bf00      	nop
 800198c:	f3af 8000 	nop.w

08001990 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001990:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8001992:	6804      	ldr	r4, [r0, #0]
  while (elp != (event_listener_t *)esp) {
 8001994:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001996:	4606      	mov	r6, r0
 8001998:	460d      	mov	r5, r1

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  while (elp != (event_listener_t *)esp) {
 800199a:	d00d      	beq.n	80019b8 <chEvtBroadcastFlagsI+0x28>
    elp->el_flags |= flags;
 800199c:	68e3      	ldr	r3, [r4, #12]
 800199e:	432b      	orrs	r3, r5
 80019a0:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == 0) || ((elp->el_flags & elp->el_wflags) != 0)) {
 80019a2:	b115      	cbz	r5, 80019aa <chEvtBroadcastFlagsI+0x1a>
 80019a4:	6922      	ldr	r2, [r4, #16]
 80019a6:	4213      	tst	r3, r2
 80019a8:	d003      	beq.n	80019b2 <chEvtBroadcastFlagsI+0x22>
      chEvtSignalI(elp->el_listener, elp->el_events);
 80019aa:	6860      	ldr	r0, [r4, #4]
 80019ac:	68a1      	ldr	r1, [r4, #8]
 80019ae:	f7ff ffd7 	bl	8001960 <chEvtSignalI>
    }
    elp = elp->el_next;
 80019b2:	6824      	ldr	r4, [r4, #0]

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  while (elp != (event_listener_t *)esp) {
 80019b4:	42a6      	cmp	r6, r4
 80019b6:	d1f1      	bne.n	800199c <chEvtBroadcastFlagsI+0xc>
 80019b8:	bd70      	pop	{r4, r5, r6, pc}
 80019ba:	bf00      	nop
 80019bc:	f3af 8000 	nop.w

080019c0 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 80019c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = 0;
  while (events) {
 80019c2:	460d      	mov	r5, r1
 80019c4:	b1a9      	cbz	r1, 80019f2 <chEvtDispatch+0x32>
 80019c6:	4607      	mov	r7, r0
 80019c8:	2400      	movs	r4, #0
    if (events & EVENT_MASK(eid)) {
 80019ca:	2601      	movs	r6, #1
 80019cc:	fa06 f304 	lsl.w	r3, r6, r4
 80019d0:	422b      	tst	r3, r5
 80019d2:	d104      	bne.n	80019de <chEvtDispatch+0x1e>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
 80019d4:	3401      	adds	r4, #1

  chDbgCheck(handlers != NULL);

  eid = 0;
  while (events) {
    if (events & EVENT_MASK(eid)) {
 80019d6:	fa06 f304 	lsl.w	r3, r6, r4
 80019da:	422b      	tst	r3, r5
 80019dc:	d0fa      	beq.n	80019d4 <chEvtDispatch+0x14>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
 80019de:	4620      	mov	r0, r4

  eid = 0;
  while (events) {
    if (events & EVENT_MASK(eid)) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 80019e0:	ea25 0503 	bic.w	r5, r5, r3
      handlers[eid](eid);
 80019e4:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
 80019e8:	4798      	blx	r3
    }
    eid++;
 80019ea:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = 0;
  while (events) {
 80019ec:	2d00      	cmp	r5, #0
 80019ee:	d1ed      	bne.n	80019cc <chEvtDispatch+0xc>
 80019f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80019f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80019f4:	f3af 8000 	nop.w
 80019f8:	f3af 8000 	nop.w
 80019fc:	f3af 8000 	nop.w

08001a00 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8001a00:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8001a02:	4b0d      	ldr	r3, [pc, #52]	; (8001a38 <chEvtWaitOne+0x38>)
 8001a04:	699d      	ldr	r5, [r3, #24]
 8001a06:	2320      	movs	r3, #32
 8001a08:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  if ((m = (ctp->p_epending & events)) == 0) {
 8001a0c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8001a0e:	ea10 0203 	ands.w	r2, r0, r3
 8001a12:	d107      	bne.n	8001a24 <chEvtWaitOne+0x24>
 8001a14:	4604      	mov	r4, r0
    ctp->p_u.ewmask = events;
 8001a16:	6228      	str	r0, [r5, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8001a18:	200a      	movs	r0, #10
 8001a1a:	f7ff fc29 	bl	8001270 <chSchGoSleepS>
    m = ctp->p_epending & events;
 8001a1e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8001a20:	ea04 0203 	and.w	r2, r4, r3
  }
  m ^= m & (m - 1);
 8001a24:	4250      	negs	r0, r2
 8001a26:	4010      	ands	r0, r2
  ctp->p_epending &= ~m;
 8001a28:	ea23 0300 	bic.w	r3, r3, r0
 8001a2c:	636b      	str	r3, [r5, #52]	; 0x34
 8001a2e:	2300      	movs	r3, #0
 8001a30:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8001a34:	bd38      	pop	{r3, r4, r5, pc}
 8001a36:	bf00      	nop
 8001a38:	20000ef0 	.word	0x20000ef0
 8001a3c:	f3af 8000 	nop.w

08001a40 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 8001a40:	b430      	push	{r4, r5}
 8001a42:	9c02      	ldr	r4, [sp, #8]
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
  iqp->q_notify = infy;
  iqp->q_link = link;
 8001a44:	6204      	str	r4, [r0, #32]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001a46:	2500      	movs	r5, #0
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
 8001a48:	440a      	add	r2, r1
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001a4a:	6085      	str	r5, [r0, #8]
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
  iqp->q_top = bp + size;
 8001a4c:	6102      	str	r2, [r0, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = tqp->p_prev = (thread_t *)tqp;
 8001a4e:	6040      	str	r0, [r0, #4]
 8001a50:	6000      	str	r0, [r0, #0]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer = iqp->q_rdptr = iqp->q_wrptr = bp;
 8001a52:	6141      	str	r1, [r0, #20]
 8001a54:	6181      	str	r1, [r0, #24]
 8001a56:	60c1      	str	r1, [r0, #12]
  iqp->q_top = bp + size;
  iqp->q_notify = infy;
 8001a58:	61c3      	str	r3, [r0, #28]
  iqp->q_link = link;
}
 8001a5a:	bc30      	pop	{r4, r5}
 8001a5c:	4770      	bx	lr
 8001a5e:	bf00      	nop

08001a60 <chIQPutI>:
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0));
 8001a60:	6983      	ldr	r3, [r0, #24]
 8001a62:	6942      	ldr	r2, [r0, #20]
 8001a64:	429a      	cmp	r2, r3
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8001a66:	b510      	push	{r4, lr}
 8001a68:	6883      	ldr	r3, [r0, #8]
 8001a6a:	d00f      	beq.n	8001a8c <chIQPutI+0x2c>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8001a6c:	3301      	adds	r3, #1
  *iqp->q_wrptr++ = b;
 8001a6e:	1c54      	adds	r4, r2, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8001a70:	6083      	str	r3, [r0, #8]
  *iqp->q_wrptr++ = b;
 8001a72:	6144      	str	r4, [r0, #20]
 8001a74:	7011      	strb	r1, [r2, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8001a76:	6942      	ldr	r2, [r0, #20]
 8001a78:	6903      	ldr	r3, [r0, #16]
 8001a7a:	429a      	cmp	r2, r3
 8001a7c:	d301      	bcc.n	8001a82 <chIQPutI+0x22>
    iqp->q_wrptr = iqp->q_buffer;
 8001a7e:	68c3      	ldr	r3, [r0, #12]
 8001a80:	6143      	str	r3, [r0, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 8001a82:	2100      	movs	r1, #0
 8001a84:	f7ff fe34 	bl	80016f0 <chThdDequeueNextI>

  return Q_OK;
 8001a88:	2000      	movs	r0, #0
 8001a8a:	bd10      	pop	{r4, pc}
 8001a8c:	2b00      	cmp	r3, #0
 8001a8e:	d0ed      	beq.n	8001a6c <chIQPutI+0xc>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 8001a90:	f06f 0003 	mvn.w	r0, #3
 8001a94:	bd10      	pop	{r4, pc}
 8001a96:	bf00      	nop
 8001a98:	f3af 8000 	nop.w
 8001a9c:	f3af 8000 	nop.w

08001aa0 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t time) {
 8001aa0:	b570      	push	{r4, r5, r6, lr}
 8001aa2:	2320      	movs	r3, #32
 8001aa4:	460e      	mov	r6, r1
 8001aa6:	4604      	mov	r4, r0
 8001aa8:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify) {
 8001aac:	69c3      	ldr	r3, [r0, #28]
 8001aae:	b12b      	cbz	r3, 8001abc <chIQGetTimeout+0x1c>
    iqp->q_notify(iqp);
 8001ab0:	4798      	blx	r3
 8001ab2:	e003      	b.n	8001abc <chIQGetTimeout+0x1c>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg;
    if ((msg = chThdEnqueueTimeoutS(&iqp->q_waiting, time)) < Q_OK) {
 8001ab4:	f7ff fe04 	bl	80016c0 <chThdEnqueueTimeoutS>
 8001ab8:	2800      	cmp	r0, #0
 8001aba:	db15      	blt.n	8001ae8 <chIQGetTimeout+0x48>
 8001abc:	68a5      	ldr	r5, [r4, #8]
 8001abe:	4620      	mov	r0, r4
 8001ac0:	4631      	mov	r1, r6
  chSysLock();
  if (iqp->q_notify) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8001ac2:	2d00      	cmp	r5, #0
 8001ac4:	d0f6      	beq.n	8001ab4 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001ac6:	69a2      	ldr	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001ac8:	6921      	ldr	r1, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001aca:	1c53      	adds	r3, r2, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 8001acc:	428b      	cmp	r3, r1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001ace:	f105 35ff 	add.w	r5, r5, #4294967295
  b = *iqp->q_rdptr++;
 8001ad2:	61a3      	str	r3, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8001ad4:	60a5      	str	r5, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8001ad6:	bf28      	it	cs
 8001ad8:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8001ada:	7810      	ldrb	r0, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8001adc:	bf28      	it	cs
 8001ade:	61a3      	strcs	r3, [r4, #24]
 8001ae0:	2300      	movs	r3, #0
 8001ae2:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return b;
}
 8001ae6:	bd70      	pop	{r4, r5, r6, pc}
 8001ae8:	f385 8811 	msr	BASEPRI, r5

  while (chIQIsEmptyI(iqp)) {
    msg_t msg;
    if ((msg = chThdEnqueueTimeoutS(&iqp->q_waiting, time)) < Q_OK) {
      chSysUnlock();
      return msg;
 8001aec:	bd70      	pop	{r4, r5, r6, pc}
 8001aee:	bf00      	nop

08001af0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t time) {
 8001af0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001af4:	4604      	mov	r4, r0
 8001af6:	b083      	sub	sp, #12
 8001af8:	4689      	mov	r9, r1
 8001afa:	4693      	mov	fp, r2
 8001afc:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 8001afe:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8001b02:	2720      	movs	r7, #32
 8001b04:	f387 8811 	msr	BASEPRI, r7
  size_t r = 0;
 8001b08:	2600      	movs	r6, #0
 8001b0a:	9701      	str	r7, [sp, #4]
 8001b0c:	46b2      	mov	sl, r6

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    if (nfy) {
 8001b0e:	f1b8 0f00 	cmp.w	r8, #0
 8001b12:	d005      	beq.n	8001b20 <chIQReadTimeout+0x30>
      nfy(iqp);
 8001b14:	4620      	mov	r0, r4
 8001b16:	47c0      	blx	r8
 8001b18:	e002      	b.n	8001b20 <chIQReadTimeout+0x30>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, time) != Q_OK) {
 8001b1a:	f7ff fdd1 	bl	80016c0 <chThdEnqueueTimeoutS>
 8001b1e:	b9d8      	cbnz	r0, 8001b58 <chIQReadTimeout+0x68>
 8001b20:	68a7      	ldr	r7, [r4, #8]
 8001b22:	4620      	mov	r0, r4
 8001b24:	4629      	mov	r1, r5
  while (true) {
    if (nfy) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8001b26:	2f00      	cmp	r7, #0
 8001b28:	d0f7      	beq.n	8001b1a <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8001b2a:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001b2c:	1e7b      	subs	r3, r7, #1
    *bp++ = *iqp->q_rdptr++;
 8001b2e:	1c51      	adds	r1, r2, #1
 8001b30:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001b32:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8001b34:	7813      	ldrb	r3, [r2, #0]
 8001b36:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top)
 8001b3a:	6923      	ldr	r3, [r4, #16]
 8001b3c:	69a2      	ldr	r2, [r4, #24]
 8001b3e:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8001b40:	bf24      	itt	cs
 8001b42:	68e3      	ldrcs	r3, [r4, #12]
 8001b44:	61a3      	strcs	r3, [r4, #24]
 8001b46:	f38a 8811 	msr	BASEPRI, sl

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    r++;
 8001b4a:	3601      	adds	r6, #1
    if (--n == 0) {
 8001b4c:	45b3      	cmp	fp, r6
 8001b4e:	d005      	beq.n	8001b5c <chIQReadTimeout+0x6c>
 8001b50:	9b01      	ldr	r3, [sp, #4]
 8001b52:	f383 8811 	msr	BASEPRI, r3
 8001b56:	e7da      	b.n	8001b0e <chIQReadTimeout+0x1e>
 8001b58:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 8001b5c:	4630      	mov	r0, r6
 8001b5e:	b003      	add	sp, #12
 8001b60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001b64:	f3af 8000 	nop.w
 8001b68:	f3af 8000 	nop.w
 8001b6c:	f3af 8000 	nop.w

08001b70 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 8001b70:	b430      	push	{r4, r5}
 8001b72:	9c02      	ldr	r4, [sp, #8]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
  oqp->q_top = bp + size;
  oqp->q_notify = onfy;
  oqp->q_link = link;
 8001b74:	6204      	str	r4, [r0, #32]
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
  oqp->q_top = bp + size;
 8001b76:	188d      	adds	r5, r1, r2
 8001b78:	6105      	str	r5, [r0, #16]
 8001b7a:	6040      	str	r0, [r0, #4]
 8001b7c:	6000      	str	r0, [r0, #0]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001b7e:	6082      	str	r2, [r0, #8]
  oqp->q_buffer = oqp->q_rdptr = oqp->q_wrptr = bp;
 8001b80:	6141      	str	r1, [r0, #20]
 8001b82:	6181      	str	r1, [r0, #24]
 8001b84:	60c1      	str	r1, [r0, #12]
  oqp->q_top = bp + size;
  oqp->q_notify = onfy;
 8001b86:	61c3      	str	r3, [r0, #28]
  oqp->q_link = link;
}
 8001b88:	bc30      	pop	{r4, r5}
 8001b8a:	4770      	bx	lr
 8001b8c:	f3af 8000 	nop.w

08001b90 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t time) {
 8001b90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001b92:	4604      	mov	r4, r0
 8001b94:	460f      	mov	r7, r1
 8001b96:	4616      	mov	r6, r2
 8001b98:	2320      	movs	r3, #32
 8001b9a:	f383 8811 	msr	BASEPRI, r3
 8001b9e:	e003      	b.n	8001ba8 <chOQPutTimeout+0x18>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg;

    if ((msg = chThdEnqueueTimeoutS(&oqp->q_waiting, time)) < Q_OK) {
 8001ba0:	f7ff fd8e 	bl	80016c0 <chThdEnqueueTimeoutS>
 8001ba4:	2800      	cmp	r0, #0
 8001ba6:	db18      	blt.n	8001bda <chOQPutTimeout+0x4a>
 8001ba8:	68a5      	ldr	r5, [r4, #8]
 8001baa:	4620      	mov	r0, r4
 8001bac:	4631      	mov	r1, r6
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t time) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8001bae:	2d00      	cmp	r5, #0
 8001bb0:	d0f6      	beq.n	8001ba0 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8001bb2:	6963      	ldr	r3, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8001bb4:	3d01      	subs	r5, #1
  *oqp->q_wrptr++ = b;
 8001bb6:	1c5a      	adds	r2, r3, #1
 8001bb8:	6162      	str	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8001bba:	60a5      	str	r5, [r4, #8]
  *oqp->q_wrptr++ = b;
 8001bbc:	701f      	strb	r7, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8001bbe:	6923      	ldr	r3, [r4, #16]
 8001bc0:	6962      	ldr	r2, [r4, #20]
 8001bc2:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8001bc4:	bf24      	itt	cs
 8001bc6:	68e3      	ldrcs	r3, [r4, #12]
 8001bc8:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify) {
 8001bca:	69e3      	ldr	r3, [r4, #28]
 8001bcc:	b10b      	cbz	r3, 8001bd2 <chOQPutTimeout+0x42>
    oqp->q_notify(oqp);
 8001bce:	4620      	mov	r0, r4
 8001bd0:	4798      	blx	r3
 8001bd2:	2000      	movs	r0, #0
 8001bd4:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 8001bd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001bda:	f385 8811 	msr	BASEPRI, r5
  while (chOQIsFullI(oqp)) {
    msg_t msg;

    if ((msg = chThdEnqueueTimeoutS(&oqp->q_waiting, time)) < Q_OK) {
      chSysUnlock();
      return msg;
 8001bde:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001be0 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8001be0:	b538      	push	{r3, r4, r5, lr}
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0));
 8001be2:	6982      	ldr	r2, [r0, #24]
 8001be4:	6943      	ldr	r3, [r0, #20]
 8001be6:	4293      	cmp	r3, r2
 8001be8:	6883      	ldr	r3, [r0, #8]
 8001bea:	d00e      	beq.n	8001c0a <chOQGetI+0x2a>
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8001bec:	6905      	ldr	r5, [r0, #16]
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8001bee:	1c51      	adds	r1, r2, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8001bf0:	3301      	adds	r3, #1
 8001bf2:	6083      	str	r3, [r0, #8]
  b = *oqp->q_rdptr++;
 8001bf4:	6181      	str	r1, [r0, #24]
  if (oqp->q_rdptr >= oqp->q_top) {
 8001bf6:	42a9      	cmp	r1, r5
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8001bf8:	7814      	ldrb	r4, [r2, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8001bfa:	d301      	bcc.n	8001c00 <chOQGetI+0x20>
    oqp->q_rdptr = oqp->q_buffer;
 8001bfc:	68c3      	ldr	r3, [r0, #12]
 8001bfe:	6183      	str	r3, [r0, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8001c00:	2100      	movs	r1, #0
 8001c02:	f7ff fd75 	bl	80016f0 <chThdDequeueNextI>

  return b;
 8001c06:	4620      	mov	r0, r4
 8001c08:	bd38      	pop	{r3, r4, r5, pc}
 8001c0a:	2b00      	cmp	r3, #0
 8001c0c:	d0ee      	beq.n	8001bec <chOQGetI+0xc>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 8001c0e:	f06f 0002 	mvn.w	r0, #2
 8001c12:	bd38      	pop	{r3, r4, r5, pc}
 8001c14:	f3af 8000 	nop.w
 8001c18:	f3af 8000 	nop.w
 8001c1c:	f3af 8000 	nop.w

08001c20 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t time) {
 8001c20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001c24:	b083      	sub	sp, #12
 8001c26:	4604      	mov	r4, r0
 8001c28:	468b      	mov	fp, r1
 8001c2a:	4616      	mov	r6, r2
 8001c2c:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 8001c2e:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8001c32:	f04f 0920 	mov.w	r9, #32
 8001c36:	f389 8811 	msr	BASEPRI, r9
  size_t w = 0;
 8001c3a:	2700      	movs	r7, #0
 8001c3c:	f8cd 9000 	str.w	r9, [sp]
 8001c40:	46ba      	mov	sl, r7
 8001c42:	68a5      	ldr	r5, [r4, #8]
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001c44:	f10b 0901 	add.w	r9, fp, #1
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8001c48:	1e6a      	subs	r2, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy) {
      nfy(oqp);
 8001c4a:	4620      	mov	r0, r4

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8001c4c:	b30d      	cbz	r5, 8001c92 <chOQWriteTimeout+0x72>
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001c4e:	6963      	ldr	r3, [r4, #20]
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8001c50:	60a2      	str	r2, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8001c52:	1c5a      	adds	r2, r3, #1
 8001c54:	6162      	str	r2, [r4, #20]
 8001c56:	f89b 2000 	ldrb.w	r2, [fp]
 8001c5a:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8001c5c:	6923      	ldr	r3, [r4, #16]
 8001c5e:	6962      	ldr	r2, [r4, #20]
 8001c60:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8001c62:	bf24      	itt	cs
 8001c64:	68e3      	ldrcs	r3, [r4, #12]
 8001c66:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy) {
 8001c68:	f1b8 0f00 	cmp.w	r8, #0
 8001c6c:	d000      	beq.n	8001c70 <chOQWriteTimeout+0x50>
      nfy(oqp);
 8001c6e:	47c0      	blx	r8
 8001c70:	f38a 8811 	msr	BASEPRI, sl
    }

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
    if (--n == 0) {
 8001c74:	3e01      	subs	r6, #1
    if (nfy) {
      nfy(oqp);
    }

    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
    w++;
 8001c76:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0) {
 8001c7a:	d012      	beq.n	8001ca2 <chOQWriteTimeout+0x82>
 8001c7c:	9b00      	ldr	r3, [sp, #0]
 8001c7e:	f383 8811 	msr	BASEPRI, r3
 8001c82:	68a5      	ldr	r5, [r4, #8]
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001c84:	46cb      	mov	fp, r9
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
        chSysUnlock();
        return w;
      }
    }
    oqp->q_counter--;
 8001c86:	1e6a      	subs	r2, r5, #1
    *oqp->q_wrptr++ = *bp++;
 8001c88:	f10b 0901 	add.w	r9, fp, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy) {
      nfy(oqp);
 8001c8c:	4620      	mov	r0, r4

  chDbgCheck(n > 0);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8001c8e:	2d00      	cmp	r5, #0
 8001c90:	d1dd      	bne.n	8001c4e <chOQWriteTimeout+0x2e>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, time) != Q_OK) {
 8001c92:	4620      	mov	r0, r4
 8001c94:	9901      	ldr	r1, [sp, #4]
 8001c96:	f7ff fd13 	bl	80016c0 <chThdEnqueueTimeoutS>
 8001c9a:	2800      	cmp	r0, #0
 8001c9c:	d0d1      	beq.n	8001c42 <chOQWriteTimeout+0x22>
 8001c9e:	f385 8811 	msr	BASEPRI, r5
    if (--n == 0) {
      return w;
    }
    chSysLock();
  }
}
 8001ca2:	4638      	mov	r0, r7
 8001ca4:	b003      	add	sp, #12
 8001ca6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001caa:	bf00      	nop
 8001cac:	f3af 8000 	nop.w

08001cb0 <_core_init>:
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001cb0:	4a05      	ldr	r2, [pc, #20]	; (8001cc8 <_core_init+0x18>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001cb2:	4b06      	ldr	r3, [pc, #24]	; (8001ccc <_core_init+0x1c>)
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001cb4:	4806      	ldr	r0, [pc, #24]	; (8001cd0 <_core_init+0x20>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001cb6:	4907      	ldr	r1, [pc, #28]	; (8001cd4 <_core_init+0x24>)
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001cb8:	f022 0207 	bic.w	r2, r2, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001cbc:	f023 0307 	bic.w	r3, r3, #7
void _core_init(void) {
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001cc0:	6002      	str	r2, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001cc2:	600b      	str	r3, [r1, #0]
 8001cc4:	4770      	bx	lr
 8001cc6:	bf00      	nop
 8001cc8:	20001637 	.word	0x20001637
 8001ccc:	2000a000 	.word	0x2000a000
 8001cd0:	200010cc 	.word	0x200010cc
 8001cd4:	200010c8 	.word	0x200010c8
 8001cd8:	f3af 8000 	nop.w
 8001cdc:	f3af 8000 	nop.w

08001ce0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8001ce0:	b410      	push	{r4}
 8001ce2:	2320      	movs	r3, #32
 8001ce4:	f383 8811 	msr	BASEPRI, r3
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size) {
 8001ce8:	4c09      	ldr	r4, [pc, #36]	; (8001d10 <chCoreAlloc+0x30>)
 8001cea:	4b0a      	ldr	r3, [pc, #40]	; (8001d14 <chCoreAlloc+0x34>)
 8001cec:	6822      	ldr	r2, [r4, #0]
 8001cee:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8001cf0:	1dc3      	adds	r3, r0, #7
 8001cf2:	f023 0307 	bic.w	r3, r3, #7
  if ((size_t)(endmem - nextmem) < size) {
 8001cf6:	1a89      	subs	r1, r1, r2
 8001cf8:	428b      	cmp	r3, r1
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8001cfa:	bf9d      	ittte	ls
 8001cfc:	189b      	addls	r3, r3, r2
 8001cfe:	6023      	strls	r3, [r4, #0]

  return p;
 8001d00:	4610      	movls	r0, r2

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  if ((size_t)(endmem - nextmem) < size) {
    return NULL;
 8001d02:	2000      	movhi	r0, #0
 8001d04:	2300      	movs	r3, #0
 8001d06:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 8001d0a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001d0e:	4770      	bx	lr
 8001d10:	200010cc 	.word	0x200010cc
 8001d14:	200010c8 	.word	0x200010c8
 8001d18:	f3af 8000 	nop.w
 8001d1c:	f3af 8000 	nop.w

08001d20 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8001d20:	4b04      	ldr	r3, [pc, #16]	; (8001d34 <_heap_init+0x14>)
 8001d22:	4a05      	ldr	r2, [pc, #20]	; (8001d38 <_heap_init+0x18>)
 8001d24:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
  default_heap.h_free.h.size = 0;
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8001d26:	f103 0010 	add.w	r0, r3, #16
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
  default_heap.h_free.h.u.next = (union heap_header *)NULL;
 8001d2a:	2200      	movs	r2, #0
 8001d2c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 8001d2e:	60da      	str	r2, [r3, #12]
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8001d30:	f7ff bd4e 	b.w	80017d0 <chMtxObjectInit>
 8001d34:	200010d0 	.word	0x200010d0
 8001d38:	08001ce1 	.word	0x08001ce1
 8001d3c:	f3af 8000 	nop.w

08001d40 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8001d40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
    heapp = &default_heap;
 8001d42:	4e21      	ldr	r6, [pc, #132]	; (8001dc8 <chHeapAlloc+0x88>)
 8001d44:	2800      	cmp	r0, #0
 8001d46:	bf18      	it	ne
 8001d48:	4606      	movne	r6, r0

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
 8001d4a:	f106 0710 	add.w	r7, r6, #16
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
    heapp = &default_heap;

  size = MEM_ALIGN_NEXT(size);
 8001d4e:	3107      	adds	r1, #7
  qp = &heapp->h_free;

  H_LOCK(heapp);
 8001d50:	4638      	mov	r0, r7
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL)
    heapp = &default_heap;

  size = MEM_ALIGN_NEXT(size);
 8001d52:	f021 0507 	bic.w	r5, r1, #7
  qp = &heapp->h_free;
 8001d56:	f106 0408 	add.w	r4, r6, #8

  H_LOCK(heapp);
 8001d5a:	f7ff fda9 	bl	80018b0 <chMtxLock>
  while (qp->h.u.next != NULL) {
 8001d5e:	e003      	b.n	8001d68 <chHeapAlloc+0x28>
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 8001d60:	6843      	ldr	r3, [r0, #4]
 8001d62:	429d      	cmp	r5, r3
 8001d64:	d912      	bls.n	8001d8c <chHeapAlloc+0x4c>
 8001d66:	4604      	mov	r4, r0

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 8001d68:	6820      	ldr	r0, [r4, #0]
 8001d6a:	2800      	cmp	r0, #0
 8001d6c:	d1f8      	bne.n	8001d60 <chHeapAlloc+0x20>

      return (void *)(hp + 1);
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 8001d6e:	4638      	mov	r0, r7
 8001d70:	f7ff fdae 	bl	80018d0 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider) {
 8001d74:	6833      	ldr	r3, [r6, #0]
 8001d76:	b32b      	cbz	r3, 8001dc4 <chHeapAlloc+0x84>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 8001d78:	f105 0008 	add.w	r0, r5, #8
 8001d7c:	4798      	blx	r3
    if (hp != NULL) {
 8001d7e:	b308      	cbz	r0, 8001dc4 <chHeapAlloc+0x84>
      hp->h.u.heap = heapp;
 8001d80:	6006      	str	r6, [r0, #0]
      hp->h.size = size;
 8001d82:	6045      	str	r5, [r0, #4]
      hp++;
 8001d84:	f100 0408 	add.w	r4, r0, #8
      return (void *)hp;
    }
  }

  return NULL;
}
 8001d88:	4620      	mov	r0, r4
 8001d8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
      if (hp->h.size < size + sizeof(union heap_header)) {
 8001d8c:	f105 0208 	add.w	r2, r5, #8
 8001d90:	429a      	cmp	r2, r3
 8001d92:	d909      	bls.n	8001da8 <chHeapAlloc+0x68>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 8001d94:	6803      	ldr	r3, [r0, #0]
 8001d96:	6023      	str	r3, [r4, #0]
        fp->h.u.next = hp->h.u.next;
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8001d98:	4604      	mov	r4, r0
      H_UNLOCK(heapp);
 8001d9a:	4638      	mov	r0, r7
        fp->h.u.next = hp->h.u.next;
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8001d9c:	f844 6b08 	str.w	r6, [r4], #8
      H_UNLOCK(heapp);
 8001da0:	f7ff fd96 	bl	80018d0 <chMtxUnlock>
      return (void *)hp;
    }
  }

  return NULL;
}
 8001da4:	4620      	mov	r0, r4
 8001da6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001da8:	f06f 0107 	mvn.w	r1, #7
 8001dac:	1b49      	subs	r1, r1, r5
           useful.*/
        qp->h.u.next = hp->h.u.next;
      }
      else {
        /* Block bigger enough, must split it.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 8001dae:	eb00 0e02 	add.w	lr, r0, r2
        fp->h.u.next = hp->h.u.next;
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
 8001db2:	440b      	add	r3, r1
        qp->h.u.next = hp->h.u.next;
      }
      else {
        /* Block bigger enough, must split it.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        fp->h.u.next = hp->h.u.next;
 8001db4:	6801      	ldr	r1, [r0, #0]
 8001db6:	5081      	str	r1, [r0, r2]
        fp->h.size = hp->h.size - sizeof(union heap_header) - size;
 8001db8:	f8ce 3004 	str.w	r3, [lr, #4]
        qp->h.u.next = fp;
 8001dbc:	f8c4 e000 	str.w	lr, [r4]
        hp->h.size = size;
 8001dc0:	6045      	str	r5, [r0, #4]
 8001dc2:	e7e9      	b.n	8001d98 <chHeapAlloc+0x58>

      return (void *)hp;
    }
  }

  return NULL;
 8001dc4:	2400      	movs	r4, #0
 8001dc6:	e7df      	b.n	8001d88 <chHeapAlloc+0x48>
 8001dc8:	200010d0 	.word	0x200010d0
 8001dcc:	f3af 8000 	nop.w

08001dd0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8001dd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  hp = (union heap_header *)p - 1;
  heapp = hp->h.u.heap;
 8001dd2:	f850 5c08 	ldr.w	r5, [r0, #-8]
  qp = &heapp->h_free;

  H_LOCK(heapp);
 8001dd6:	f105 0710 	add.w	r7, r5, #16
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8001dda:	4606      	mov	r6, r0
  union heap_header *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  hp = (union heap_header *)p - 1;
 8001ddc:	f1a0 0408 	sub.w	r4, r0, #8
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8001de0:	3508      	adds	r5, #8

  H_LOCK(heapp);
 8001de2:	4638      	mov	r0, r7
 8001de4:	f7ff fd64 	bl	80018b0 <chMtxLock>

  chDbgCheck(p != NULL);

  hp = (union heap_header *)p - 1;
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8001de8:	462b      	mov	r3, r5

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8001dea:	42ab      	cmp	r3, r5
 8001dec:	d004      	beq.n	8001df8 <chHeapFree+0x28>
 8001dee:	42a3      	cmp	r3, r4
 8001df0:	d302      	bcc.n	8001df8 <chHeapFree+0x28>
 8001df2:	681b      	ldr	r3, [r3, #0]
 8001df4:	42ab      	cmp	r3, r5
 8001df6:	d1fa      	bne.n	8001dee <chHeapFree+0x1e>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8001df8:	681a      	ldr	r2, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8001dfa:	b11a      	cbz	r2, 8001e04 <chHeapFree+0x34>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8001dfc:	4294      	cmp	r4, r2
 8001dfe:	d301      	bcc.n	8001e04 <chHeapFree+0x34>
 8001e00:	4613      	mov	r3, r2
        qp->h.u.next = hp->h.u.next;
      }
      break;
    }
    qp = qp->h.u.next;
  }
 8001e02:	e7f2      	b.n	8001dea <chHeapFree+0x1a>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8001e04:	f856 1c04 	ldr.w	r1, [r6, #-4]
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8001e08:	f846 2c08 	str.w	r2, [r6, #-8]
      qp->h.u.next = hp;
 8001e0c:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8001e0e:	f101 0208 	add.w	r2, r1, #8
 8001e12:	f856 5c08 	ldr.w	r5, [r6, #-8]
 8001e16:	18a0      	adds	r0, r4, r2
 8001e18:	42a8      	cmp	r0, r5
 8001e1a:	d00a      	beq.n	8001e32 <chHeapFree+0x62>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 8001e1c:	6859      	ldr	r1, [r3, #4]
 8001e1e:	f101 0208 	add.w	r2, r1, #8
 8001e22:	441a      	add	r2, r3
 8001e24:	4294      	cmp	r4, r2
 8001e26:	d012      	beq.n	8001e4e <chHeapFree+0x7e>
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8001e28:	4638      	mov	r0, r7

  return;
}
 8001e2a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8001e2e:	f7ff bd4f 	b.w	80018d0 <chMtxUnlock>
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8001e32:	6840      	ldr	r0, [r0, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 8001e34:	58a2      	ldr	r2, [r4, r2]
 8001e36:	f846 2c08 	str.w	r2, [r6, #-8]
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8001e3a:	180a      	adds	r2, r1, r0
 8001e3c:	3208      	adds	r2, #8
 8001e3e:	f846 2c04 	str.w	r2, [r6, #-4]
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 8001e42:	6859      	ldr	r1, [r3, #4]
 8001e44:	f101 0208 	add.w	r2, r1, #8
 8001e48:	441a      	add	r2, r3
 8001e4a:	4294      	cmp	r4, r2
 8001e4c:	d1ec      	bne.n	8001e28 <chHeapFree+0x58>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
        qp->h.u.next = hp->h.u.next;
 8001e4e:	e916 0005 	ldmdb	r6, {r0, r2}
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8001e52:	440a      	add	r2, r1
 8001e54:	3208      	adds	r2, #8
        qp->h.u.next = hp->h.u.next;
 8001e56:	6018      	str	r0, [r3, #0]
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8001e58:	605a      	str	r2, [r3, #4]
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8001e5a:	4638      	mov	r0, r7

  return;
}
 8001e5c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8001e60:	f7ff bd36 	b.w	80018d0 <chMtxUnlock>
 8001e64:	f3af 8000 	nop.w
 8001e68:	f3af 8000 	nop.w
 8001e6c:	f3af 8000 	nop.w

08001e70 <chPoolFree>:
 8001e70:	2320      	movs	r3, #32
 8001e72:	f383 8811 	msr	BASEPRI, r3
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8001e76:	6803      	ldr	r3, [r0, #0]
 8001e78:	600b      	str	r3, [r1, #0]
 8001e7a:	2300      	movs	r3, #0
  mp->mp_next = php;
 8001e7c:	6001      	str	r1, [r0, #0]
 8001e7e:	f383 8811 	msr	BASEPRI, r3
 8001e82:	4770      	bx	lr
 8001e84:	f3af 8000 	nop.w
 8001e88:	f3af 8000 	nop.w
 8001e8c:	f3af 8000 	nop.w

08001e90 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8001e90:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8001e92:	f000 fda5 	bl	80029e0 <hal_lld_init>

#if HAL_USE_PAL || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8001e96:	4809      	ldr	r0, [pc, #36]	; (8001ebc <halInit+0x2c>)
 8001e98:	f001 f812 	bl	8002ec0 <_pal_lld_init>
#endif
#if HAL_USE_ADC || defined(__DOXYGEN__)
  adcInit();
 8001e9c:	f000 f810 	bl	8001ec0 <adcInit>
#endif
#if HAL_USE_EXT || defined(__DOXYGEN__)
  extInit();
#endif
#if HAL_USE_GPT || defined(__DOXYGEN__)
  gptInit();
 8001ea0:	f000 f846 	bl	8001f30 <gptInit>
#endif
#if HAL_USE_PWM || defined(__DOXYGEN__)
  pwmInit();
#endif
#if HAL_USE_SERIAL || defined(__DOXYGEN__)
  sdInit();
 8001ea4:	f000 f8b4 	bl	8002010 <sdInit>
#endif
#if HAL_USE_UART || defined(__DOXYGEN__)
  uartInit();
#endif
#if HAL_USE_USB || defined(__DOXYGEN__)
  usbInit();
 8001ea8:	f000 f94a 	bl	8002140 <usbInit>
#endif
#if HAL_USE_MMC_SPI || defined(__DOXYGEN__)
  mmcInit();
#endif
#if HAL_USE_SERIAL_USB || defined(__DOXYGEN__)
  sduInit();
 8001eac:	f000 f908 	bl	80020c0 <sduInit>
#if HAL_USE_COMMUNITY || defined(__DOXYGEN__)
  halCommunityInit();
#endif

  /* Board specific initialization.*/
  boardInit();
 8001eb0:	f001 fe46 	bl	8003b40 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 8001eb4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8001eb8:	f000 b90a 	b.w	80020d0 <stInit>
 8001ebc:	08006a10 	.word	0x08006a10

08001ec0 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
 8001ec0:	f000 be1e 	b.w	8002b00 <adc_lld_init>
 8001ec4:	f3af 8000 	nop.w
 8001ec8:	f3af 8000 	nop.w
 8001ecc:	f3af 8000 	nop.w

08001ed0 <adcObjectInit>:
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
  adcp->config   = NULL;
 8001ed0:	2300      	movs	r3, #0
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8001ed2:	2201      	movs	r2, #1
 8001ed4:	7002      	strb	r2, [r0, #0]
  adcp->config   = NULL;
 8001ed6:	6043      	str	r3, [r0, #4]
  adcp->samples  = NULL;
 8001ed8:	6083      	str	r3, [r0, #8]
  adcp->depth    = 0;
 8001eda:	60c3      	str	r3, [r0, #12]
  adcp->grpp     = NULL;
 8001edc:	6103      	str	r3, [r0, #16]
#if ADC_USE_WAIT
  adcp->thread   = NULL;
 8001ede:	6143      	str	r3, [r0, #20]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8001ee0:	3018      	adds	r0, #24
 8001ee2:	f7ff bc75 	b.w	80017d0 <chMtxObjectInit>
 8001ee6:	bf00      	nop
 8001ee8:	f3af 8000 	nop.w
 8001eec:	f3af 8000 	nop.w

08001ef0 <adcStart>:
 * @param[in] config    pointer to the @p ADCConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void adcStart(ADCDriver *adcp, const ADCConfig *config) {
 8001ef0:	b510      	push	{r4, lr}
 8001ef2:	2320      	movs	r3, #32
 8001ef4:	4604      	mov	r4, r0
 8001ef6:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
 8001efa:	6041      	str	r1, [r0, #4]
  adc_lld_start(adcp);
 8001efc:	f000 fe20 	bl	8002b40 <adc_lld_start>
  adcp->state = ADC_READY;
 8001f00:	2302      	movs	r3, #2
 8001f02:	7023      	strb	r3, [r4, #0]
 8001f04:	2300      	movs	r3, #0
 8001f06:	f383 8811 	msr	BASEPRI, r3
 8001f0a:	bd10      	pop	{r4, pc}
 8001f0c:	f3af 8000 	nop.w

08001f10 <adcStartConversion>:
 * @api
 */
void adcStartConversion(ADCDriver *adcp,
                        const ADCConversionGroup *grpp,
                        adcsample_t *samples,
                        size_t depth) {
 8001f10:	b538      	push	{r3, r4, r5, lr}
 8001f12:	2520      	movs	r5, #32
 8001f14:	f385 8811 	msr	BASEPRI, r5
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
  adcp->grpp     = grpp;
  adcp->state    = ADC_ACTIVE;
 8001f18:	2503      	movs	r5, #3
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
 8001f1a:	60c3      	str	r3, [r0, #12]
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 8001f1c:	6082      	str	r2, [r0, #8]
  adcp->depth    = depth;
  adcp->grpp     = grpp;
 8001f1e:	6101      	str	r1, [r0, #16]
  adcp->state    = ADC_ACTIVE;
 8001f20:	7005      	strb	r5, [r0, #0]
  adc_lld_start_conversion(adcp);
 8001f22:	f000 fe4d 	bl	8002bc0 <adc_lld_start_conversion>
 8001f26:	2300      	movs	r3, #0
 8001f28:	f383 8811 	msr	BASEPRI, r3
 8001f2c:	bd38      	pop	{r3, r4, r5, pc}
 8001f2e:	bf00      	nop

08001f30 <gptInit>:
 *
 * @init
 */
void gptInit(void) {

  gpt_lld_init();
 8001f30:	f001 b8be 	b.w	80030b0 <gpt_lld_init>
 8001f34:	f3af 8000 	nop.w
 8001f38:	f3af 8000 	nop.w
 8001f3c:	f3af 8000 	nop.w

08001f40 <gptObjectInit>:
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
 8001f40:	2201      	movs	r2, #1
  gptp->config = NULL;
 8001f42:	2300      	movs	r3, #0
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
 8001f44:	7002      	strb	r2, [r0, #0]
  gptp->config = NULL;
 8001f46:	6043      	str	r3, [r0, #4]
 8001f48:	4770      	bx	lr
 8001f4a:	bf00      	nop
 8001f4c:	f3af 8000 	nop.w

08001f50 <gptStart>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] config    pointer to the @p GPTConfig object
 *
 * @api
 */
void gptStart(GPTDriver *gptp, const GPTConfig *config) {
 8001f50:	b510      	push	{r4, lr}
 8001f52:	2320      	movs	r3, #32
 8001f54:	4604      	mov	r4, r0
 8001f56:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck((gptp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
              "invalid state");
  gptp->config = config;
 8001f5a:	6041      	str	r1, [r0, #4]
  gpt_lld_start(gptp);
 8001f5c:	f001 f8b8 	bl	80030d0 <gpt_lld_start>
  gptp->state = GPT_READY;
 8001f60:	2302      	movs	r3, #2
 8001f62:	7023      	strb	r3, [r4, #0]
 8001f64:	2300      	movs	r3, #0
 8001f66:	f383 8811 	msr	BASEPRI, r3
 8001f6a:	bd10      	pop	{r4, pc}
 8001f6c:	f3af 8000 	nop.w

08001f70 <gptStartContinuous>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @api
 */
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
 8001f70:	b508      	push	{r3, lr}
 8001f72:	2220      	movs	r2, #32
 8001f74:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
  osalDbgAssert(gptp->state == GPT_READY,
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 8001f78:	2203      	movs	r2, #3
 8001f7a:	7002      	strb	r2, [r0, #0]
  gpt_lld_start_timer(gptp, interval);
 8001f7c:	f001 f8e0 	bl	8003140 <gpt_lld_start_timer>
 8001f80:	2300      	movs	r3, #0
 8001f82:	f383 8811 	msr	BASEPRI, r3
 8001f86:	bd08      	pop	{r3, pc}
 8001f88:	f3af 8000 	nop.w
 8001f8c:	f3af 8000 	nop.w

08001f90 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t time) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, time);
 8001f90:	300c      	adds	r0, #12
 8001f92:	f7ff bdad 	b.w	8001af0 <chIQReadTimeout>
 8001f96:	bf00      	nop
 8001f98:	f3af 8000 	nop.w
 8001f9c:	f3af 8000 	nop.w

08001fa0 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001fa0:	300c      	adds	r0, #12
 8001fa2:	f04f 33ff 	mov.w	r3, #4294967295
 8001fa6:	f7ff bda3 	b.w	8001af0 <chIQReadTimeout>
 8001faa:	bf00      	nop
 8001fac:	f3af 8000 	nop.w

08001fb0 <writet>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t time) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, time);
 8001fb0:	3030      	adds	r0, #48	; 0x30
 8001fb2:	f7ff be35 	b.w	8001c20 <chOQWriteTimeout>
 8001fb6:	bf00      	nop
 8001fb8:	f3af 8000 	nop.w
 8001fbc:	f3af 8000 	nop.w

08001fc0 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8001fc0:	3030      	adds	r0, #48	; 0x30
 8001fc2:	f04f 33ff 	mov.w	r3, #4294967295
 8001fc6:	f7ff be2b 	b.w	8001c20 <chOQWriteTimeout>
 8001fca:	bf00      	nop
 8001fcc:	f3af 8000 	nop.w

08001fd0 <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001fd0:	300c      	adds	r0, #12
 8001fd2:	f7ff bd65 	b.w	8001aa0 <chIQGetTimeout>
 8001fd6:	bf00      	nop
 8001fd8:	f3af 8000 	nop.w
 8001fdc:	f3af 8000 	nop.w

08001fe0 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001fe0:	300c      	adds	r0, #12
 8001fe2:	f04f 31ff 	mov.w	r1, #4294967295
 8001fe6:	f7ff bd5b 	b.w	8001aa0 <chIQGetTimeout>
 8001fea:	bf00      	nop
 8001fec:	f3af 8000 	nop.w

08001ff0 <putt>:
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8001ff0:	3030      	adds	r0, #48	; 0x30
 8001ff2:	f7ff bdcd 	b.w	8001b90 <chOQPutTimeout>
 8001ff6:	bf00      	nop
 8001ff8:	f3af 8000 	nop.w
 8001ffc:	f3af 8000 	nop.w

08002000 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8002000:	3030      	adds	r0, #48	; 0x30
 8002002:	f04f 32ff 	mov.w	r2, #4294967295
 8002006:	f7ff bdc3 	b.w	8001b90 <chOQPutTimeout>
 800200a:	bf00      	nop
 800200c:	f3af 8000 	nop.w

08002010 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 8002010:	f001 b966 	b.w	80032e0 <sd_lld_init>
 8002014:	f3af 8000 	nop.w
 8002018:	f3af 8000 	nop.w
 800201c:	f3af 8000 	nop.w

08002020 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8002020:	b570      	push	{r4, r5, r6, lr}

  sdp->vmt = &vmt;
 8002022:	4b0e      	ldr	r3, [pc, #56]	; (800205c <sdObjectInit+0x3c>)
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8002024:	4604      	mov	r4, r0
 8002026:	b082      	sub	sp, #8

  sdp->vmt = &vmt;
 8002028:	f840 3b04 	str.w	r3, [r0], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800202c:	2601      	movs	r6, #1
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 800202e:	9400      	str	r4, [sp, #0]
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8002030:	460b      	mov	r3, r1
 8002032:	4615      	mov	r5, r2
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)(void *)esp;
 8002034:	6060      	str	r0, [r4, #4]

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8002036:	f104 0154 	add.w	r1, r4, #84	; 0x54
 800203a:	f104 000c 	add.w	r0, r4, #12
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800203e:	7226      	strb	r6, [r4, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8002040:	2210      	movs	r2, #16
 8002042:	f7ff fcfd 	bl	8001a40 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8002046:	9400      	str	r4, [sp, #0]
 8002048:	462b      	mov	r3, r5
 800204a:	f104 0030 	add.w	r0, r4, #48	; 0x30
 800204e:	f104 0164 	add.w	r1, r4, #100	; 0x64
 8002052:	2210      	movs	r2, #16
 8002054:	f7ff fd8c 	bl	8001b70 <chOQObjectInit>
}
 8002058:	b002      	add	sp, #8
 800205a:	bd70      	pop	{r4, r5, r6, pc}
 800205c:	080068e0 	.word	0x080068e0

08002060 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8002060:	b510      	push	{r4, lr}
 8002062:	2320      	movs	r3, #32
 8002064:	4604      	mov	r4, r0
 8002066:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 800206a:	f001 f951 	bl	8003310 <sd_lld_start>
  sdp->state = SD_READY;
 800206e:	2302      	movs	r3, #2
 8002070:	7223      	strb	r3, [r4, #8]
 8002072:	2300      	movs	r3, #0
 8002074:	f383 8811 	msr	BASEPRI, r3
 8002078:	bd10      	pop	{r4, pc}
 800207a:	bf00      	nop
 800207c:	f3af 8000 	nop.w

08002080 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8002080:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8002082:	6943      	ldr	r3, [r0, #20]
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8002084:	4604      	mov	r4, r0
 8002086:	460d      	mov	r5, r1

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8002088:	b13b      	cbz	r3, 800209a <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 800208a:	4629      	mov	r1, r5
 800208c:	f104 000c 	add.w	r0, r4, #12
 8002090:	f7ff fce6 	bl	8001a60 <chIQPutI>
 8002094:	2800      	cmp	r0, #0
 8002096:	db0b      	blt.n	80020b0 <sdIncomingDataI+0x30>
 8002098:	bd38      	pop	{r3, r4, r5, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800209a:	3004      	adds	r0, #4
 800209c:	2104      	movs	r1, #4
 800209e:	f7ff fc77 	bl	8001990 <chEvtBroadcastFlagsI>
 80020a2:	4629      	mov	r1, r5
 80020a4:	f104 000c 	add.w	r0, r4, #12
 80020a8:	f7ff fcda 	bl	8001a60 <chIQPutI>
 80020ac:	2800      	cmp	r0, #0
 80020ae:	daf3      	bge.n	8002098 <sdIncomingDataI+0x18>
 80020b0:	1d20      	adds	r0, r4, #4
 80020b2:	2180      	movs	r1, #128	; 0x80
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
}
 80020b4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80020b8:	f7ff bc6a 	b.w	8001990 <chEvtBroadcastFlagsI>
 80020bc:	f3af 8000 	nop.w

080020c0 <sduInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sduInit(void) {
 80020c0:	4770      	bx	lr
 80020c2:	bf00      	nop
 80020c4:	f3af 8000 	nop.w
 80020c8:	f3af 8000 	nop.w
 80020cc:	f3af 8000 	nop.w

080020d0 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
 80020d0:	f001 b85e 	b.w	8003190 <st_lld_init>
 80020d4:	f3af 8000 	nop.w
 80020d8:	f3af 8000 	nop.w
 80020dc:	f3af 8000 	nop.w

080020e0 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80020e0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->SR     = 0;
 80020e4:	2100      	movs	r1, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80020e6:	2202      	movs	r2, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80020e8:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80020ea:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80020ec:	60da      	str	r2, [r3, #12]
 80020ee:	4770      	bx	lr

080020f0 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80020f0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80020f4:	2200      	movs	r2, #0
 80020f6:	60da      	str	r2, [r3, #12]
 80020f8:	4770      	bx	lr
 80020fa:	bf00      	nop
 80020fc:	f3af 8000 	nop.w

08002100 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002100:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002104:	6358      	str	r0, [r3, #52]	; 0x34
 8002106:	4770      	bx	lr
 8002108:	f3af 8000 	nop.w
 800210c:	f3af 8000 	nop.w

08002110 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 8002110:	b510      	push	{r4, lr}
 8002112:	4604      	mov	r4, r0

  usbp->address = usbp->setup[2];
 8002114:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
 8002118:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
  usb_lld_set_address(usbp);
 800211c:	f001 fb40 	bl	80037a0 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8002120:	6863      	ldr	r3, [r4, #4]
 8002122:	681b      	ldr	r3, [r3, #0]
 8002124:	b113      	cbz	r3, 800212c <set_address+0x1c>
 8002126:	4620      	mov	r0, r4
 8002128:	2101      	movs	r1, #1
 800212a:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 800212c:	2303      	movs	r3, #3
 800212e:	7023      	strb	r3, [r4, #0]
 8002130:	bd10      	pop	{r4, pc}
 8002132:	bf00      	nop
 8002134:	f3af 8000 	nop.w
 8002138:	f3af 8000 	nop.w
 800213c:	f3af 8000 	nop.w

08002140 <usbInit>:
 *
 * @init
 */
void usbInit(void) {

  usb_lld_init();
 8002140:	f001 bb26 	b.w	8003790 <usb_lld_init>
 8002144:	f3af 8000 	nop.w
 8002148:	f3af 8000 	nop.w
 800214c:	f3af 8000 	nop.w

08002150 <usbObjectInit>:
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8002150:	2301      	movs	r3, #1
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 8002152:	b430      	push	{r4, r5}
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
 8002154:	2200      	movs	r2, #0
 8002156:	f100 0544 	add.w	r5, r0, #68	; 0x44
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 800215a:	7003      	strb	r3, [r0, #0]
  usbp->config       = NULL;
 800215c:	4629      	mov	r1, r5
 800215e:	6042      	str	r2, [r0, #4]
 8002160:	f100 0328 	add.w	r3, r0, #40	; 0x28
  for (i = 0; i < USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8002164:	f843 2f04 	str.w	r2, [r3, #4]!
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < USB_MAX_ENDPOINTS; i++) {
 8002168:	42ab      	cmp	r3, r5
    usbp->in_params[i]  = NULL;
 800216a:	f04f 0400 	mov.w	r4, #0
    usbp->out_params[i] = NULL;
 800216e:	f841 2f04 	str.w	r2, [r1, #4]!
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < USB_MAX_ENDPOINTS; i++) {
 8002172:	d1f7      	bne.n	8002164 <usbObjectInit+0x14>
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 8002174:	8104      	strh	r4, [r0, #8]
  usbp->receiving    = 0;
 8002176:	8144      	strh	r4, [r0, #10]
}
 8002178:	bc30      	pop	{r4, r5}
 800217a:	4770      	bx	lr
 800217c:	f3af 8000 	nop.w

08002180 <usbStartReceiveI>:
 * @retval false        Operation started successfully.
 * @retval true         Endpoint busy, operation not started.
 *
 * @iclass
 */
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {
 8002180:	b570      	push	{r4, r5, r6, lr}

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep))
 8002182:	8945      	ldrh	r5, [r0, #10]
 8002184:	fa45 f301 	asr.w	r3, r5, r1
 8002188:	f013 0401 	ands.w	r4, r3, #1
 800218c:	d001      	beq.n	8002192 <usbStartReceiveI+0x12>
    return true;
 800218e:	2001      	movs	r0, #1

  usbp->receiving |= (1 << ep);
  usb_lld_start_out(usbp, ep);
  return false;
}
 8002190:	bd70      	pop	{r4, r5, r6, pc}
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep))
    return true;

  usbp->receiving |= (1 << ep);
 8002192:	2301      	movs	r3, #1
 8002194:	408b      	lsls	r3, r1
 8002196:	431d      	orrs	r5, r3
 8002198:	8145      	strh	r5, [r0, #10]
  usb_lld_start_out(usbp, ep);
 800219a:	f001 fc39 	bl	8003a10 <usb_lld_start_out>
  return false;
 800219e:	4620      	mov	r0, r4
 80021a0:	bd70      	pop	{r4, r5, r6, pc}
 80021a2:	bf00      	nop
 80021a4:	f3af 8000 	nop.w
 80021a8:	f3af 8000 	nop.w
 80021ac:	f3af 8000 	nop.w

080021b0 <usbStartTransmitI>:
 * @retval false        Operation started successfully.
 * @retval true         Endpoint busy, operation not started.
 *
 * @iclass
 */
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {
 80021b0:	b570      	push	{r4, r5, r6, lr}

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep))
 80021b2:	8905      	ldrh	r5, [r0, #8]
 80021b4:	fa45 f301 	asr.w	r3, r5, r1
 80021b8:	f013 0401 	ands.w	r4, r3, #1
 80021bc:	d001      	beq.n	80021c2 <usbStartTransmitI+0x12>
    return true;
 80021be:	2001      	movs	r0, #1

  usbp->transmitting |= (1 << ep);
  usb_lld_start_in(usbp, ep);
  return false;
}
 80021c0:	bd70      	pop	{r4, r5, r6, pc}
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep))
    return true;

  usbp->transmitting |= (1 << ep);
 80021c2:	2301      	movs	r3, #1
 80021c4:	408b      	lsls	r3, r1
 80021c6:	431d      	orrs	r5, r3
 80021c8:	8105      	strh	r5, [r0, #8]
  usb_lld_start_in(usbp, ep);
 80021ca:	f001 fc39 	bl	8003a40 <usb_lld_start_in>
  return false;
 80021ce:	4620      	mov	r0, r4
 80021d0:	bd70      	pop	{r4, r5, r6, pc}
 80021d2:	bf00      	nop
 80021d4:	f3af 8000 	nop.w
 80021d8:	f3af 8000 	nop.w
 80021dc:	f3af 8000 	nop.w

080021e0 <_usb_reset>:
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  usbp->state         = USB_READY;
  usbp->status        = 0;
 80021e0:	2200      	movs	r2, #0
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  usbp->state         = USB_READY;
 80021e2:	2302      	movs	r3, #2
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 80021e4:	b410      	push	{r4}
  unsigned i;

  usbp->state         = USB_READY;
 80021e6:	7003      	strb	r3, [r0, #0]
  usbp->status        = 0;
 80021e8:	f8a0 207c 	strh.w	r2, [r0, #124]	; 0x7c
  usbp->address       = 0;
 80021ec:	f880 207e 	strb.w	r2, [r0, #126]	; 0x7e
  usbp->configuration = 0;
 80021f0:	f880 207f 	strb.w	r2, [r0, #127]	; 0x7f
  usbp->transmitting  = 0;
 80021f4:	8102      	strh	r2, [r0, #8]
  usbp->receiving     = 0;
 80021f6:	8142      	strh	r2, [r0, #10]
 80021f8:	f100 0308 	add.w	r3, r0, #8
 80021fc:	f100 0428 	add.w	r4, r0, #40	; 0x28

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= USB_MAX_ENDPOINTS; i++)
    usbp->epc[i] = NULL;
 8002200:	f843 2f04 	str.w	r2, [r3, #4]!
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= USB_MAX_ENDPOINTS; i++)
 8002204:	42a3      	cmp	r3, r4
    usbp->epc[i] = NULL;
 8002206:	f04f 0100 	mov.w	r1, #0
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= USB_MAX_ENDPOINTS; i++)
 800220a:	d1f9      	bne.n	8002200 <_usb_reset+0x20>
    usbp->epc[i] = NULL;

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800220c:	f880 1064 	strb.w	r1, [r0, #100]	; 0x64

  /* Low level reset.*/
  usb_lld_reset(usbp);
}
 8002210:	f85d 4b04 	ldr.w	r4, [sp], #4

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;

  /* Low level reset.*/
  usb_lld_reset(usbp);
 8002214:	f001 bb44 	b.w	80038a0 <usb_lld_reset>
 8002218:	f3af 8000 	nop.w
 800221c:	f3af 8000 	nop.w

08002220 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8002220:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8002222:	2300      	movs	r3, #0
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8002224:	4604      	mov	r4, r0
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8002226:	f880 3064 	strb.w	r3, [r0, #100]	; 0x64
  usbReadSetup(usbp, ep, usbp->setup);
 800222a:	f100 0274 	add.w	r2, r0, #116	; 0x74
 800222e:	f001 fb7f 	bl	8003930 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  if (!(usbp->config->requests_hook_cb) ||
 8002232:	6863      	ldr	r3, [r4, #4]
 8002234:	689b      	ldr	r3, [r3, #8]
 8002236:	b363      	cbz	r3, 8002292 <_usb_ep0setup+0x72>
      !(usbp->config->requests_hook_cb(usbp))) {
 8002238:	4620      	mov	r0, r4
 800223a:	4798      	blx	r3
  usbp->ep0state = USB_EP0_WAITING_SETUP;
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  if (!(usbp->config->requests_hook_cb) ||
 800223c:	b348      	cbz	r0, 8002292 <_usb_ep0setup+0x72>
 800223e:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
 8002240:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = usbFetchWord(&usbp->setup[6]);
 8002244:	f894 107b 	ldrb.w	r1, [r4, #123]	; 0x7b
 8002248:	f894 207a 	ldrb.w	r2, [r4, #122]	; 0x7a
 800224c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max)
 8002250:	42aa      	cmp	r2, r5
    usbp->ep0n = max;
 8002252:	bf3c      	itt	cc
 8002254:	66e2      	strcc	r2, [r4, #108]	; 0x6c
 8002256:	4615      	movcc	r5, r2
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8002258:	f013 0f80 	tst.w	r3, #128	; 0x80
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800225c:	68e3      	ldr	r3, [r4, #12]
     usbSetupTransfer().*/
  max = usbFetchWord(&usbp->setup[6]);
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max)
    usbp->ep0n = max;
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800225e:	f040 808c 	bne.w	800237a <_usb_ep0setup+0x15a>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n > 0) {
 8002262:	2d00      	cmp	r5, #0
 8002264:	d171      	bne.n	800234a <_usb_ep0setup+0x12a>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8002266:	695b      	ldr	r3, [r3, #20]
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8002268:	2205      	movs	r2, #5
 800226a:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 800226e:	4620      	mov	r0, r4
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8002270:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 8002272:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 8002274:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 8002276:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 8002278:	4629      	mov	r1, r5
 800227a:	f001 fb89 	bl	8003990 <usb_lld_prepare_transmit>
 800227e:	2320      	movs	r3, #32
 8002280:	f383 8811 	msr	BASEPRI, r3
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      usbPrepareTransmit(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0);
 8002284:	4620      	mov	r0, r4
 8002286:	4629      	mov	r1, r5
 8002288:	f7ff ff92 	bl	80021b0 <usbStartTransmitI>
 800228c:	f385 8811 	msr	BASEPRI, r5
 8002290:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     request.*/
  if (!(usbp->config->requests_hook_cb) ||
      !(usbp->config->requests_hook_cb(usbp))) {
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8002292:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8002296:	f013 0760 	ands.w	r7, r3, #96	; 0x60
 800229a:	d011      	beq.n	80022c0 <_usb_ep0setup+0xa0>
        !default_handler(usbp)) {
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 800229c:	4620      	mov	r0, r4
 800229e:	2100      	movs	r1, #0
 80022a0:	f001 fbfe 	bl	8003aa0 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 80022a4:	4620      	mov	r0, r4
 80022a6:	2100      	movs	r1, #0
 80022a8:	f001 fbe2 	bl	8003a70 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80022ac:	6863      	ldr	r3, [r4, #4]
 80022ae:	681b      	ldr	r3, [r3, #0]
 80022b0:	b113      	cbz	r3, 80022b8 <_usb_ep0setup+0x98>
 80022b2:	4620      	mov	r0, r4
 80022b4:	2105      	movs	r1, #5
 80022b6:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 80022b8:	2306      	movs	r3, #6
 80022ba:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      return;
 80022be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch (((usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                              USB_RTYPE_TYPE_MASK)) |
           (usbp->setup[1] << 8))) {
 80022c0:	f894 5075 	ldrb.w	r5, [r4, #117]	; 0x75
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch (((usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80022c4:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                              USB_RTYPE_TYPE_MASK)) |
 80022c8:	ea42 2605 	orr.w	r6, r2, r5, lsl #8
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch (((usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80022cc:	f5b6 7f40 	cmp.w	r6, #768	; 0x300
 80022d0:	f000 80f1 	beq.w	80024b6 <_usb_ep0setup+0x296>
 80022d4:	dd17      	ble.n	8002306 <_usb_ep0setup+0xe6>
 80022d6:	f5b6 6fc0 	cmp.w	r6, #1536	; 0x600
 80022da:	f000 80d3 	beq.w	8002484 <_usb_ep0setup+0x264>
 80022de:	dd7b      	ble.n	80023d8 <_usb_ep0setup+0x1b8>
 80022e0:	f5b6 6f10 	cmp.w	r6, #2304	; 0x900
 80022e4:	f000 8086 	beq.w	80023f4 <_usb_ep0setup+0x1d4>
 80022e8:	f640 4202 	movw	r2, #3074	; 0xc02
 80022ec:	4296      	cmp	r6, r2
 80022ee:	f000 80c2 	beq.w	8002476 <_usb_ep0setup+0x256>
 80022f2:	f5b6 6f00 	cmp.w	r6, #2048	; 0x800
 80022f6:	d1d1      	bne.n	800229c <_usb_ep0setup+0x7c>
      return false;
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    return true;
  case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 80022f8:	f104 027f 	add.w	r2, r4, #127	; 0x7f
 80022fc:	2501      	movs	r5, #1
 80022fe:	6727      	str	r7, [r4, #112]	; 0x70
 8002300:	66a2      	str	r2, [r4, #104]	; 0x68
 8002302:	66e5      	str	r5, [r4, #108]	; 0x6c
 8002304:	e79e      	b.n	8002244 <_usb_ep0setup+0x24>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch (((usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002306:	2e02      	cmp	r6, #2
 8002308:	f000 80e5 	beq.w	80024d6 <_usb_ep0setup+0x2b6>
 800230c:	f340 80a8 	ble.w	8002460 <_usb_ep0setup+0x240>
 8002310:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 8002314:	f000 8081 	beq.w	800241a <_usb_ep0setup+0x1fa>
 8002318:	f5b6 7f81 	cmp.w	r6, #258	; 0x102
 800231c:	d1be      	bne.n	800229c <_usb_ep0setup+0x7c>
        return false;
      }
    }
  case USB_RTYPE_RECIPIENT_ENDPOINT | (USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT)
 800231e:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 8002322:	2a00      	cmp	r2, #0
 8002324:	d1ba      	bne.n	800229c <_usb_ep0setup+0x7c>
      return false;
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0F) > 0) {
 8002326:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
 800232a:	f012 010f 	ands.w	r1, r2, #15
 800232e:	d007      	beq.n	8002340 <_usb_ep0setup+0x120>
      if (usbp->setup[4] & 0x80)
 8002330:	0612      	lsls	r2, r2, #24
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0F);
 8002332:	4620      	mov	r0, r4
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT)
      return false;
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0F) > 0) {
      if (usbp->setup[4] & 0x80)
 8002334:	f100 80f5 	bmi.w	8002522 <_usb_ep0setup+0x302>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0F);
      else
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0F);
 8002338:	f001 fbca 	bl	8003ad0 <usb_lld_clear_out>
 800233c:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
      if (usbp->setup[4] & 0x80)
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0F);
      else
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0F);
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8002340:	2500      	movs	r5, #0
 8002342:	66a5      	str	r5, [r4, #104]	; 0x68
 8002344:	66e5      	str	r5, [r4, #108]	; 0x6c
 8002346:	6725      	str	r5, [r4, #112]	; 0x70
 8002348:	e77c      	b.n	8002244 <_usb_ep0setup+0x24>
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800234a:	699b      	ldr	r3, [r3, #24]
  else {
    /* OUT phase.*/
    if (usbp->ep0n > 0) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
 800234c:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800234e:	2600      	movs	r6, #0
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n > 0) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8002350:	2104      	movs	r1, #4
 8002352:	f884 1064 	strb.w	r1, [r4, #100]	; 0x64
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 8002356:	4620      	mov	r0, r4
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
 8002358:	60da      	str	r2, [r3, #12]
  osp->rxsize             = n;
 800235a:	605d      	str	r5, [r3, #4]
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 800235c:	701e      	strb	r6, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 800235e:	609e      	str	r6, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 8002360:	4631      	mov	r1, r6
 8002362:	f001 fb05 	bl	8003970 <usb_lld_prepare_receive>
 8002366:	2320      	movs	r3, #32
 8002368:	f383 8811 	msr	BASEPRI, r3
    if (usbp->ep0n > 0) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0);
 800236c:	4620      	mov	r0, r4
 800236e:	4631      	mov	r1, r6
 8002370:	f7ff ff06 	bl	8002180 <usbStartReceiveI>
 8002374:	f386 8811 	msr	BASEPRI, r6
 8002378:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max)
    usbp->ep0n = max;
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n > 0) {
 800237a:	b1bd      	cbz	r5, 80023ac <_usb_ep0setup+0x18c>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800237c:	695b      	ldr	r3, [r3, #20]
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n > 0) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
      usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
 800237e:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8002380:	2600      	movs	r6, #0
    usbp->ep0n = max;
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n > 0) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 8002382:	2101      	movs	r1, #1
 8002384:	f884 1064 	strb.w	r1, [r4, #100]	; 0x64
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8002388:	4620      	mov	r0, r4
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
 800238a:	60da      	str	r2, [r3, #12]
  isp->txsize             = n;
 800238c:	605d      	str	r5, [r3, #4]
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 800238e:	701e      	strb	r6, [r3, #0]
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;
 8002390:	609e      	str	r6, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 8002392:	4631      	mov	r1, r6
 8002394:	f001 fafc 	bl	8003990 <usb_lld_prepare_transmit>
 8002398:	2320      	movs	r3, #32
 800239a:	f383 8811 	msr	BASEPRI, r3
    if (usbp->ep0n > 0) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
      usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0);
 800239e:	4620      	mov	r0, r4
 80023a0:	4631      	mov	r1, r6
 80023a2:	f7ff ff05 	bl	80021b0 <usbStartTransmitI>
 80023a6:	f386 8811 	msr	BASEPRI, r6
 80023aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80023ac:	699b      	ldr	r3, [r3, #24]
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 80023ae:	2203      	movs	r2, #3
 80023b0:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 80023b4:	4620      	mov	r0, r4
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 80023b6:	701d      	strb	r5, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
 80023b8:	60dd      	str	r5, [r3, #12]
  osp->rxsize             = n;
 80023ba:	605d      	str	r5, [r3, #4]
  osp->rxcnt              = 0;
 80023bc:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 80023be:	4629      	mov	r1, r5
 80023c0:	f001 fad6 	bl	8003970 <usb_lld_prepare_receive>
 80023c4:	2320      	movs	r3, #32
 80023c6:	f383 8811 	msr	BASEPRI, r3
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      usbPrepareReceive(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0);
 80023ca:	4620      	mov	r0, r4
 80023cc:	4629      	mov	r1, r5
 80023ce:	f7ff fed7 	bl	8002180 <usbStartReceiveI>
 80023d2:	f385 8811 	msr	BASEPRI, r5
 80023d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch (((usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80023d8:	f240 3202 	movw	r2, #770	; 0x302
 80023dc:	4296      	cmp	r6, r2
 80023de:	d02c      	beq.n	800243a <_usb_ep0setup+0x21a>
 80023e0:	f5b6 6fa0 	cmp.w	r6, #1280	; 0x500
 80023e4:	f47f af5a 	bne.w	800229c <_usb_ep0setup+0x7c>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
        (usbp->setup[1] == USB_REQ_SET_ADDRESS))
      set_address(usbp);
    usbSetupTransfer(usbp, NULL, 0, NULL);
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
 80023e8:	4a53      	ldr	r2, [pc, #332]	; (8002538 <_usb_ep0setup+0x318>)
 80023ea:	66a7      	str	r7, [r4, #104]	; 0x68
 80023ec:	66e7      	str	r7, [r4, #108]	; 0x6c
 80023ee:	463d      	mov	r5, r7
 80023f0:	6722      	str	r2, [r4, #112]	; 0x70
 80023f2:	e727      	b.n	8002244 <_usb_ep0setup+0x24>
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
    return true;
  case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host.*/
    usbp->configuration = usbp->setup[2];
 80023f4:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 80023f8:	f884 207f 	strb.w	r2, [r4, #127]	; 0x7f
    if (usbp->configuration == 0)
 80023fc:	2a00      	cmp	r2, #0
 80023fe:	f040 8081 	bne.w	8002504 <_usb_ep0setup+0x2e4>
      usbp->state = USB_SELECTED;
 8002402:	2203      	movs	r2, #3
 8002404:	7022      	strb	r2, [r4, #0]
    else
      usbp->state = USB_ACTIVE;
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8002406:	6862      	ldr	r2, [r4, #4]
 8002408:	6812      	ldr	r2, [r2, #0]
 800240a:	2a00      	cmp	r2, #0
 800240c:	d098      	beq.n	8002340 <_usb_ep0setup+0x120>
 800240e:	4620      	mov	r0, r4
 8002410:	2102      	movs	r1, #2
 8002412:	4790      	blx	r2
 8002414:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8002418:	e792      	b.n	8002340 <_usb_ep0setup+0x120>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    return true;
  case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800241a:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 800241e:	2a01      	cmp	r2, #1
 8002420:	f47f af3c 	bne.w	800229c <_usb_ep0setup+0x7c>
      usbp->status &= ~2;
 8002424:	f8b4 207c 	ldrh.w	r2, [r4, #124]	; 0x7c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8002428:	66a7      	str	r7, [r4, #104]	; 0x68
    return true;
  case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2;
 800242a:	f022 0202 	bic.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800242e:	66e7      	str	r7, [r4, #108]	; 0x6c
 8002430:	6727      	str	r7, [r4, #112]	; 0x70
 8002432:	463d      	mov	r5, r7
    return true;
  case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2;
 8002434:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
 8002438:	e704      	b.n	8002244 <_usb_ep0setup+0x24>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  case USB_RTYPE_RECIPIENT_ENDPOINT | (USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT)
 800243a:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 800243e:	2a00      	cmp	r2, #0
 8002440:	f47f af2c 	bne.w	800229c <_usb_ep0setup+0x7c>
      return false;
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0F) > 0) {
 8002444:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
 8002448:	f012 010f 	ands.w	r1, r2, #15
 800244c:	f43f af78 	beq.w	8002340 <_usb_ep0setup+0x120>
      if (usbp->setup[4] & 0x80)
 8002450:	0613      	lsls	r3, r2, #24
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0F);
 8002452:	4620      	mov	r0, r4
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT)
      return false;
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0F) > 0) {
      if (usbp->setup[4] & 0x80)
 8002454:	d46a      	bmi.n	800252c <_usb_ep0setup+0x30c>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0F);
      else
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0F);
 8002456:	f001 fb0b 	bl	8003a70 <usb_lld_stall_out>
 800245a:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 800245e:	e76f      	b.n	8002340 <_usb_ep0setup+0x120>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch (((usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002460:	b936      	cbnz	r6, 8002470 <_usb_ep0setup+0x250>
                              USB_RTYPE_TYPE_MASK)) |
           (usbp->setup[1] << 8))) {
  case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8002462:	f104 027c 	add.w	r2, r4, #124	; 0x7c
 8002466:	2502      	movs	r5, #2
 8002468:	6726      	str	r6, [r4, #112]	; 0x70
 800246a:	66a2      	str	r2, [r4, #104]	; 0x68
 800246c:	66e5      	str	r5, [r4, #108]	; 0x6c
 800246e:	e6e9      	b.n	8002244 <_usb_ep0setup+0x24>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch (((usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002470:	2e01      	cmp	r6, #1
 8002472:	f47f af13 	bne.w	800229c <_usb_ep0setup+0x7c>
    return true;
  case USB_RTYPE_RECIPIENT_INTERFACE | (USB_REQ_GET_STATUS << 8):
  case USB_RTYPE_RECIPIENT_ENDPOINT | (USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8002476:	4a31      	ldr	r2, [pc, #196]	; (800253c <_usb_ep0setup+0x31c>)
 8002478:	66a2      	str	r2, [r4, #104]	; 0x68
 800247a:	2502      	movs	r5, #2
 800247c:	2200      	movs	r2, #0
 800247e:	66e5      	str	r5, [r4, #108]	; 0x6c
 8002480:	6722      	str	r2, [r4, #112]	; 0x70
 8002482:	e6df      	b.n	8002244 <_usb_ep0setup+0x24>
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(
 8002484:	6862      	ldr	r2, [r4, #4]
           usbp, usbp->setup[3], usbp->setup[2],
           usbFetchWord(&usbp->setup[4]));
 8002486:	f894 0079 	ldrb.w	r0, [r4, #121]	; 0x79
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(
 800248a:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
 800248e:	6855      	ldr	r5, [r2, #4]
 8002490:	f894 1077 	ldrb.w	r1, [r4, #119]	; 0x77
 8002494:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 8002498:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800249c:	4620      	mov	r0, r4
 800249e:	47a8      	blx	r5
           usbp, usbp->setup[3], usbp->setup[2],
           usbFetchWord(&usbp->setup[4]));
    if (dp == NULL)
 80024a0:	2800      	cmp	r0, #0
 80024a2:	f43f aefb 	beq.w	800229c <_usb_ep0setup+0x7c>
      return false;
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 80024a6:	6843      	ldr	r3, [r0, #4]
 80024a8:	6805      	ldr	r5, [r0, #0]
 80024aa:	66e5      	str	r5, [r4, #108]	; 0x6c
 80024ac:	66a3      	str	r3, [r4, #104]	; 0x68
 80024ae:	6727      	str	r7, [r4, #112]	; 0x70
 80024b0:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 80024b4:	e6c6      	b.n	8002244 <_usb_ep0setup+0x24>
    }
    return false;
  case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80024b6:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
 80024ba:	2a01      	cmp	r2, #1
 80024bc:	f47f aeee 	bne.w	800229c <_usb_ep0setup+0x7c>
      usbp->status |= 2;
 80024c0:	f8b4 207c 	ldrh.w	r2, [r4, #124]	; 0x7c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80024c4:	66a7      	str	r7, [r4, #104]	; 0x68
    return false;
  case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2;
 80024c6:	f042 0202 	orr.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80024ca:	66e7      	str	r7, [r4, #108]	; 0x6c
 80024cc:	6727      	str	r7, [r4, #112]	; 0x70
 80024ce:	463d      	mov	r5, r7
    return false;
  case USB_RTYPE_RECIPIENT_DEVICE | (USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2;
 80024d0:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
 80024d4:	e6b6      	b.n	8002244 <_usb_ep0setup+0x24>
       using a hook..*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    return true;
  case USB_RTYPE_RECIPIENT_ENDPOINT | (USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if (usbp->setup[4] & 0x80) {
 80024d6:	f894 1078 	ldrb.w	r1, [r4, #120]	; 0x78
 80024da:	f011 0f80 	tst.w	r1, #128	; 0x80
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0F)) {
 80024de:	4620      	mov	r0, r4
 80024e0:	f001 010f 	and.w	r1, r1, #15
       using a hook..*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    return true;
  case USB_RTYPE_RECIPIENT_ENDPOINT | (USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if (usbp->setup[4] & 0x80) {
 80024e4:	d111      	bne.n	800250a <_usb_ep0setup+0x2ea>
      default:
        return false;
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0F)) {
 80024e6:	f001 fa03 	bl	80038f0 <usb_lld_get_status_out>
 80024ea:	2801      	cmp	r0, #1
 80024ec:	d011      	beq.n	8002512 <_usb_ep0setup+0x2f2>
 80024ee:	2802      	cmp	r0, #2
 80024f0:	f47f aed4 	bne.w	800229c <_usb_ep0setup+0x7c>
      case EP_STATUS_STALLED:
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
        return true;
      case EP_STATUS_ACTIVE:
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 80024f4:	4b12      	ldr	r3, [pc, #72]	; (8002540 <_usb_ep0setup+0x320>)
 80024f6:	66a3      	str	r3, [r4, #104]	; 0x68
 80024f8:	66e0      	str	r0, [r4, #108]	; 0x6c
 80024fa:	6727      	str	r7, [r4, #112]	; 0x70
 80024fc:	4605      	mov	r5, r0
 80024fe:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8002502:	e69f      	b.n	8002244 <_usb_ep0setup+0x24>
    /* Handling configuration selection from the host.*/
    usbp->configuration = usbp->setup[2];
    if (usbp->configuration == 0)
      usbp->state = USB_SELECTED;
    else
      usbp->state = USB_ACTIVE;
 8002504:	2204      	movs	r2, #4
 8002506:	7022      	strb	r2, [r4, #0]
 8002508:	e77d      	b.n	8002406 <_usb_ep0setup+0x1e6>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    return true;
  case USB_RTYPE_RECIPIENT_ENDPOINT | (USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if (usbp->setup[4] & 0x80) {
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0F)) {
 800250a:	f001 fa01 	bl	8003910 <usb_lld_get_status_in>
 800250e:	2801      	cmp	r0, #1
 8002510:	d1ed      	bne.n	80024ee <_usb_ep0setup+0x2ce>
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0F)) {
      case EP_STATUS_STALLED:
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8002512:	4b0c      	ldr	r3, [pc, #48]	; (8002544 <_usb_ep0setup+0x324>)
 8002514:	66a3      	str	r3, [r4, #104]	; 0x68
 8002516:	66e6      	str	r6, [r4, #108]	; 0x6c
 8002518:	6727      	str	r7, [r4, #112]	; 0x70
 800251a:	4635      	mov	r5, r6
 800251c:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8002520:	e690      	b.n	8002244 <_usb_ep0setup+0x24>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT)
      return false;
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0F) > 0) {
      if (usbp->setup[4] & 0x80)
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0F);
 8002522:	f001 faed 	bl	8003b00 <usb_lld_clear_in>
 8002526:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 800252a:	e709      	b.n	8002340 <_usb_ep0setup+0x120>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT)
      return false;
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0F) > 0) {
      if (usbp->setup[4] & 0x80)
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0F);
 800252c:	f001 fab8 	bl	8003aa0 <usb_lld_stall_in>
 8002530:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8002534:	e704      	b.n	8002340 <_usb_ep0setup+0x120>
 8002536:	bf00      	nop
 8002538:	08002111 	.word	0x08002111
 800253c:	08006900 	.word	0x08006900
 8002540:	08006910 	.word	0x08006910
 8002544:	08006920 	.word	0x08006920
 8002548:	f3af 8000 	nop.w
 800254c:	f3af 8000 	nop.w

08002550 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8002550:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8002552:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
 8002556:	2b02      	cmp	r3, #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8002558:	4604      	mov	r4, r0
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800255a:	d042      	beq.n	80025e2 <_usb_ep0in+0x92>
 800255c:	2b05      	cmp	r3, #5
 800255e:	d039      	beq.n	80025d4 <_usb_ep0in+0x84>
 8002560:	2b01      	cmp	r3, #1
 8002562:	d010      	beq.n	8002586 <_usb_ep0in+0x36>
    ;
  }
  /* Error response, the state machine goes into an error state, the low
     level layer will have to reset it to USB_EP0_WAITING_SETUP after
     receiving a SETUP packet.*/
  usb_lld_stall_in(usbp, 0);
 8002564:	2100      	movs	r1, #0
 8002566:	f001 fa9b 	bl	8003aa0 <usb_lld_stall_in>
  usb_lld_stall_out(usbp, 0);
 800256a:	4620      	mov	r0, r4
 800256c:	2100      	movs	r1, #0
 800256e:	f001 fa7f 	bl	8003a70 <usb_lld_stall_out>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8002572:	6863      	ldr	r3, [r4, #4]
 8002574:	681b      	ldr	r3, [r3, #0]
 8002576:	b113      	cbz	r3, 800257e <_usb_ep0in+0x2e>
 8002578:	4620      	mov	r0, r4
 800257a:	2105      	movs	r1, #5
 800257c:	4798      	blx	r3
  usbp->ep0state = USB_EP0_ERROR;
 800257e:	2306      	movs	r3, #6
 8002580:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8002584:	bd38      	pop	{r3, r4, r5, pc}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_TX:
    max = usbFetchWord(&usbp->setup[6]);
 8002586:	f890 207b 	ldrb.w	r2, [r0, #123]	; 0x7b
 800258a:	f890 307a 	ldrb.w	r3, [r0, #122]	; 0x7a
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) && ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0)) {
 800258e:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_TX:
    max = usbFetchWord(&usbp->setup[6]);
 8002590:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) && ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0)) {
 8002594:	428b      	cmp	r3, r1
 8002596:	68c3      	ldr	r3, [r0, #12]
 8002598:	d905      	bls.n	80025a6 <_usb_ep0in+0x56>
 800259a:	8a1d      	ldrh	r5, [r3, #16]
 800259c:	fbb1 f2f5 	udiv	r2, r1, r5
 80025a0:	fb05 1512 	mls	r5, r5, r2, r1
 80025a4:	b1fd      	cbz	r5, 80025e6 <_usb_ep0in+0x96>
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80025a6:	699b      	ldr	r3, [r3, #24]

  osp->rxqueued           = false;
 80025a8:	2500      	movs	r5, #0
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 80025aa:	2203      	movs	r2, #3
 80025ac:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 80025b0:	4629      	mov	r1, r5
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 80025b2:	701d      	strb	r5, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
 80025b4:	60dd      	str	r5, [r3, #12]
  osp->rxsize             = n;
 80025b6:	605d      	str	r5, [r3, #4]
  osp->rxcnt              = 0;
 80025b8:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 80025ba:	4620      	mov	r0, r4
 80025bc:	f001 f9d8 	bl	8003970 <usb_lld_prepare_receive>
 80025c0:	2320      	movs	r3, #32
 80025c2:	f383 8811 	msr	BASEPRI, r3
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    usbPrepareReceive(usbp, 0, NULL, 0);
    osalSysLockFromISR();
    usbStartReceiveI(usbp, 0);
 80025c6:	4620      	mov	r0, r4
 80025c8:	4629      	mov	r1, r5
 80025ca:	f7ff fdd9 	bl	8002180 <usbStartReceiveI>
 80025ce:	f385 8811 	msr	BASEPRI, r5
 80025d2:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL)
 80025d4:	6f03      	ldr	r3, [r0, #112]	; 0x70
 80025d6:	b103      	cbz	r3, 80025da <_usb_ep0in+0x8a>
      usbp->ep0endcb(usbp);
 80025d8:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 80025da:	2300      	movs	r3, #0
 80025dc:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
    return;
 80025e0:	bd38      	pop	{r3, r4, r5, pc}
 80025e2:	68c3      	ldr	r3, [r0, #12]
 80025e4:	e7df      	b.n	80025a6 <_usb_ep0in+0x56>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80025e6:	695b      	ldr	r3, [r3, #20]
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 80025e8:	4629      	mov	r1, r5
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 80025ea:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 80025ec:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 80025ee:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 80025f0:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 80025f2:	f001 f9cd 	bl	8003990 <usb_lld_prepare_transmit>
 80025f6:	2320      	movs	r3, #32
 80025f8:	f383 8811 	msr	BASEPRI, r3
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) && ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0)) {
      usbPrepareTransmit(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0);
 80025fc:	4620      	mov	r0, r4
 80025fe:	4629      	mov	r1, r5
 8002600:	f7ff fdd6 	bl	80021b0 <usbStartTransmitI>
 8002604:	f385 8811 	msr	BASEPRI, r5
      osalSysUnlockFromISR();
      usbp->ep0state = USB_EP0_WAITING_TX0;
 8002608:	2302      	movs	r3, #2
 800260a:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
      return;
 800260e:	bd38      	pop	{r3, r4, r5, pc}

08002610 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8002610:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 8002612:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
 8002616:	2b03      	cmp	r3, #3
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8002618:	4604      	mov	r4, r0

  (void)ep;
  switch (usbp->ep0state) {
 800261a:	d02a      	beq.n	8002672 <_usb_ep0out+0x62>
 800261c:	2b04      	cmp	r3, #4
 800261e:	d011      	beq.n	8002644 <_usb_ep0out+0x34>
    ;
  }
  /* Error response, the state machine goes into an error state, the low
     level layer will have to reset it to USB_EP0_WAITING_SETUP after
     receiving a SETUP packet.*/
  usb_lld_stall_in(usbp, 0);
 8002620:	4620      	mov	r0, r4
 8002622:	2100      	movs	r1, #0
 8002624:	f001 fa3c 	bl	8003aa0 <usb_lld_stall_in>
  usb_lld_stall_out(usbp, 0);
 8002628:	4620      	mov	r0, r4
 800262a:	2100      	movs	r1, #0
 800262c:	f001 fa20 	bl	8003a70 <usb_lld_stall_out>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8002630:	6863      	ldr	r3, [r4, #4]
 8002632:	681b      	ldr	r3, [r3, #0]
 8002634:	b113      	cbz	r3, 800263c <_usb_ep0out+0x2c>
 8002636:	4620      	mov	r0, r4
 8002638:	2105      	movs	r1, #5
 800263a:	4798      	blx	r3
  usbp->ep0state = USB_EP0_ERROR;
 800263c:	2306      	movs	r3, #6
 800263e:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
 8002642:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8002644:	68c3      	ldr	r3, [r0, #12]
 8002646:	695b      	ldr	r3, [r3, #20]

  isp->txqueued           = false;
 8002648:	2500      	movs	r5, #0

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 800264a:	2205      	movs	r2, #5
 800264c:	f880 2064 	strb.w	r2, [r0, #100]	; 0x64
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8002650:	4629      	mov	r1, r5
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8002652:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 8002654:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 8002656:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 8002658:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800265a:	f001 f999 	bl	8003990 <usb_lld_prepare_transmit>
 800265e:	2320      	movs	r3, #32
 8002660:	f383 8811 	msr	BASEPRI, r3
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    usbPrepareTransmit(usbp, 0, NULL, 0);
    osalSysLockFromISR();
    usbStartTransmitI(usbp, 0);
 8002664:	4620      	mov	r0, r4
 8002666:	4629      	mov	r1, r5
 8002668:	f7ff fda2 	bl	80021b0 <usbStartTransmitI>
 800266c:	f385 8811 	msr	BASEPRI, r5
 8002670:	bd38      	pop	{r3, r4, r5, pc}
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeI(usbp, 0) != 0)
 8002672:	68c3      	ldr	r3, [r0, #12]
 8002674:	699b      	ldr	r3, [r3, #24]
 8002676:	689b      	ldr	r3, [r3, #8]
 8002678:	2b00      	cmp	r3, #0
 800267a:	d1d1      	bne.n	8002620 <_usb_ep0out+0x10>
      break;
#endif
    if (usbp->ep0endcb != NULL)
 800267c:	6f03      	ldr	r3, [r0, #112]	; 0x70
 800267e:	b103      	cbz	r3, 8002682 <_usb_ep0out+0x72>
      usbp->ep0endcb(usbp);
 8002680:	4798      	blx	r3
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8002682:	2300      	movs	r3, #0
 8002684:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
    return;
 8002688:	bd38      	pop	{r3, r4, r5, pc}
 800268a:	bf00      	nop
 800268c:	f3af 8000 	nop.w

08002690 <nvicEnableVector>:
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 8002690:	0943      	lsrs	r3, r0, #5
 8002692:	009b      	lsls	r3, r3, #2
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8002694:	b410      	push	{r4}
 8002696:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 800269a:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 800269e:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 80026a2:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 80026a6:	0109      	lsls	r1, r1, #4
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 80026a8:	f000 001f 	and.w	r0, r0, #31
 80026ac:	2201      	movs	r2, #1
 80026ae:	4082      	lsls	r2, r0
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

  NVIC->IP[n]        = NVIC_PRIORITY_MASK(prio);
 80026b0:	b2c9      	uxtb	r1, r1
 80026b2:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 80026b6:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5] = 1 << (n & 0x1F);
 80026ba:	601a      	str	r2, [r3, #0]
}
 80026bc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80026c0:	4770      	bx	lr
 80026c2:	bf00      	nop
 80026c4:	f3af 8000 	nop.w
 80026c8:	f3af 8000 	nop.w
 80026cc:	f3af 8000 	nop.w

080026d0 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector6C) {
 80026d0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 80026d2:	4b07      	ldr	r3, [pc, #28]	; (80026f0 <Vector6C+0x20>)
  DMA1->IFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
 80026d4:	4a07      	ldr	r2, [pc, #28]	; (80026f4 <Vector6C+0x24>)
OSAL_IRQ_HANDLER(Vector6C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 80026d6:	6819      	ldr	r1, [r3, #0]
 80026d8:	f001 010f 	and.w	r1, r1, #15
  DMA1->IFCR = flags << 0;
 80026dc:	6059      	str	r1, [r3, #4]
  if (dma_isr_redir[0].dma_func)
 80026de:	6813      	ldr	r3, [r2, #0]
 80026e0:	b10b      	cbz	r3, 80026e6 <Vector6C+0x16>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 80026e2:	6850      	ldr	r0, [r2, #4]
 80026e4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80026e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80026ea:	f7fe bc09 	b.w	8000f00 <_port_irq_epilogue>
 80026ee:	bf00      	nop
 80026f0:	40020000 	.word	0x40020000
 80026f4:	200010f0 	.word	0x200010f0
 80026f8:	f3af 8000 	nop.w
 80026fc:	f3af 8000 	nop.w

08002700 <Vector70>:
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8002700:	4b07      	ldr	r3, [pc, #28]	; (8002720 <Vector70+0x20>)
  DMA1->IFCR = flags << 4;
  if (dma_isr_redir[1].dma_func)
 8002702:	4808      	ldr	r0, [pc, #32]	; (8002724 <Vector70+0x24>)
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8002704:	6819      	ldr	r1, [r3, #0]
  DMA1->IFCR = flags << 4;
  if (dma_isr_redir[1].dma_func)
 8002706:	6882      	ldr	r2, [r0, #8]
OSAL_IRQ_HANDLER(Vector70) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8002708:	f3c1 1103 	ubfx	r1, r1, #4, #4
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector70) {
 800270c:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 4;
 800270e:	010c      	lsls	r4, r1, #4
 8002710:	605c      	str	r4, [r3, #4]
  if (dma_isr_redir[1].dma_func)
 8002712:	b10a      	cbz	r2, 8002718 <Vector70+0x18>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8002714:	68c0      	ldr	r0, [r0, #12]
 8002716:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8002718:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 4;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800271c:	f7fe bbf0 	b.w	8000f00 <_port_irq_epilogue>
 8002720:	40020000 	.word	0x40020000
 8002724:	200010f0 	.word	0x200010f0
 8002728:	f3af 8000 	nop.w
 800272c:	f3af 8000 	nop.w

08002730 <Vector74>:
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8002730:	4b07      	ldr	r3, [pc, #28]	; (8002750 <Vector74+0x20>)
  DMA1->IFCR = flags << 8;
  if (dma_isr_redir[2].dma_func)
 8002732:	4808      	ldr	r0, [pc, #32]	; (8002754 <Vector74+0x24>)
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8002734:	6819      	ldr	r1, [r3, #0]
  DMA1->IFCR = flags << 8;
  if (dma_isr_redir[2].dma_func)
 8002736:	6902      	ldr	r2, [r0, #16]
OSAL_IRQ_HANDLER(Vector74) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8002738:	f3c1 2103 	ubfx	r1, r1, #8, #4
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector74) {
 800273c:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 8;
 800273e:	020c      	lsls	r4, r1, #8
 8002740:	605c      	str	r4, [r3, #4]
  if (dma_isr_redir[2].dma_func)
 8002742:	b10a      	cbz	r2, 8002748 <Vector74+0x18>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8002744:	6940      	ldr	r0, [r0, #20]
 8002746:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8002748:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 8;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800274c:	f7fe bbd8 	b.w	8000f00 <_port_irq_epilogue>
 8002750:	40020000 	.word	0x40020000
 8002754:	200010f0 	.word	0x200010f0
 8002758:	f3af 8000 	nop.w
 800275c:	f3af 8000 	nop.w

08002760 <Vector78>:
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8002760:	4b07      	ldr	r3, [pc, #28]	; (8002780 <Vector78+0x20>)
  DMA1->IFCR = flags << 12;
  if (dma_isr_redir[3].dma_func)
 8002762:	4808      	ldr	r0, [pc, #32]	; (8002784 <Vector78+0x24>)
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8002764:	6819      	ldr	r1, [r3, #0]
  DMA1->IFCR = flags << 12;
  if (dma_isr_redir[3].dma_func)
 8002766:	6982      	ldr	r2, [r0, #24]
OSAL_IRQ_HANDLER(Vector78) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8002768:	f3c1 3103 	ubfx	r1, r1, #12, #4
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector78) {
 800276c:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 12;
 800276e:	030c      	lsls	r4, r1, #12
 8002770:	605c      	str	r4, [r3, #4]
  if (dma_isr_redir[3].dma_func)
 8002772:	b10a      	cbz	r2, 8002778 <Vector78+0x18>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8002774:	69c0      	ldr	r0, [r0, #28]
 8002776:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8002778:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 12;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800277c:	f7fe bbc0 	b.w	8000f00 <_port_irq_epilogue>
 8002780:	40020000 	.word	0x40020000
 8002784:	200010f0 	.word	0x200010f0
 8002788:	f3af 8000 	nop.w
 800278c:	f3af 8000 	nop.w

08002790 <Vector7C>:
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8002790:	4b07      	ldr	r3, [pc, #28]	; (80027b0 <Vector7C+0x20>)
  DMA1->IFCR = flags << 16;
  if (dma_isr_redir[4].dma_func)
 8002792:	4808      	ldr	r0, [pc, #32]	; (80027b4 <Vector7C+0x24>)
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8002794:	6819      	ldr	r1, [r3, #0]
  DMA1->IFCR = flags << 16;
  if (dma_isr_redir[4].dma_func)
 8002796:	6a02      	ldr	r2, [r0, #32]
OSAL_IRQ_HANDLER(Vector7C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8002798:	f3c1 4103 	ubfx	r1, r1, #16, #4
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector7C) {
 800279c:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 16;
 800279e:	040c      	lsls	r4, r1, #16
 80027a0:	605c      	str	r4, [r3, #4]
  if (dma_isr_redir[4].dma_func)
 80027a2:	b10a      	cbz	r2, 80027a8 <Vector7C+0x18>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 80027a4:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80027a6:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80027a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 16;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80027ac:	f7fe bba8 	b.w	8000f00 <_port_irq_epilogue>
 80027b0:	40020000 	.word	0x40020000
 80027b4:	200010f0 	.word	0x200010f0
 80027b8:	f3af 8000 	nop.w
 80027bc:	f3af 8000 	nop.w

080027c0 <Vector80>:
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 80027c0:	4b07      	ldr	r3, [pc, #28]	; (80027e0 <Vector80+0x20>)
  DMA1->IFCR = flags << 20;
  if (dma_isr_redir[5].dma_func)
 80027c2:	4808      	ldr	r0, [pc, #32]	; (80027e4 <Vector80+0x24>)
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 80027c4:	6819      	ldr	r1, [r3, #0]
  DMA1->IFCR = flags << 20;
  if (dma_isr_redir[5].dma_func)
 80027c6:	6a82      	ldr	r2, [r0, #40]	; 0x28
OSAL_IRQ_HANDLER(Vector80) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 80027c8:	f3c1 5103 	ubfx	r1, r1, #20, #4
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector80) {
 80027cc:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 20;
 80027ce:	050c      	lsls	r4, r1, #20
 80027d0:	605c      	str	r4, [r3, #4]
  if (dma_isr_redir[5].dma_func)
 80027d2:	b10a      	cbz	r2, 80027d8 <Vector80+0x18>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 80027d4:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80027d6:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80027d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 20;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80027dc:	f7fe bb90 	b.w	8000f00 <_port_irq_epilogue>
 80027e0:	40020000 	.word	0x40020000
 80027e4:	200010f0 	.word	0x200010f0
 80027e8:	f3af 8000 	nop.w
 80027ec:	f3af 8000 	nop.w

080027f0 <Vector84>:
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 80027f0:	4b07      	ldr	r3, [pc, #28]	; (8002810 <Vector84+0x20>)
  DMA1->IFCR = flags << 24;
  if (dma_isr_redir[6].dma_func)
 80027f2:	4808      	ldr	r0, [pc, #32]	; (8002814 <Vector84+0x24>)
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 80027f4:	6819      	ldr	r1, [r3, #0]
  DMA1->IFCR = flags << 24;
  if (dma_isr_redir[6].dma_func)
 80027f6:	6b02      	ldr	r2, [r0, #48]	; 0x30
OSAL_IRQ_HANDLER(Vector84) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 80027f8:	f3c1 6103 	ubfx	r1, r1, #24, #4
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector84) {
 80027fc:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 24;
 80027fe:	060c      	lsls	r4, r1, #24
 8002800:	605c      	str	r4, [r3, #4]
  if (dma_isr_redir[6].dma_func)
 8002802:	b10a      	cbz	r2, 8002808 <Vector84+0x18>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8002804:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8002806:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8002808:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 24;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800280c:	f7fe bb78 	b.w	8000f00 <_port_irq_epilogue>
 8002810:	40020000 	.word	0x40020000
 8002814:	200010f0 	.word	0x200010f0
 8002818:	f3af 8000 	nop.w
 800281c:	f3af 8000 	nop.w

08002820 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector120) {
 8002820:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 0) & STM32_DMA_ISR_MASK;
 8002822:	4b07      	ldr	r3, [pc, #28]	; (8002840 <Vector120+0x20>)
  DMA2->IFCR = flags << 0;
  if (dma_isr_redir[7].dma_func)
 8002824:	4807      	ldr	r0, [pc, #28]	; (8002844 <Vector120+0x24>)
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 0) & STM32_DMA_ISR_MASK;
 8002826:	6819      	ldr	r1, [r3, #0]
  DMA2->IFCR = flags << 0;
  if (dma_isr_redir[7].dma_func)
 8002828:	6b82      	ldr	r2, [r0, #56]	; 0x38
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 0) & STM32_DMA_ISR_MASK;
 800282a:	f001 010f 	and.w	r1, r1, #15
  DMA2->IFCR = flags << 0;
 800282e:	6059      	str	r1, [r3, #4]
  if (dma_isr_redir[7].dma_func)
 8002830:	b10a      	cbz	r2, 8002836 <Vector120+0x16>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 8002832:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8002834:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8002836:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->ISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 0;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800283a:	f7fe bb61 	b.w	8000f00 <_port_irq_epilogue>
 800283e:	bf00      	nop
 8002840:	40020400 	.word	0x40020400
 8002844:	200010f0 	.word	0x200010f0
 8002848:	f3af 8000 	nop.w
 800284c:	f3af 8000 	nop.w

08002850 <Vector124>:
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 4) & STM32_DMA_ISR_MASK;
 8002850:	4b07      	ldr	r3, [pc, #28]	; (8002870 <Vector124+0x20>)
  DMA2->IFCR = flags << 4;
  if (dma_isr_redir[8].dma_func)
 8002852:	4808      	ldr	r0, [pc, #32]	; (8002874 <Vector124+0x24>)
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 4) & STM32_DMA_ISR_MASK;
 8002854:	6819      	ldr	r1, [r3, #0]
  DMA2->IFCR = flags << 4;
  if (dma_isr_redir[8].dma_func)
 8002856:	6c02      	ldr	r2, [r0, #64]	; 0x40
OSAL_IRQ_HANDLER(Vector124) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 4) & STM32_DMA_ISR_MASK;
 8002858:	f3c1 1103 	ubfx	r1, r1, #4, #4
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector124) {
 800285c:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 4) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 4;
 800285e:	010c      	lsls	r4, r1, #4
 8002860:	605c      	str	r4, [r3, #4]
  if (dma_isr_redir[8].dma_func)
 8002862:	b10a      	cbz	r2, 8002868 <Vector124+0x18>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 8002864:	6c40      	ldr	r0, [r0, #68]	; 0x44
 8002866:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8002868:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->ISR >> 4) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 4;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800286c:	f7fe bb48 	b.w	8000f00 <_port_irq_epilogue>
 8002870:	40020400 	.word	0x40020400
 8002874:	200010f0 	.word	0x200010f0
 8002878:	f3af 8000 	nop.w
 800287c:	f3af 8000 	nop.w

08002880 <Vector128>:
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 8) & STM32_DMA_ISR_MASK;
 8002880:	4b07      	ldr	r3, [pc, #28]	; (80028a0 <Vector128+0x20>)
  DMA2->IFCR = flags << 8;
  if (dma_isr_redir[9].dma_func)
 8002882:	4808      	ldr	r0, [pc, #32]	; (80028a4 <Vector128+0x24>)
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 8) & STM32_DMA_ISR_MASK;
 8002884:	6819      	ldr	r1, [r3, #0]
  DMA2->IFCR = flags << 8;
  if (dma_isr_redir[9].dma_func)
 8002886:	6c82      	ldr	r2, [r0, #72]	; 0x48
OSAL_IRQ_HANDLER(Vector128) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 8) & STM32_DMA_ISR_MASK;
 8002888:	f3c1 2103 	ubfx	r1, r1, #8, #4
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector128) {
 800288c:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 8) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 8;
 800288e:	020c      	lsls	r4, r1, #8
 8002890:	605c      	str	r4, [r3, #4]
  if (dma_isr_redir[9].dma_func)
 8002892:	b10a      	cbz	r2, 8002898 <Vector128+0x18>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8002894:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8002896:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 8002898:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->ISR >> 8) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 8;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800289c:	f7fe bb30 	b.w	8000f00 <_port_irq_epilogue>
 80028a0:	40020400 	.word	0x40020400
 80028a4:	200010f0 	.word	0x200010f0
 80028a8:	f3af 8000 	nop.w
 80028ac:	f3af 8000 	nop.w

080028b0 <Vector12C>:
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 12) & STM32_DMA_ISR_MASK;
 80028b0:	4b07      	ldr	r3, [pc, #28]	; (80028d0 <Vector12C+0x20>)
  DMA2->IFCR = flags << 12;
  if (dma_isr_redir[10].dma_func)
 80028b2:	4808      	ldr	r0, [pc, #32]	; (80028d4 <Vector12C+0x24>)
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 12) & STM32_DMA_ISR_MASK;
 80028b4:	6819      	ldr	r1, [r3, #0]
  DMA2->IFCR = flags << 12;
  if (dma_isr_redir[10].dma_func)
 80028b6:	6d02      	ldr	r2, [r0, #80]	; 0x50
OSAL_IRQ_HANDLER(Vector12C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 12) & STM32_DMA_ISR_MASK;
 80028b8:	f3c1 3103 	ubfx	r1, r1, #12, #4
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector12C) {
 80028bc:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 12) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 12;
 80028be:	030c      	lsls	r4, r1, #12
 80028c0:	605c      	str	r4, [r3, #4]
  if (dma_isr_redir[10].dma_func)
 80028c2:	b10a      	cbz	r2, 80028c8 <Vector12C+0x18>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 80028c4:	6d40      	ldr	r0, [r0, #84]	; 0x54
 80028c6:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80028c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->ISR >> 12) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 12;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80028cc:	f7fe bb18 	b.w	8000f00 <_port_irq_epilogue>
 80028d0:	40020400 	.word	0x40020400
 80028d4:	200010f0 	.word	0x200010f0
 80028d8:	f3af 8000 	nop.w
 80028dc:	f3af 8000 	nop.w

080028e0 <Vector130>:
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 16) & STM32_DMA_ISR_MASK;
 80028e0:	4b07      	ldr	r3, [pc, #28]	; (8002900 <Vector130+0x20>)
  DMA2->IFCR = flags << 16;
  if (dma_isr_redir[11].dma_func)
 80028e2:	4808      	ldr	r0, [pc, #32]	; (8002904 <Vector130+0x24>)
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 16) & STM32_DMA_ISR_MASK;
 80028e4:	6819      	ldr	r1, [r3, #0]
  DMA2->IFCR = flags << 16;
  if (dma_isr_redir[11].dma_func)
 80028e6:	6d82      	ldr	r2, [r0, #88]	; 0x58
OSAL_IRQ_HANDLER(Vector130) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 16) & STM32_DMA_ISR_MASK;
 80028e8:	f3c1 4103 	ubfx	r1, r1, #16, #4
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector130) {
 80028ec:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 16;
 80028ee:	040c      	lsls	r4, r1, #16
 80028f0:	605c      	str	r4, [r3, #4]
  if (dma_isr_redir[11].dma_func)
 80028f2:	b10a      	cbz	r2, 80028f8 <Vector130+0x18>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 80028f4:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 80028f6:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
}
 80028f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->ISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 16;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80028fc:	f7fe bb00 	b.w	8000f00 <_port_irq_epilogue>
 8002900:	40020400 	.word	0x40020400
 8002904:	200010f0 	.word	0x200010f0
 8002908:	f3af 8000 	nop.w
 800290c:	f3af 8000 	nop.w

08002910 <dmaInit>:
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 8002910:	4b0c      	ldr	r3, [pc, #48]	; (8002944 <dmaInit+0x34>)
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8002912:	b430      	push	{r4, r5}
  int i;

  dma_streams_mask = 0;
 8002914:	2200      	movs	r2, #0
 8002916:	4d0c      	ldr	r5, [pc, #48]	; (8002948 <dmaInit+0x38>)
 8002918:	4c0c      	ldr	r4, [pc, #48]	; (800294c <dmaInit+0x3c>)
 800291a:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
 800291c:	4611      	mov	r1, r2
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800291e:	4613      	mov	r3, r2
    _stm32_dma_streams[i].channel->CCR = 0;
 8002920:	58a8      	ldr	r0, [r5, r2]
 8002922:	6001      	str	r1, [r0, #0]
    dma_isr_redir[i].dma_func = NULL;
 8002924:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8002928:	3301      	adds	r3, #1
 800292a:	2b0c      	cmp	r3, #12
 800292c:	f102 020c 	add.w	r2, r2, #12
 8002930:	d1f6      	bne.n	8002920 <dmaInit+0x10>
    _stm32_dma_streams[i].channel->CCR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFF;
 8002932:	4907      	ldr	r1, [pc, #28]	; (8002950 <dmaInit+0x40>)
#if STM32_HAS_DMA2
  DMA2->IFCR = 0xFFFFFFFF;
 8002934:	4a07      	ldr	r2, [pc, #28]	; (8002954 <dmaInit+0x44>)
  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFF;
 8002936:	f04f 33ff 	mov.w	r3, #4294967295
 800293a:	604b      	str	r3, [r1, #4]
#if STM32_HAS_DMA2
  DMA2->IFCR = 0xFFFFFFFF;
#endif
}
 800293c:	bc30      	pop	{r4, r5}
    _stm32_dma_streams[i].channel->CCR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFF;
#if STM32_HAS_DMA2
  DMA2->IFCR = 0xFFFFFFFF;
 800293e:	6053      	str	r3, [r2, #4]
#endif
}
 8002940:	4770      	bx	lr
 8002942:	bf00      	nop
 8002944:	20001150 	.word	0x20001150
 8002948:	08006930 	.word	0x08006930
 800294c:	200010f0 	.word	0x200010f0
 8002950:	40020000 	.word	0x40020000
 8002954:	40020400 	.word	0x40020400
 8002958:	f3af 8000 	nop.w
 800295c:	f3af 8000 	nop.w

08002960 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8002960:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
 8002962:	4f1c      	ldr	r7, [pc, #112]	; (80029d4 <dmaStreamAllocate+0x74>)
 8002964:	7a46      	ldrb	r6, [r0, #9]
 8002966:	683d      	ldr	r5, [r7, #0]
 8002968:	2401      	movs	r4, #1
 800296a:	fa04 fe06 	lsl.w	lr, r4, r6
 800296e:	ea1e 0f05 	tst.w	lr, r5
 8002972:	d12a      	bne.n	80029ca <dmaStreamAllocate+0x6a>
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8002974:	4c18      	ldr	r4, [pc, #96]	; (80029d8 <dmaStreamAllocate+0x78>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8002976:	eb04 0cc6 	add.w	ip, r4, r6, lsl #3
  dma_streams_mask |= (1 << dmastp->selfindex);
 800297a:	ea4e 0505 	orr.w	r5, lr, r5
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800297e:	f8cc 3004 	str.w	r3, [ip, #4]
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 8002982:	066b      	lsls	r3, r5, #25
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 8002984:	603d      	str	r5, [r7, #0]
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8002986:	f844 2036 	str.w	r2, [r4, r6, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 800298a:	d004      	beq.n	8002996 <dmaStreamAllocate+0x36>
    rccEnableDMA1(FALSE);
 800298c:	4c13      	ldr	r4, [pc, #76]	; (80029dc <dmaStreamAllocate+0x7c>)
 800298e:	6963      	ldr	r3, [r4, #20]
 8002990:	f043 0301 	orr.w	r3, r3, #1
 8002994:	6163      	str	r3, [r4, #20]
#if STM32_HAS_DMA2
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
 8002996:	f415 6f78 	tst.w	r5, #3968	; 0xf80
 800299a:	d004      	beq.n	80029a6 <dmaStreamAllocate+0x46>
    rccEnableDMA2(FALSE);
 800299c:	4c0f      	ldr	r4, [pc, #60]	; (80029dc <dmaStreamAllocate+0x7c>)
 800299e:	6963      	ldr	r3, [r4, #20]
 80029a0:	f043 0302 	orr.w	r3, r3, #2
 80029a4:	6163      	str	r3, [r4, #20]
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80029a6:	e890 0048 	ldmia.w	r0, {r3, r6}
 80029aa:	681c      	ldr	r4, [r3, #0]
 80029ac:	f024 040f 	bic.w	r4, r4, #15
 80029b0:	601c      	str	r4, [r3, #0]
 80029b2:	7a04      	ldrb	r4, [r0, #8]
 80029b4:	250f      	movs	r5, #15
 80029b6:	40a5      	lsls	r5, r4
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80029b8:	2400      	movs	r4, #0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
    rccEnableDMA2(FALSE);
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 80029ba:	6035      	str	r5, [r6, #0]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80029bc:	601c      	str	r4, [r3, #0]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
 80029be:	b132      	cbz	r2, 80029ce <dmaStreamAllocate+0x6e>
    nvicEnableVector(dmastp->vector, priority);
 80029c0:	7a80      	ldrb	r0, [r0, #10]
 80029c2:	f7ff fe65 	bl	8002690 <nvicEnableVector>

  return FALSE;
 80029c6:	4620      	mov	r0, r4
 80029c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
    return TRUE;
 80029ca:	4620      	mov	r0, r4
 80029cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
    nvicEnableVector(dmastp->vector, priority);

  return FALSE;
 80029ce:	4610      	mov	r0, r2
}
 80029d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80029d2:	bf00      	nop
 80029d4:	20001150 	.word	0x20001150
 80029d8:	200010f0 	.word	0x200010f0
 80029dc:	40021000 	.word	0x40021000

080029e0 <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 80029e0:	4b1c      	ldr	r3, [pc, #112]	; (8002a54 <hal_lld_init+0x74>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80029e2:	481d      	ldr	r0, [pc, #116]	; (8002a58 <hal_lld_init+0x78>)
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 80029e4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80029e6:	f04f 31ff 	mov.w	r1, #4294967295
 80029ea:	2200      	movs	r2, #0
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80029ec:	b510      	push	{r4, lr}

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 80029ee:	6299      	str	r1, [r3, #40]	; 0x28
 80029f0:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 80029f2:	691c      	ldr	r4, [r3, #16]
 80029f4:	6119      	str	r1, [r3, #16]
 80029f6:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 80029f8:	68dc      	ldr	r4, [r3, #12]
 80029fa:	60d9      	str	r1, [r3, #12]
 80029fc:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80029fe:	69d9      	ldr	r1, [r3, #28]
 8002a00:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8002a04:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002a06:	6801      	ldr	r1, [r0, #0]
 8002a08:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8002a0c:	6001      	str	r1, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8002a0e:	6a19      	ldr	r1, [r3, #32]
 8002a10:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8002a14:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8002a18:	d003      	beq.n	8002a22 <hal_lld_init+0x42>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8002a1a:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8002a1e:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 8002a20:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8002a22:	4b0c      	ldr	r3, [pc, #48]	; (8002a54 <hal_lld_init+0x74>)
 8002a24:	6a1a      	ldr	r2, [r3, #32]
 8002a26:	0412      	lsls	r2, r2, #16
 8002a28:	d407      	bmi.n	8002a3a <hal_lld_init+0x5a>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8002a2a:	6a1a      	ldr	r2, [r3, #32]
 8002a2c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002a30:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8002a32:	6a1a      	ldr	r2, [r3, #32]
 8002a34:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8002a38:	621a      	str	r2, [r3, #32]

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8002a3a:	f7ff ff69 	bl	8002910 <dmaInit>
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8002a3e:	4905      	ldr	r1, [pc, #20]	; (8002a54 <hal_lld_init+0x74>)

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8002a40:	4a06      	ldr	r2, [pc, #24]	; (8002a5c <hal_lld_init+0x7c>)
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8002a42:	698b      	ldr	r3, [r1, #24]
 8002a44:	f043 0301 	orr.w	r3, r3, #1
 8002a48:	618b      	str	r3, [r1, #24]

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8002a4a:	6813      	ldr	r3, [r2, #0]
 8002a4c:	f043 0320 	orr.w	r3, r3, #32
 8002a50:	6013      	str	r3, [r2, #0]
 8002a52:	bd10      	pop	{r4, pc}
 8002a54:	40021000 	.word	0x40021000
 8002a58:	40007000 	.word	0x40007000
 8002a5c:	40010000 	.word	0x40010000

08002a60 <stm32_clock_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8002a60:	4924      	ldr	r1, [pc, #144]	; (8002af4 <stm32_clock_init+0x94>)
 8002a62:	680b      	ldr	r3, [r1, #0]
 8002a64:	f043 0301 	orr.w	r3, r3, #1
 8002a68:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8002a6a:	680a      	ldr	r2, [r1, #0]
 8002a6c:	4b21      	ldr	r3, [pc, #132]	; (8002af4 <stm32_clock_init+0x94>)
 8002a6e:	0790      	lsls	r0, r2, #30
 8002a70:	d5fb      	bpl.n	8002a6a <stm32_clock_init+0xa>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8002a72:	685a      	ldr	r2, [r3, #4]
 8002a74:	f022 0203 	bic.w	r2, r2, #3
 8002a78:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8002a7a:	685a      	ldr	r2, [r3, #4]
 8002a7c:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8002a7e:	4619      	mov	r1, r3
 8002a80:	684b      	ldr	r3, [r1, #4]
 8002a82:	4a1c      	ldr	r2, [pc, #112]	; (8002af4 <stm32_clock_init+0x94>)
 8002a84:	f013 030c 	ands.w	r3, r3, #12
 8002a88:	d1fa      	bne.n	8002a80 <stm32_clock_init+0x20>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8002a8a:	6811      	ldr	r1, [r2, #0]
 8002a8c:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 8002a90:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8002a92:	6053      	str	r3, [r2, #4]

#if STM32_HSE_ENABLED
  /* HSE activation.*/
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 8002a94:	6813      	ldr	r3, [r2, #0]
 8002a96:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
 8002a9a:	6013      	str	r3, [r2, #0]
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 8002a9c:	6811      	ldr	r1, [r2, #0]
 8002a9e:	4b15      	ldr	r3, [pc, #84]	; (8002af4 <stm32_clock_init+0x94>)
 8002aa0:	0389      	lsls	r1, r1, #14
 8002aa2:	d5fb      	bpl.n	8002a9c <stm32_clock_init+0x3c>
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8002aa4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002aa6:	f042 0201 	orr.w	r2, r2, #1
 8002aaa:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8002aac:	461a      	mov	r2, r3
 8002aae:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8002ab0:	4b10      	ldr	r3, [pc, #64]	; (8002af4 <stm32_clock_init+0x94>)
 8002ab2:	0788      	lsls	r0, r1, #30
 8002ab4:	d5fb      	bpl.n	8002aae <stm32_clock_init+0x4e>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
 8002ab6:	4a10      	ldr	r2, [pc, #64]	; (8002af8 <stm32_clock_init+0x98>)
 8002ab8:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8002aba:	f44f 5104 	mov.w	r1, #8448	; 0x2100
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8002abe:	2230      	movs	r2, #48	; 0x30

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8002ac0:	62d9      	str	r1, [r3, #44]	; 0x2c
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8002ac2:	631a      	str	r2, [r3, #48]	; 0x30
               STM32_USART2SW  | STM32_I2C2SW    | STM32_I2C1SW   |
               STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8002ac4:	681a      	ldr	r2, [r3, #0]
 8002ac6:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8002aca:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8002acc:	6819      	ldr	r1, [r3, #0]
 8002ace:	4a09      	ldr	r2, [pc, #36]	; (8002af4 <stm32_clock_init+0x94>)
 8002ad0:	0189      	lsls	r1, r1, #6
 8002ad2:	d5fb      	bpl.n	8002acc <stm32_clock_init+0x6c>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8002ad4:	4b09      	ldr	r3, [pc, #36]	; (8002afc <stm32_clock_init+0x9c>)
 8002ad6:	2112      	movs	r1, #18
 8002ad8:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8002ada:	6853      	ldr	r3, [r2, #4]
 8002adc:	f043 0302 	orr.w	r3, r3, #2
 8002ae0:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8002ae2:	6853      	ldr	r3, [r2, #4]
 8002ae4:	4903      	ldr	r1, [pc, #12]	; (8002af4 <stm32_clock_init+0x94>)
 8002ae6:	f003 030c 	and.w	r3, r3, #12
 8002aea:	2b08      	cmp	r3, #8
 8002aec:	d1f9      	bne.n	8002ae2 <stm32_clock_init+0x82>
    ;                                       /* Waits selection complete.    */
#endif

  /* After PLL activation because the special requirements for TIM1 and
     TIM8 bits.*/
  RCC->CFGR3 |= STM32_TIM8SW | STM32_TIM1SW;
 8002aee:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8002af0:	630b      	str	r3, [r1, #48]	; 0x30
 8002af2:	4770      	bx	lr
 8002af4:	40021000 	.word	0x40021000
 8002af8:	001d2400 	.word	0x001d2400
 8002afc:	40022000 	.word	0x40022000

08002b00 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 8002b00:	b538      	push	{r3, r4, r5, lr}

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 8002b02:	4c0a      	ldr	r4, [pc, #40]	; (8002b2c <adc_lld_init+0x2c>)
 8002b04:	4620      	mov	r0, r4
 8002b06:	f7ff f9e3 	bl	8001ed0 <adcObjectInit>
  ADCD1.adcc = ADC1_2_COMMON;
 8002b0a:	4b09      	ldr	r3, [pc, #36]	; (8002b30 <adc_lld_init+0x30>)
 8002b0c:	62a3      	str	r3, [r4, #40]	; 0x28
  ADCD1.adcm = ADC1;
 8002b0e:	f04f 45a0 	mov.w	r5, #1342177280	; 0x50000000
#if STM32_ADC_DUAL_MODE
  ADCD1.adcs = ADC2;
#endif
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
  ADCD1.dmamode = ADC_DMA_SIZE |
 8002b12:	f242 538a 	movw	r3, #9610	; 0x258a
  ADCD1.adcc = ADC1_2_COMMON;
  ADCD1.adcm = ADC1;
#if STM32_ADC_DUAL_MODE
  ADCD1.adcs = ADC2;
#endif
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
 8002b16:	4a07      	ldr	r2, [pc, #28]	; (8002b34 <adc_lld_init+0x34>)

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adcc = ADC1_2_COMMON;
  ADCD1.adcm = ADC1;
 8002b18:	62e5      	str	r5, [r4, #44]	; 0x2c
#if STM32_ADC_DUAL_MODE
  ADCD1.adcs = ADC2;
#endif
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
 8002b1a:	6322      	str	r2, [r4, #48]	; 0x30
  ADCD1.dmamode = ADC_DMA_SIZE |
 8002b1c:	6363      	str	r3, [r4, #52]	; 0x34
                  STM32_DMA_CR_PL(STM32_ADC_ADC12_DMA_PRIORITY) |
                  STM32_DMA_CR_DIR_P2M |
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
  nvicEnableVector(ADC1_2_IRQn, STM32_ADC_ADC12_IRQ_PRIORITY);
 8002b1e:	2012      	movs	r0, #18
 8002b20:	2105      	movs	r1, #5
  nvicEnableVector(ADC3_IRQn, STM32_ADC_ADC34_IRQ_PRIORITY);
#if STM32_ADC_DUAL_MODE
  nvicEnableVector(ADC4_IRQn, STM32_ADC_ADC34_IRQ_PRIORITY);
#endif
#endif /* STM32_ADC_USE_ADC3 */
}
 8002b22:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  ADCD1.dmamode = ADC_DMA_SIZE |
                  STM32_DMA_CR_PL(STM32_ADC_ADC12_DMA_PRIORITY) |
                  STM32_DMA_CR_DIR_P2M |
                  STM32_DMA_CR_MINC        | STM32_DMA_CR_TCIE        |
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;
  nvicEnableVector(ADC1_2_IRQn, STM32_ADC_ADC12_IRQ_PRIORITY);
 8002b26:	f7ff bdb3 	b.w	8002690 <nvicEnableVector>
 8002b2a:	bf00      	nop
 8002b2c:	20001154 	.word	0x20001154
 8002b30:	50000300 	.word	0x50000300
 8002b34:	08006930 	.word	0x08006930
 8002b38:	f3af 8000 	nop.w
 8002b3c:	f3af 8000 	nop.w

08002b40 <adc_lld_start>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {
 8002b40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8002b42:	7803      	ldrb	r3, [r0, #0]
 8002b44:	2b01      	cmp	r3, #1
 8002b46:	d000      	beq.n	8002b4a <adc_lld_start+0xa>
 8002b48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
 8002b4a:	4b19      	ldr	r3, [pc, #100]	; (8002bb0 <adc_lld_start+0x70>)
 8002b4c:	4298      	cmp	r0, r3
 8002b4e:	4604      	mov	r4, r0
 8002b50:	d022      	beq.n	8002b98 <adc_lld_start+0x58>

    /* Setting DMA peripheral-side pointer.*/
#if STM32_ADC_DUAL_MODE
      dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcc->CDR);
#else
      dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 8002b52:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002b54:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002b56:	6810      	ldr	r0, [r2, #0]
#endif

    /* Clock source setting.*/
    adcp->adcc->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_DMA_MDMA;
 8002b58:	6aa5      	ldr	r5, [r4, #40]	; 0x28

    /* Setting DMA peripheral-side pointer.*/
#if STM32_ADC_DUAL_MODE
      dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcc->CDR);
#else
      dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 8002b5a:	f103 0740 	add.w	r7, r3, #64	; 0x40
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_vreg_on(ADCDriver *adcp) {

  adcp->adcm->CR = 0;   /* RM 12.4.3.*/
  adcp->adcm->CR = ADC_CR_ADVREGEN_0;
 8002b5e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_vreg_on(ADCDriver *adcp) {

  adcp->adcm->CR = 0;   /* RM 12.4.3.*/
 8002b62:	2100      	movs	r1, #0
#else
      dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
#endif

    /* Clock source setting.*/
    adcp->adcc->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_DMA_MDMA;
 8002b64:	f44f 3680 	mov.w	r6, #65536	; 0x10000

    /* Setting DMA peripheral-side pointer.*/
#if STM32_ADC_DUAL_MODE
      dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcc->CDR);
#else
      dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
 8002b68:	6087      	str	r7, [r0, #8]
#endif

    /* Clock source setting.*/
    adcp->adcc->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_DMA_MDMA;
 8002b6a:	60ae      	str	r6, [r5, #8]
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 8002b6c:	f44f 7034 	mov.w	r0, #720	; 0x2d0
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_vreg_on(ADCDriver *adcp) {

  adcp->adcm->CR = 0;   /* RM 12.4.3.*/
 8002b70:	6099      	str	r1, [r3, #8]
  adcp->adcm->CR = ADC_CR_ADVREGEN_0;
 8002b72:	609a      	str	r2, [r3, #8]
 8002b74:	f7fe fab4 	bl	80010e0 <chSysPolledDelayX>
 8002b78:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_calibrate(ADCDriver *adcp) {

  osalDbgAssert(adcp->adcm->CR == ADC_CR_ADVREGEN_0, "invalid register state");
  adcp->adcm->CR |= ADC_CR_ADCAL;
 8002b7a:	689a      	ldr	r2, [r3, #8]
 8002b7c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8002b80:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0)
 8002b82:	689a      	ldr	r2, [r3, #8]
 8002b84:	2a00      	cmp	r2, #0
 8002b86:	dbfc      	blt.n	8002b82 <adc_lld_start+0x42>
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_analog_on(ADCDriver *adcp) {

  adcp->adcm->CR |= ADC_CR_ADEN;
 8002b88:	689a      	ldr	r2, [r3, #8]
 8002b8a:	f042 0201 	orr.w	r2, r2, #1
 8002b8e:	609a      	str	r2, [r3, #8]
  while ((adcp->adcm->ISR & ADC_ISR_ADRD) == 0)
 8002b90:	681a      	ldr	r2, [r3, #0]
 8002b92:	07d2      	lsls	r2, r2, #31
 8002b94:	d5fc      	bpl.n	8002b90 <adc_lld_start+0x50>
 8002b96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
      bool b;
      b = dmaStreamAllocate(adcp->dmastp,
 8002b98:	4a06      	ldr	r2, [pc, #24]	; (8002bb4 <adc_lld_start+0x74>)
 8002b9a:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8002b9c:	4623      	mov	r3, r4
 8002b9e:	2105      	movs	r1, #5
 8002ba0:	f7ff fede 	bl	8002960 <dmaStreamAllocate>
                            STM32_ADC_ADC12_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_dma_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableADC12(FALSE);
 8002ba4:	4a04      	ldr	r2, [pc, #16]	; (8002bb8 <adc_lld_start+0x78>)
 8002ba6:	6953      	ldr	r3, [r2, #20]
 8002ba8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002bac:	6153      	str	r3, [r2, #20]
 8002bae:	e7d0      	b.n	8002b52 <adc_lld_start+0x12>
 8002bb0:	20001154 	.word	0x20001154
 8002bb4:	08002cb1 	.word	0x08002cb1
 8002bb8:	40021000 	.word	0x40021000
 8002bbc:	f3af 8000 	nop.w

08002bc0 <adc_lld_start_conversion>:
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 8002bc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  osalDbgAssert(!STM32_ADC_DUAL_MODE || ((grpp->num_channels & 1) == 0),
                "odd number of channels in dual mode");

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
  ccr     = grpp->ccr | (adcp->adcc->CCR & (ADC_CCR_CKMODE_MASK |
 8002bc4:	f8d0 e028 	ldr.w	lr, [r0, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
  uint32_t dmamode, ccr, cfgr;
  const ADCConversionGroup *grpp = adcp->grpp;
 8002bc8:	6902      	ldr	r2, [r0, #16]
  osalDbgAssert(!STM32_ADC_DUAL_MODE || ((grpp->num_channels & 1) == 0),
                "odd number of channels in dual mode");

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
  ccr     = grpp->ccr | (adcp->adcc->CCR & (ADC_CCR_CKMODE_MASK |
 8002bca:	f8de 3008 	ldr.w	r3, [lr, #8]
 8002bce:	6956      	ldr	r6, [r2, #20]
                                            ADC_CCR_MDMA_MASK));
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
  if (grpp->circular) {
 8002bd0:	7811      	ldrb	r1, [r2, #0]

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
  ccr     = grpp->ccr | (adcp->adcc->CCR & (ADC_CCR_CKMODE_MASK |
                                            ADC_CCR_MDMA_MASK));
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
 8002bd2:	68d5      	ldr	r5, [r2, #12]

  osalDbgAssert(!STM32_ADC_DUAL_MODE || ((grpp->num_channels & 1) == 0),
                "odd number of channels in dual mode");

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
 8002bd4:	6b47      	ldr	r7, [r0, #52]	; 0x34
  ccr     = grpp->ccr | (adcp->adcc->CCR & (ADC_CCR_CKMODE_MASK |
 8002bd6:	f403 3370 	and.w	r3, r3, #245760	; 0x3c000
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 8002bda:	b083      	sub	sp, #12
  osalDbgAssert(!STM32_ADC_DUAL_MODE || ((grpp->num_channels & 1) == 0),
                "odd number of channels in dual mode");

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
  ccr     = grpp->ccr | (adcp->adcc->CCR & (ADC_CCR_CKMODE_MASK |
 8002bdc:	431e      	orrs	r6, r3
                                            ADC_CCR_MDMA_MASK));
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
  if (grpp->circular) {
 8002bde:	2900      	cmp	r1, #0
 8002be0:	d040      	beq.n	8002c64 <adc_lld_start_conversion+0xa4>
#if STM32_ADC_DUAL_MODE
    ccr  |= ADC_CCR_DMACFG_CIRCULAR;
#else
    cfgr |= ADC_CFGR_DMACFG_CIRCULAR;
#endif
    if (adcp->depth > 1) {
 8002be2:	68c3      	ldr	r3, [r0, #12]
  if (grpp->circular) {
    dmamode |= STM32_DMA_CR_CIRC;
#if STM32_ADC_DUAL_MODE
    ccr  |= ADC_CCR_DMACFG_CIRCULAR;
#else
    cfgr |= ADC_CFGR_DMACFG_CIRCULAR;
 8002be4:	f045 0103 	orr.w	r1, r5, #3
#endif
    if (adcp->depth > 1) {
 8002be8:	2b01      	cmp	r3, #1
  if (grpp->circular) {
    dmamode |= STM32_DMA_CR_CIRC;
#if STM32_ADC_DUAL_MODE
    ccr  |= ADC_CCR_DMACFG_CIRCULAR;
#else
    cfgr |= ADC_CFGR_DMACFG_CIRCULAR;
 8002bea:	9101      	str	r1, [sp, #4]
  dmamode = adcp->dmamode;
  ccr     = grpp->ccr | (adcp->adcc->CCR & (ADC_CCR_CKMODE_MASK |
                                            ADC_CCR_MDMA_MASK));
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
  if (grpp->circular) {
    dmamode |= STM32_DMA_CR_CIRC;
 8002bec:	bf94      	ite	ls
 8002bee:	f047 0720 	orrls.w	r7, r7, #32
    cfgr |= ADC_CFGR_DMACFG_CIRCULAR;
#endif
    if (adcp->depth > 1) {
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      dmamode |= STM32_DMA_CR_HTIE;
 8002bf2:	f047 0724 	orrhi.w	r7, r7, #36	; 0x24
    }
  }

  /* DMA setup.*/
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8002bf6:	6b01      	ldr	r1, [r0, #48]	; 0x30
#if STM32_ADC_DUAL_MODE
  dmaStreamSetTransactionSize(adcp->dmastp, ((uint32_t)grpp->num_channels/2) *
                                            (uint32_t)adcp->depth);
#else
    dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 8002bf8:	8854      	ldrh	r4, [r2, #2]
      dmamode |= STM32_DMA_CR_HTIE;
    }
  }

  /* DMA setup.*/
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8002bfa:	6809      	ldr	r1, [r1, #0]
 8002bfc:	6885      	ldr	r5, [r0, #8]
 8002bfe:	60cd      	str	r5, [r1, #12]
#if STM32_ADC_DUAL_MODE
  dmaStreamSetTransactionSize(adcp->dmastp, ((uint32_t)grpp->num_channels/2) *
                                            (uint32_t)adcp->depth);
#else
    dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 8002c00:	fb04 f303 	mul.w	r3, r4, r3
 8002c04:	604b      	str	r3, [r1, #4]
                                              (uint32_t)adcp->depth);
#endif
  dmaStreamSetMode(adcp->dmastp, dmamode);
 8002c06:	600f      	str	r7, [r1, #0]
  dmaStreamEnable(adcp->dmastp);
 8002c08:	680f      	ldr	r7, [r1, #0]
     structure.*/
  adcp->adcc->CCR   = ccr;

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  adcp->adcm->ISR   = adcp->adcm->ISR;
 8002c0a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  adcp->adcm->IER   = ADC_IER_OVR | ADC_IER_AWD1;
  adcp->adcm->TR1   = grpp->tr1;
 8002c0c:	f8d2 b010 	ldr.w	fp, [r2, #16]
  adcp->adcs->SQR4  = grpp->ssqr[3];

#else /* !STM32_ADC_DUAL_MODE */
  adcp->adcm->SMPR1 = grpp->smpr[0];
  adcp->adcm->SMPR2 = grpp->smpr[1];
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 8002c10:	6a10      	ldr	r0, [r2, #32]
  adcp->adcs->SQR2  = grpp->ssqr[1];
  adcp->adcs->SQR3  = grpp->ssqr[2];
  adcp->adcs->SQR4  = grpp->ssqr[3];

#else /* !STM32_ADC_DUAL_MODE */
  adcp->adcm->SMPR1 = grpp->smpr[0];
 8002c12:	f8d2 a018 	ldr.w	sl, [r2, #24]
  adcp->adcm->SMPR2 = grpp->smpr[1];
 8002c16:	f8d2 901c 	ldr.w	r9, [r2, #28]
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
  adcp->adcm->SQR2  = grpp->sqr[1];
 8002c1a:	f8d2 8024 	ldr.w	r8, [r2, #36]	; 0x24
  adcp->adcm->SQR3  = grpp->sqr[2];
 8002c1e:	f8d2 c028 	ldr.w	ip, [r2, #40]	; 0x28
  adcp->adcm->SQR4  = grpp->sqr[3];
 8002c22:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
#else
    dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
                                              (uint32_t)adcp->depth);
#endif
  dmaStreamSetMode(adcp->dmastp, dmamode);
  dmaStreamEnable(adcp->dmastp);
 8002c24:	f047 0701 	orr.w	r7, r7, #1
 8002c28:	600f      	str	r7, [r1, #0]

  /* Configuring the CCR register with the static settings ORed with
     the user-specified settings in the conversion group configuration
     structure.*/
  adcp->adcc->CCR   = ccr;
 8002c2a:	f8ce 6008 	str.w	r6, [lr, #8]

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  adcp->adcm->ISR   = adcp->adcm->ISR;
 8002c2e:	6819      	ldr	r1, [r3, #0]
 8002c30:	6019      	str	r1, [r3, #0]
  adcp->adcs->SQR4  = grpp->ssqr[3];

#else /* !STM32_ADC_DUAL_MODE */
  adcp->adcm->SMPR1 = grpp->smpr[0];
  adcp->adcm->SMPR2 = grpp->smpr[1];
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 8002c32:	3c01      	subs	r4, #1
  adcp->adcc->CCR   = ccr;

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  adcp->adcm->ISR   = adcp->adcm->ISR;
  adcp->adcm->IER   = ADC_IER_OVR | ADC_IER_AWD1;
 8002c34:	2190      	movs	r1, #144	; 0x90
  adcp->adcs->SQR4  = grpp->ssqr[3];

#else /* !STM32_ADC_DUAL_MODE */
  adcp->adcm->SMPR1 = grpp->smpr[0];
  adcp->adcm->SMPR2 = grpp->smpr[1];
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 8002c36:	4320      	orrs	r0, r4
  adcp->adcc->CCR   = ccr;

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  adcp->adcm->ISR   = adcp->adcm->ISR;
  adcp->adcm->IER   = ADC_IER_OVR | ADC_IER_AWD1;
 8002c38:	6059      	str	r1, [r3, #4]
  adcp->adcm->TR1   = grpp->tr1;
 8002c3a:	f8c3 b020 	str.w	fp, [r3, #32]
  adcp->adcs->SQR2  = grpp->ssqr[1];
  adcp->adcs->SQR3  = grpp->ssqr[2];
  adcp->adcs->SQR4  = grpp->ssqr[3];

#else /* !STM32_ADC_DUAL_MODE */
  adcp->adcm->SMPR1 = grpp->smpr[0];
 8002c3e:	f8c3 a014 	str.w	sl, [r3, #20]
  adcp->adcm->SMPR2 = grpp->smpr[1];
 8002c42:	f8c3 9018 	str.w	r9, [r3, #24]
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels);
 8002c46:	6318      	str	r0, [r3, #48]	; 0x30
  adcp->adcm->SQR2  = grpp->sqr[1];
 8002c48:	f8c3 8034 	str.w	r8, [r3, #52]	; 0x34
  adcp->adcm->SQR3  = grpp->sqr[2];
 8002c4c:	f8c3 c038 	str.w	ip, [r3, #56]	; 0x38
  adcp->adcm->SQR4  = grpp->sqr[3];
 8002c50:	63da      	str	r2, [r3, #60]	; 0x3c
#endif /* !STM32_ADC_DUAL_MODE */

  /* ADC configuration.*/
  adcp->adcm->CFGR  = cfgr;
 8002c52:	9a01      	ldr	r2, [sp, #4]
 8002c54:	60da      	str	r2, [r3, #12]

  /* Starting conversion.*/
  adcp->adcm->CR   |= ADC_CR_ADSTART;
 8002c56:	689a      	ldr	r2, [r3, #8]
 8002c58:	f042 0204 	orr.w	r2, r2, #4
 8002c5c:	609a      	str	r2, [r3, #8]
}
 8002c5e:	b003      	add	sp, #12
 8002c60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
  ccr     = grpp->ccr | (adcp->adcc->CCR & (ADC_CCR_CKMODE_MASK |
                                            ADC_CCR_MDMA_MASK));
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
 8002c64:	f045 0301 	orr.w	r3, r5, #1
 8002c68:	9301      	str	r3, [sp, #4]
 8002c6a:	68c3      	ldr	r3, [r0, #12]
 8002c6c:	e7c3      	b.n	8002bf6 <adc_lld_start_conversion+0x36>
 8002c6e:	bf00      	nop

08002c70 <adc_lld_stop_conversion>:
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8002c70:	6b01      	ldr	r1, [r0, #48]	; 0x30
 8002c72:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {
 8002c74:	b430      	push	{r4, r5}

  dmaStreamDisable(adcp->dmastp);
 8002c76:	e891 0030 	ldmia.w	r1, {r4, r5}
 8002c7a:	6820      	ldr	r0, [r4, #0]
 8002c7c:	f020 000f 	bic.w	r0, r0, #15
 8002c80:	6020      	str	r0, [r4, #0]
 8002c82:	7a09      	ldrb	r1, [r1, #8]
 8002c84:	230f      	movs	r3, #15
 8002c86:	408b      	lsls	r3, r1
 8002c88:	602b      	str	r3, [r5, #0]
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_stop_adc(ADCDriver *adcp) {

  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8002c8a:	6893      	ldr	r3, [r2, #8]
 8002c8c:	0759      	lsls	r1, r3, #29
 8002c8e:	d506      	bpl.n	8002c9e <adc_lld_stop_conversion+0x2e>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 8002c90:	6893      	ldr	r3, [r2, #8]
 8002c92:	f043 0310 	orr.w	r3, r3, #16
 8002c96:	6093      	str	r3, [r2, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8002c98:	6893      	ldr	r3, [r2, #8]
 8002c9a:	06db      	lsls	r3, r3, #27
 8002c9c:	d4fc      	bmi.n	8002c98 <adc_lld_stop_conversion+0x28>
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  adc_lld_stop_adc(adcp);
}
 8002c9e:	bc30      	pop	{r4, r5}
 8002ca0:	4770      	bx	lr
 8002ca2:	bf00      	nop
 8002ca4:	f3af 8000 	nop.w
 8002ca8:	f3af 8000 	nop.w
 8002cac:	f3af 8000 	nop.w

08002cb0 <adc_lld_serve_dma_interrupt>:
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_dma_interrupt(ADCDriver *adcp, uint32_t flags) {
 8002cb0:	b570      	push	{r4, r5, r6, lr}

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8002cb2:	070e      	lsls	r6, r1, #28
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_dma_interrupt(ADCDriver *adcp, uint32_t flags) {
 8002cb4:	4604      	mov	r4, r0

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8002cb6:	d419      	bmi.n	8002cec <adc_lld_serve_dma_interrupt+0x3c>
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  }
  else {
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
 8002cb8:	6903      	ldr	r3, [r0, #16]
 8002cba:	b1b3      	cbz	r3, 8002cea <adc_lld_serve_dma_interrupt+0x3a>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 8002cbc:	078d      	lsls	r5, r1, #30
 8002cbe:	d512      	bpl.n	8002ce6 <adc_lld_serve_dma_interrupt+0x36>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8002cc0:	781a      	ldrb	r2, [r3, #0]
 8002cc2:	2a00      	cmp	r2, #0
 8002cc4:	d03d      	beq.n	8002d42 <adc_lld_serve_dma_interrupt+0x92>
 8002cc6:	685d      	ldr	r5, [r3, #4]
 8002cc8:	b17d      	cbz	r5, 8002cea <adc_lld_serve_dma_interrupt+0x3a>
 8002cca:	68c2      	ldr	r2, [r0, #12]
 8002ccc:	2a01      	cmp	r2, #1
 8002cce:	d933      	bls.n	8002d38 <adc_lld_serve_dma_interrupt+0x88>
 8002cd0:	885b      	ldrh	r3, [r3, #2]
 8002cd2:	6881      	ldr	r1, [r0, #8]
 8002cd4:	0852      	lsrs	r2, r2, #1
 8002cd6:	fb03 f302 	mul.w	r3, r3, r2
 8002cda:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 8002cde:	462b      	mov	r3, r5
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 8002ce0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8002ce4:	4718      	bx	r3
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8002ce6:	074a      	lsls	r2, r1, #29
 8002ce8:	d41d      	bmi.n	8002d26 <adc_lld_serve_dma_interrupt+0x76>
 8002cea:	bd70      	pop	{r4, r5, r6, pc}

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8002cec:	f7ff ffc0 	bl	8002c70 <adc_lld_stop_conversion>
 8002cf0:	6923      	ldr	r3, [r4, #16]
 8002cf2:	689b      	ldr	r3, [r3, #8]
 8002cf4:	b14b      	cbz	r3, 8002d0a <adc_lld_serve_dma_interrupt+0x5a>
 8002cf6:	2205      	movs	r2, #5
 8002cf8:	7022      	strb	r2, [r4, #0]
 8002cfa:	4620      	mov	r0, r4
 8002cfc:	2100      	movs	r1, #0
 8002cfe:	4798      	blx	r3
 8002d00:	7823      	ldrb	r3, [r4, #0]
 8002d02:	2b05      	cmp	r3, #5
 8002d04:	bf04      	itt	eq
 8002d06:	2302      	moveq	r3, #2
 8002d08:	7023      	strbeq	r3, [r4, #0]
 8002d0a:	2500      	movs	r5, #0
 8002d0c:	6125      	str	r5, [r4, #16]
 8002d0e:	2320      	movs	r3, #32
 8002d10:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8002d14:	f04f 31ff 	mov.w	r1, #4294967295
 8002d18:	f104 0014 	add.w	r0, r4, #20
 8002d1c:	f7fe fcc0 	bl	80016a0 <chThdResumeI>
 8002d20:	f385 8811 	msr	BASEPRI, r5
 8002d24:	bd70      	pop	{r4, r5, r6, pc}
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 8002d26:	685b      	ldr	r3, [r3, #4]
 8002d28:	2b00      	cmp	r3, #0
 8002d2a:	d0de      	beq.n	8002cea <adc_lld_serve_dma_interrupt+0x3a>
 8002d2c:	68c2      	ldr	r2, [r0, #12]
 8002d2e:	6881      	ldr	r1, [r0, #8]
 8002d30:	0852      	lsrs	r2, r2, #1
      }
    }
  }
}
 8002d32:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 8002d36:	4718      	bx	r3
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8002d38:	462b      	mov	r3, r5
 8002d3a:	6881      	ldr	r1, [r0, #8]
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 8002d3c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8002d40:	4718      	bx	r3
 8002d42:	f7ff ff95 	bl	8002c70 <adc_lld_stop_conversion>
 8002d46:	6923      	ldr	r3, [r4, #16]
 8002d48:	685b      	ldr	r3, [r3, #4]
 8002d4a:	b1a3      	cbz	r3, 8002d76 <adc_lld_serve_dma_interrupt+0xc6>
 8002d4c:	2204      	movs	r2, #4
 8002d4e:	7022      	strb	r2, [r4, #0]
 8002d50:	4620      	mov	r0, r4
 8002d52:	68a1      	ldr	r1, [r4, #8]
 8002d54:	68e2      	ldr	r2, [r4, #12]
 8002d56:	4798      	blx	r3
 8002d58:	7823      	ldrb	r3, [r4, #0]
 8002d5a:	2b04      	cmp	r3, #4
 8002d5c:	d00b      	beq.n	8002d76 <adc_lld_serve_dma_interrupt+0xc6>
 8002d5e:	2320      	movs	r3, #32
 8002d60:	f383 8811 	msr	BASEPRI, r3
 8002d64:	2100      	movs	r1, #0
 8002d66:	f104 0014 	add.w	r0, r4, #20
 8002d6a:	f7fe fc99 	bl	80016a0 <chThdResumeI>
 8002d6e:	2300      	movs	r3, #0
 8002d70:	f383 8811 	msr	BASEPRI, r3
 8002d74:	bd70      	pop	{r4, r5, r6, pc}
 8002d76:	2202      	movs	r2, #2
 8002d78:	2300      	movs	r3, #0
 8002d7a:	7022      	strb	r2, [r4, #0]
 8002d7c:	6123      	str	r3, [r4, #16]
 8002d7e:	e7ee      	b.n	8002d5e <adc_lld_serve_dma_interrupt+0xae>

08002d80 <Vector88>:
/**
 * @brief   ADC1/ADC2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector88) {
 8002d80:	b570      	push	{r4, r5, r6, lr}
 */
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8002d82:	4d4a      	ldr	r5, [pc, #296]	; (8002eac <Vector88+0x12c>)
  isr  = ADC1->ISR;
  isr |= ADC2->ISR;
  ADC1->ISR = isr;
  ADC2->ISR = isr;
#else /* !STM32_ADC_DUAL_MODE */
  isr  = ADC1->ISR;
 8002d84:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 */
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8002d88:	692a      	ldr	r2, [r5, #16]
  isr  = ADC1->ISR;
  isr |= ADC2->ISR;
  ADC1->ISR = isr;
  ADC2->ISR = isr;
#else /* !STM32_ADC_DUAL_MODE */
  isr  = ADC1->ISR;
 8002d8a:	681c      	ldr	r4, [r3, #0]
  ADC1->ISR = isr;
 8002d8c:	601c      	str	r4, [r3, #0]
 */
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8002d8e:	b13a      	cbz	r2, 8002da0 <Vector88+0x20>
    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
 8002d90:	06e0      	lsls	r0, r4, #27
 8002d92:	d409      	bmi.n	8002da8 <Vector88+0x28>
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
    }
    if (isr & ADC_ISR_AWD1) {
 8002d94:	0621      	lsls	r1, r4, #24
 8002d96:	d42a      	bmi.n	8002dee <Vector88+0x6e>
      /* Analog watchdog error.*/
      _adc_isr_error_code(adcp, ADC_ERR_AWD1);
    }
    if (isr & ADC_ISR_AWD2) {
 8002d98:	05e2      	lsls	r2, r4, #23
 8002d9a:	d447      	bmi.n	8002e2c <Vector88+0xac>
      /* Analog watchdog error.*/
      _adc_isr_error_code(adcp, ADC_ERR_AWD2);
    }
    if (isr & ADC_ISR_AWD3) {
 8002d9c:	05a3      	lsls	r3, r4, #22
 8002d9e:	d464      	bmi.n	8002e6a <Vector88+0xea>
#endif /* !STM32_ADC_DUAL_MODE */

  adc_lld_serve_interrupt(&ADCD1, isr);

  OSAL_IRQ_EPILOGUE();
}
 8002da0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  ADC1->ISR = isr;
#endif /* !STM32_ADC_DUAL_MODE */

  adc_lld_serve_interrupt(&ADCD1, isr);

  OSAL_IRQ_EPILOGUE();
 8002da4:	f7fe b8ac 	b.w	8000f00 <_port_irq_epilogue>
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
 8002da8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8002daa:	681b      	ldr	r3, [r3, #0]
 8002dac:	685b      	ldr	r3, [r3, #4]
  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
 8002dae:	2b00      	cmp	r3, #0
 8002db0:	d0f0      	beq.n	8002d94 <Vector88+0x14>
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
 8002db2:	4628      	mov	r0, r5
 8002db4:	f7ff ff5c 	bl	8002c70 <adc_lld_stop_conversion>
 8002db8:	692b      	ldr	r3, [r5, #16]
 8002dba:	689b      	ldr	r3, [r3, #8]
 8002dbc:	b14b      	cbz	r3, 8002dd2 <Vector88+0x52>
 8002dbe:	2205      	movs	r2, #5
 8002dc0:	702a      	strb	r2, [r5, #0]
 8002dc2:	4628      	mov	r0, r5
 8002dc4:	2101      	movs	r1, #1
 8002dc6:	4798      	blx	r3
 8002dc8:	782b      	ldrb	r3, [r5, #0]
 8002dca:	2b05      	cmp	r3, #5
 8002dcc:	bf04      	itt	eq
 8002dce:	2302      	moveq	r3, #2
 8002dd0:	702b      	strbeq	r3, [r5, #0]
 8002dd2:	2600      	movs	r6, #0
 8002dd4:	612e      	str	r6, [r5, #16]
 8002dd6:	2320      	movs	r3, #32
 8002dd8:	f383 8811 	msr	BASEPRI, r3
 8002ddc:	4834      	ldr	r0, [pc, #208]	; (8002eb0 <Vector88+0x130>)
 8002dde:	f04f 31ff 	mov.w	r1, #4294967295
 8002de2:	f7fe fc5d 	bl	80016a0 <chThdResumeI>
 8002de6:	f386 8811 	msr	BASEPRI, r6
    }
    if (isr & ADC_ISR_AWD1) {
 8002dea:	0621      	lsls	r1, r4, #24
 8002dec:	d5d4      	bpl.n	8002d98 <Vector88+0x18>
      /* Analog watchdog error.*/
      _adc_isr_error_code(adcp, ADC_ERR_AWD1);
 8002dee:	4e2f      	ldr	r6, [pc, #188]	; (8002eac <Vector88+0x12c>)
 8002df0:	4630      	mov	r0, r6
 8002df2:	f7ff ff3d 	bl	8002c70 <adc_lld_stop_conversion>
 8002df6:	692b      	ldr	r3, [r5, #16]
 8002df8:	689b      	ldr	r3, [r3, #8]
 8002dfa:	b14b      	cbz	r3, 8002e10 <Vector88+0x90>
 8002dfc:	2205      	movs	r2, #5
 8002dfe:	7032      	strb	r2, [r6, #0]
 8002e00:	4630      	mov	r0, r6
 8002e02:	2102      	movs	r1, #2
 8002e04:	4798      	blx	r3
 8002e06:	7833      	ldrb	r3, [r6, #0]
 8002e08:	2b05      	cmp	r3, #5
 8002e0a:	bf04      	itt	eq
 8002e0c:	2302      	moveq	r3, #2
 8002e0e:	7033      	strbeq	r3, [r6, #0]
 8002e10:	2600      	movs	r6, #0
 8002e12:	612e      	str	r6, [r5, #16]
 8002e14:	2320      	movs	r3, #32
 8002e16:	f383 8811 	msr	BASEPRI, r3
 8002e1a:	4825      	ldr	r0, [pc, #148]	; (8002eb0 <Vector88+0x130>)
 8002e1c:	f04f 31ff 	mov.w	r1, #4294967295
 8002e20:	f7fe fc3e 	bl	80016a0 <chThdResumeI>
 8002e24:	f386 8811 	msr	BASEPRI, r6
    }
    if (isr & ADC_ISR_AWD2) {
 8002e28:	05e2      	lsls	r2, r4, #23
 8002e2a:	d5b7      	bpl.n	8002d9c <Vector88+0x1c>
      /* Analog watchdog error.*/
      _adc_isr_error_code(adcp, ADC_ERR_AWD2);
 8002e2c:	4e1f      	ldr	r6, [pc, #124]	; (8002eac <Vector88+0x12c>)
 8002e2e:	4630      	mov	r0, r6
 8002e30:	f7ff ff1e 	bl	8002c70 <adc_lld_stop_conversion>
 8002e34:	692b      	ldr	r3, [r5, #16]
 8002e36:	689b      	ldr	r3, [r3, #8]
 8002e38:	b14b      	cbz	r3, 8002e4e <Vector88+0xce>
 8002e3a:	2205      	movs	r2, #5
 8002e3c:	7032      	strb	r2, [r6, #0]
 8002e3e:	4630      	mov	r0, r6
 8002e40:	2103      	movs	r1, #3
 8002e42:	4798      	blx	r3
 8002e44:	7833      	ldrb	r3, [r6, #0]
 8002e46:	2b05      	cmp	r3, #5
 8002e48:	bf04      	itt	eq
 8002e4a:	2302      	moveq	r3, #2
 8002e4c:	7033      	strbeq	r3, [r6, #0]
 8002e4e:	2600      	movs	r6, #0
 8002e50:	612e      	str	r6, [r5, #16]
 8002e52:	2320      	movs	r3, #32
 8002e54:	f383 8811 	msr	BASEPRI, r3
 8002e58:	4815      	ldr	r0, [pc, #84]	; (8002eb0 <Vector88+0x130>)
 8002e5a:	f04f 31ff 	mov.w	r1, #4294967295
 8002e5e:	f7fe fc1f 	bl	80016a0 <chThdResumeI>
 8002e62:	f386 8811 	msr	BASEPRI, r6
    }
    if (isr & ADC_ISR_AWD3) {
 8002e66:	05a3      	lsls	r3, r4, #22
 8002e68:	d59a      	bpl.n	8002da0 <Vector88+0x20>
      /* Analog watchdog error.*/
      _adc_isr_error_code(adcp, ADC_ERR_AWD3);
 8002e6a:	4c10      	ldr	r4, [pc, #64]	; (8002eac <Vector88+0x12c>)
 8002e6c:	4620      	mov	r0, r4
 8002e6e:	f7ff feff 	bl	8002c70 <adc_lld_stop_conversion>
 8002e72:	692b      	ldr	r3, [r5, #16]
 8002e74:	689b      	ldr	r3, [r3, #8]
 8002e76:	b14b      	cbz	r3, 8002e8c <Vector88+0x10c>
 8002e78:	2205      	movs	r2, #5
 8002e7a:	7022      	strb	r2, [r4, #0]
 8002e7c:	4620      	mov	r0, r4
 8002e7e:	2104      	movs	r1, #4
 8002e80:	4798      	blx	r3
 8002e82:	7823      	ldrb	r3, [r4, #0]
 8002e84:	2b05      	cmp	r3, #5
 8002e86:	bf04      	itt	eq
 8002e88:	2302      	moveq	r3, #2
 8002e8a:	7023      	strbeq	r3, [r4, #0]
 8002e8c:	2400      	movs	r4, #0
 8002e8e:	612c      	str	r4, [r5, #16]
 8002e90:	2320      	movs	r3, #32
 8002e92:	f383 8811 	msr	BASEPRI, r3
 8002e96:	4806      	ldr	r0, [pc, #24]	; (8002eb0 <Vector88+0x130>)
 8002e98:	f04f 31ff 	mov.w	r1, #4294967295
 8002e9c:	f7fe fc00 	bl	80016a0 <chThdResumeI>
 8002ea0:	f384 8811 	msr	BASEPRI, r4
#endif /* !STM32_ADC_DUAL_MODE */

  adc_lld_serve_interrupt(&ADCD1, isr);

  OSAL_IRQ_EPILOGUE();
}
 8002ea4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  ADC1->ISR = isr;
#endif /* !STM32_ADC_DUAL_MODE */

  adc_lld_serve_interrupt(&ADCD1, isr);

  OSAL_IRQ_EPILOGUE();
 8002ea8:	f7fe b82a 	b.w	8000f00 <_port_irq_epilogue>
 8002eac:	20001154 	.word	0x20001154
 8002eb0:	20001168 	.word	0x20001168
 8002eb4:	f3af 8000 	nop.w
 8002eb8:	f3af 8000 	nop.w
 8002ebc:	f3af 8000 	nop.w

08002ec0 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8002ec0:	b4f0      	push	{r4, r5, r6, r7}
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8002ec2:	4f36      	ldr	r7, [pc, #216]	; (8002f9c <_pal_lld_init+0xdc>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002ec4:	4d36      	ldr	r5, [pc, #216]	; (8002fa0 <_pal_lld_init+0xe0>)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8002ec6:	697e      	ldr	r6, [r7, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002ec8:	4c36      	ldr	r4, [pc, #216]	; (8002fa4 <_pal_lld_init+0xe4>)
 8002eca:	4937      	ldr	r1, [pc, #220]	; (8002fa8 <_pal_lld_init+0xe8>)
 8002ecc:	4a37      	ldr	r2, [pc, #220]	; (8002fac <_pal_lld_init+0xec>)
 8002ece:	4b38      	ldr	r3, [pc, #224]	; (8002fb0 <_pal_lld_init+0xf0>)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8002ed0:	f446 06fc 	orr.w	r6, r6, #8257536	; 0x7e0000
 8002ed4:	617e      	str	r6, [r7, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002ed6:	f04f 4690 	mov.w	r6, #1207959552	; 0x48000000
 8002eda:	6847      	ldr	r7, [r0, #4]
 8002edc:	6077      	str	r7, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002ede:	6887      	ldr	r7, [r0, #8]
 8002ee0:	60b7      	str	r7, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8002ee2:	68c7      	ldr	r7, [r0, #12]
 8002ee4:	60f7      	str	r7, [r6, #12]
  gpiop->ODR     = config->odr;
 8002ee6:	6907      	ldr	r7, [r0, #16]
 8002ee8:	6177      	str	r7, [r6, #20]
  gpiop->AFRL    = config->afrl;
 8002eea:	6947      	ldr	r7, [r0, #20]
 8002eec:	6237      	str	r7, [r6, #32]
  gpiop->AFRH    = config->afrh;
 8002eee:	6987      	ldr	r7, [r0, #24]
 8002ef0:	6277      	str	r7, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002ef2:	6807      	ldr	r7, [r0, #0]
 8002ef4:	6037      	str	r7, [r6, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002ef6:	6a06      	ldr	r6, [r0, #32]
 8002ef8:	606e      	str	r6, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002efa:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8002efc:	60ae      	str	r6, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 8002efe:	6a86      	ldr	r6, [r0, #40]	; 0x28
 8002f00:	60ee      	str	r6, [r5, #12]
  gpiop->ODR     = config->odr;
 8002f02:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
 8002f04:	616e      	str	r6, [r5, #20]
  gpiop->AFRL    = config->afrl;
 8002f06:	6b06      	ldr	r6, [r0, #48]	; 0x30
 8002f08:	622e      	str	r6, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8002f0a:	6b46      	ldr	r6, [r0, #52]	; 0x34
 8002f0c:	626e      	str	r6, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002f0e:	69c6      	ldr	r6, [r0, #28]
 8002f10:	602e      	str	r6, [r5, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002f12:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
 8002f14:	6065      	str	r5, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002f16:	6c05      	ldr	r5, [r0, #64]	; 0x40
 8002f18:	60a5      	str	r5, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8002f1a:	6c45      	ldr	r5, [r0, #68]	; 0x44
 8002f1c:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 8002f1e:	6c85      	ldr	r5, [r0, #72]	; 0x48
 8002f20:	6165      	str	r5, [r4, #20]
  gpiop->AFRL    = config->afrl;
 8002f22:	6cc5      	ldr	r5, [r0, #76]	; 0x4c
 8002f24:	6225      	str	r5, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8002f26:	6d05      	ldr	r5, [r0, #80]	; 0x50
 8002f28:	6265      	str	r5, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002f2a:	6b85      	ldr	r5, [r0, #56]	; 0x38
 8002f2c:	6025      	str	r5, [r4, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002f2e:	6d84      	ldr	r4, [r0, #88]	; 0x58
 8002f30:	604c      	str	r4, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002f32:	6dc4      	ldr	r4, [r0, #92]	; 0x5c
 8002f34:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8002f36:	6e04      	ldr	r4, [r0, #96]	; 0x60
 8002f38:	60cc      	str	r4, [r1, #12]
  gpiop->ODR     = config->odr;
 8002f3a:	6e44      	ldr	r4, [r0, #100]	; 0x64
 8002f3c:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8002f3e:	6e84      	ldr	r4, [r0, #104]	; 0x68
 8002f40:	620c      	str	r4, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8002f42:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
 8002f44:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002f46:	6d44      	ldr	r4, [r0, #84]	; 0x54
 8002f48:	600c      	str	r4, [r1, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002f4a:	6f41      	ldr	r1, [r0, #116]	; 0x74
 8002f4c:	6051      	str	r1, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002f4e:	6f81      	ldr	r1, [r0, #120]	; 0x78
 8002f50:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8002f52:	6fc1      	ldr	r1, [r0, #124]	; 0x7c
 8002f54:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 8002f56:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
 8002f5a:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8002f5c:	f8d0 1084 	ldr.w	r1, [r0, #132]	; 0x84
 8002f60:	6211      	str	r1, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8002f62:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 8002f66:	6251      	str	r1, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002f68:	6f01      	ldr	r1, [r0, #112]	; 0x70
 8002f6a:	6011      	str	r1, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002f6c:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 8002f70:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002f72:	f8d0 2094 	ldr.w	r2, [r0, #148]	; 0x94
 8002f76:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8002f78:	f8d0 2098 	ldr.w	r2, [r0, #152]	; 0x98
 8002f7c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8002f7e:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
 8002f82:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8002f84:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
 8002f88:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8002f8a:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
 8002f8e:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002f90:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 8002f94:	601a      	str	r2, [r3, #0]
  initgpio(GPIOH, &config->PHData);
#endif
#if STM32_HAS_GPIOI
  initgpio(GPIOI, &config->PIData);
#endif
}
 8002f96:	bcf0      	pop	{r4, r5, r6, r7}
 8002f98:	4770      	bx	lr
 8002f9a:	bf00      	nop
 8002f9c:	40021000 	.word	0x40021000
 8002fa0:	48000400 	.word	0x48000400
 8002fa4:	48000800 	.word	0x48000800
 8002fa8:	48000c00 	.word	0x48000c00
 8002fac:	48001000 	.word	0x48001000
 8002fb0:	48001400 	.word	0x48001400
 8002fb4:	f3af 8000 	nop.w
 8002fb8:	f3af 8000 	nop.w
 8002fbc:	f3af 8000 	nop.w

08002fc0 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8002fc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
 8002fc4:	f04f 0c0f 	mov.w	ip, #15
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8002fc8:	f002 0e03 	and.w	lr, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8002fcc:	f3c2 0780 	ubfx	r7, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8002fd0:	f3c2 06c1 	ubfx	r6, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 8002fd4:	f3c2 1541 	ubfx	r5, r2, #5, #2
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8002fd8:	2400      	movs	r4, #0

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8002fda:	f3c2 12c3 	ubfx	r2, r2, #7, #4
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 8002fde:	f04f 0901 	mov.w	r9, #1
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 8002fe2:	f04f 0803 	mov.w	r8, #3
 8002fe6:	e02b      	b.n	8003040 <_pal_lld_setgroupmode+0x80>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 8002fe8:	f8d0 b020 	ldr.w	fp, [r0, #32]
 8002fec:	ea2b 0303 	bic.w	r3, fp, r3
 8002ff0:	ea43 030a 	orr.w	r3, r3, sl
 8002ff4:	6203      	str	r3, [r0, #32]
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8002ff6:	6843      	ldr	r3, [r0, #4]
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 8002ff8:	fa09 fa04 	lsl.w	sl, r9, r4
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8002ffc:	ea23 030a 	bic.w	r3, r3, sl
 8003000:	433b      	orrs	r3, r7
 8003002:	6043      	str	r3, [r0, #4]
 8003004:	ea4f 0a44 	mov.w	sl, r4, lsl #1
      m2 = 3 << (bit * 2);
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8003008:	6883      	ldr	r3, [r0, #8]
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 800300a:	fa08 fa0a 	lsl.w	sl, r8, sl
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800300e:	ea6f 0a0a 	mvn.w	sl, sl
 8003012:	ea0a 0303 	and.w	r3, sl, r3
 8003016:	4333      	orrs	r3, r6
 8003018:	6083      	str	r3, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800301a:	68c3      	ldr	r3, [r0, #12]
 800301c:	ea0a 0303 	and.w	r3, sl, r3
 8003020:	432b      	orrs	r3, r5
 8003022:	60c3      	str	r3, [r0, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 8003024:	6803      	ldr	r3, [r0, #0]
 8003026:	ea0a 0303 	and.w	r3, sl, r3
 800302a:	ea43 030e 	orr.w	r3, r3, lr
 800302e:	6003      	str	r3, [r0, #0]
    }
    mask >>= 1;
    if (!mask)
 8003030:	0849      	lsrs	r1, r1, #1
 8003032:	d019      	beq.n	8003068 <_pal_lld_setgroupmode+0xa8>
      return;
    otyper <<= 1;
 8003034:	007f      	lsls	r7, r7, #1
    ospeedr <<= 2;
 8003036:	00b6      	lsls	r6, r6, #2
    pupdr <<= 2;
 8003038:	00ad      	lsls	r5, r5, #2
    moder <<= 2;
 800303a:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    bit++;
 800303e:	3401      	adds	r4, #1
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8003040:	f004 0307 	and.w	r3, r4, #7
 8003044:	009b      	lsls	r3, r3, #2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 8003046:	f011 0f01 	tst.w	r1, #1
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800304a:	fa02 fa03 	lsl.w	sl, r2, r3
      m4 = 15 << ((bit & 7) * 4);
 800304e:	fa0c f303 	lsl.w	r3, ip, r3
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 8003052:	d0ed      	beq.n	8003030 <_pal_lld_setgroupmode+0x70>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
 8003054:	2c07      	cmp	r4, #7
 8003056:	d9c7      	bls.n	8002fe8 <_pal_lld_setgroupmode+0x28>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003058:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
 800305c:	ea2b 0303 	bic.w	r3, fp, r3
 8003060:	ea43 030a 	orr.w	r3, r3, sl
 8003064:	6243      	str	r3, [r0, #36]	; 0x24
 8003066:	e7c6      	b.n	8002ff6 <_pal_lld_setgroupmode+0x36>
 8003068:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800306c:	f3af 8000 	nop.w

08003070 <VectorA4>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8003070:	b508      	push	{r3, lr}
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 */
static void gpt_lld_serve_interrupt(GPTDriver *gptp) {

  gptp->tim->SR = 0;
 8003072:	4b0b      	ldr	r3, [pc, #44]	; (80030a0 <VectorA4+0x30>)
  if (gptp->state == GPT_ONESHOT) {
 8003074:	7818      	ldrb	r0, [r3, #0]
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 */
static void gpt_lld_serve_interrupt(GPTDriver *gptp) {

  gptp->tim->SR = 0;
 8003076:	68da      	ldr	r2, [r3, #12]
 8003078:	2100      	movs	r1, #0
  if (gptp->state == GPT_ONESHOT) {
 800307a:	2804      	cmp	r0, #4
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 */
static void gpt_lld_serve_interrupt(GPTDriver *gptp) {

  gptp->tim->SR = 0;
 800307c:	6111      	str	r1, [r2, #16]
  if (gptp->state == GPT_ONESHOT) {
 800307e:	d107      	bne.n	8003090 <VectorA4+0x20>
    gptp->state = GPT_READY;                /* Back in GPT_READY state.     */
 8003080:	2002      	movs	r0, #2
 8003082:	7018      	strb	r0, [r3, #0]
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  gptp->tim->CR1   = 0;                         /* Initially stopped.       */
 8003084:	6011      	str	r1, [r2, #0]
  gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
 8003086:	6111      	str	r1, [r2, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 8003088:	68d1      	ldr	r1, [r2, #12]
 800308a:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 800308e:	60d1      	str	r1, [r2, #12]
  gptp->tim->SR = 0;
  if (gptp->state == GPT_ONESHOT) {
    gptp->state = GPT_READY;                /* Back in GPT_READY state.     */
    gpt_lld_stop_timer(gptp);               /* Timer automatically stopped. */
  }
  gptp->config->callback(gptp);
 8003090:	685b      	ldr	r3, [r3, #4]
 8003092:	4803      	ldr	r0, [pc, #12]	; (80030a0 <VectorA4+0x30>)
 8003094:	685b      	ldr	r3, [r3, #4]
 8003096:	4798      	blx	r3
  OSAL_IRQ_PROLOGUE();

  gpt_lld_serve_interrupt(&GPTD1);

  OSAL_IRQ_EPILOGUE();
}
 8003098:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  gpt_lld_serve_interrupt(&GPTD1);

  OSAL_IRQ_EPILOGUE();
 800309c:	f7fd bf30 	b.w	8000f00 <_port_irq_epilogue>
 80030a0:	2000118c 	.word	0x2000118c
 80030a4:	f3af 8000 	nop.w
 80030a8:	f3af 8000 	nop.w
 80030ac:	f3af 8000 	nop.w

080030b0 <gpt_lld_init>:
 */
void gpt_lld_init(void) {

#if STM32_GPT_USE_TIM1
  /* Driver initialization.*/
  GPTD1.tim = STM32_TIM1;
 80030b0:	4802      	ldr	r0, [pc, #8]	; (80030bc <gpt_lld_init+0xc>)
 80030b2:	4b03      	ldr	r3, [pc, #12]	; (80030c0 <gpt_lld_init+0x10>)
 80030b4:	60c3      	str	r3, [r0, #12]
  gptObjectInit(&GPTD1);
 80030b6:	f7fe bf43 	b.w	8001f40 <gptObjectInit>
 80030ba:	bf00      	nop
 80030bc:	2000118c 	.word	0x2000118c
 80030c0:	40012c00 	.word	0x40012c00
 80030c4:	f3af 8000 	nop.w
 80030c8:	f3af 8000 	nop.w
 80030cc:	f3af 8000 	nop.w

080030d0 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 80030d0:	b538      	push	{r3, r4, r5, lr}
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 80030d2:	7803      	ldrb	r3, [r0, #0]
 80030d4:	2b01      	cmp	r3, #1
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 80030d6:	4604      	mov	r4, r0
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 80030d8:	d012      	beq.n	8003100 <gpt_lld_start+0x30>
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 80030da:	6860      	ldr	r0, [r4, #4]
 80030dc:	68a3      	ldr	r3, [r4, #8]
  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
  gptp->tim->CR2  = gptp->config->cr2;
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 80030de:	68c1      	ldr	r1, [r0, #12]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 80030e0:	6805      	ldr	r5, [r0, #0]
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 80030e2:	68e2      	ldr	r2, [r4, #12]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 80030e4:	fbb3 f3f5 	udiv	r3, r3, r5
 80030e8:	3b01      	subs	r3, #1
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
  gptp->tim->CR2  = gptp->config->cr2;
 80030ea:	6884      	ldr	r4, [r0, #8]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 80030ec:	b29b      	uxth	r3, r3
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 80030ee:	2000      	movs	r0, #0
  gptp->tim->CR2  = gptp->config->cr2;
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 80030f0:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 80030f4:	6010      	str	r0, [r2, #0]
  gptp->tim->CR2  = gptp->config->cr2;
 80030f6:	6054      	str	r4, [r2, #4]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 80030f8:	6293      	str	r3, [r2, #40]	; 0x28
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
 80030fa:	6110      	str	r0, [r2, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 80030fc:	60d1      	str	r1, [r2, #12]
 80030fe:	bd38      	pop	{r3, r4, r5, pc}
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
    /* Clock activation.*/
#if STM32_GPT_USE_TIM1
    if (&GPTD1 == gptp) {
 8003100:	4b0a      	ldr	r3, [pc, #40]	; (800312c <gpt_lld_start+0x5c>)
 8003102:	4298      	cmp	r0, r3
 8003104:	d1e9      	bne.n	80030da <gpt_lld_start+0xa>
      rccEnableTIM1(FALSE);
 8003106:	4b0a      	ldr	r3, [pc, #40]	; (8003130 <gpt_lld_start+0x60>)
 8003108:	699a      	ldr	r2, [r3, #24]
 800310a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800310e:	619a      	str	r2, [r3, #24]
      rccResetTIM1();
 8003110:	68da      	ldr	r2, [r3, #12]
 8003112:	2100      	movs	r1, #0
 8003114:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8003118:	60da      	str	r2, [r3, #12]
      nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_GPT_TIM1_IRQ_PRIORITY);
 800311a:	2019      	movs	r0, #25
  if (gptp->state == GPT_STOP) {
    /* Clock activation.*/
#if STM32_GPT_USE_TIM1
    if (&GPTD1 == gptp) {
      rccEnableTIM1(FALSE);
      rccResetTIM1();
 800311c:	60d9      	str	r1, [r3, #12]
      nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_GPT_TIM1_IRQ_PRIORITY);
 800311e:	2107      	movs	r1, #7
 8003120:	f7ff fab6 	bl	8002690 <nvicEnableVector>
#if defined(STM32_TIM1CLK)
      gptp->clock = STM32_TIM1CLK;
 8003124:	4b03      	ldr	r3, [pc, #12]	; (8003134 <gpt_lld_start+0x64>)
 8003126:	60a3      	str	r3, [r4, #8]
 8003128:	e7d7      	b.n	80030da <gpt_lld_start+0xa>
 800312a:	bf00      	nop
 800312c:	2000118c 	.word	0x2000118c
 8003130:	40021000 	.word	0x40021000
 8003134:	044aa200 	.word	0x044aa200
 8003138:	f3af 8000 	nop.w
 800313c:	f3af 8000 	nop.w

08003140 <gpt_lld_start_timer>:

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is because the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
  if (NULL != gptp->config->callback)
 8003140:	6842      	ldr	r2, [r0, #4]
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  gptp->tim->ARR   = (uint32_t)(interval - 1);  /* Time constant.           */
 8003142:	68c3      	ldr	r3, [r0, #12]

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is because the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
  if (NULL != gptp->config->callback)
 8003144:	6850      	ldr	r0, [r2, #4]
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  gptp->tim->ARR   = (uint32_t)(interval - 1);  /* Time constant.           */
 8003146:	3901      	subs	r1, #1
 8003148:	62d9      	str	r1, [r3, #44]	; 0x2c
  gptp->tim->EGR   = STM32_TIM_EGR_UG;          /* Update event.            */
  gptp->tim->CNT   = 0;                         /* Reset counter.           */
 800314a:	2200      	movs	r2, #0
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  gptp->tim->ARR   = (uint32_t)(interval - 1);  /* Time constant.           */
  gptp->tim->EGR   = STM32_TIM_EGR_UG;          /* Update event.            */
 800314c:	2101      	movs	r1, #1
 800314e:	6159      	str	r1, [r3, #20]
  gptp->tim->CNT   = 0;                         /* Reset counter.           */
 8003150:	625a      	str	r2, [r3, #36]	; 0x24

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is because the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR    = 0;                         /* Clear pending IRQs.      */
 8003152:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
 8003154:	b110      	cbz	r0, 800315c <gpt_lld_start_timer+0x1c>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 8003156:	68da      	ldr	r2, [r3, #12]
 8003158:	430a      	orrs	r2, r1
 800315a:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1   = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 800315c:	2205      	movs	r2, #5
 800315e:	601a      	str	r2, [r3, #0]
 8003160:	4770      	bx	lr
 8003162:	bf00      	nop
 8003164:	f3af 8000 	nop.w
 8003168:	f3af 8000 	nop.w
 800316c:	f3af 8000 	nop.w

08003170 <VectorB0>:
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  STM32_ST_TIM->SR = 0;
 8003170:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8003174:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  STM32_ST_TIM->SR = 0;
 8003176:	2400      	movs	r4, #0
 8003178:	611c      	str	r4, [r3, #16]
 800317a:	2320      	movs	r3, #32
 800317c:	f383 8811 	msr	BASEPRI, r3
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
 8003180:	f7fd ff4e 	bl	8001020 <chSysTimerHandlerI>
 8003184:	f384 8811 	msr	BASEPRI, r4
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
 8003188:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 800318c:	f7fd beb8 	b.w	8000f00 <_port_irq_epilogue>

08003190 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8003190:	b470      	push	{r4, r5, r6}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8003192:	480d      	ldr	r0, [pc, #52]	; (80031c8 <st_lld_init+0x38>)
 8003194:	69c1      	ldr	r1, [r0, #28]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8003196:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 800319a:	2200      	movs	r2, #0
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800319c:	2401      	movs	r4, #1

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800319e:	f041 0101 	orr.w	r1, r1, #1

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80031a2:	f641 461f 	movw	r6, #7199	; 0x1c1f
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80031a6:	f04f 35ff 	mov.w	r5, #4294967295

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80031aa:	61c1      	str	r1, [r0, #28]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80031ac:	629e      	str	r6, [r3, #40]	; 0x28
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80031ae:	201c      	movs	r0, #28
  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80031b0:	62dd      	str	r5, [r3, #44]	; 0x2c
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80031b2:	2108      	movs	r1, #8
  ST_ENABLE_CLOCK();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 80031b4:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80031b6:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80031b8:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 80031ba:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80031bc:	615c      	str	r4, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80031be:	601c      	str	r4, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 80031c0:	bc70      	pop	{r4, r5, r6}
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 80031c2:	f7ff ba65 	b.w	8002690 <nvicEnableVector>
 80031c6:	bf00      	nop
 80031c8:	40021000 	.word	0x40021000
 80031cc:	f3af 8000 	nop.w

080031d0 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 80031d0:	4a02      	ldr	r2, [pc, #8]	; (80031dc <notify1+0xc>)
 80031d2:	6813      	ldr	r3, [r2, #0]
 80031d4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80031d8:	6013      	str	r3, [r2, #0]
 80031da:	4770      	bx	lr
 80031dc:	40013800 	.word	0x40013800

080031e0 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 80031e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 80031e2:	4f3b      	ldr	r7, [pc, #236]	; (80032d0 <VectorD4+0xf0>)
 80031e4:	6f7d      	ldr	r5, [r7, #116]	; 0x74
  uint32_t cr1 = u->CR1;
 80031e6:	682e      	ldr	r6, [r5, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 80031e8:	69ec      	ldr	r4, [r5, #28]
  u->ICR = isr;
 80031ea:	622c      	str	r4, [r5, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 80031ec:	0722      	lsls	r2, r4, #28
 80031ee:	d133      	bne.n	8003258 <VectorD4+0x78>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 80031f0:	05e3      	lsls	r3, r4, #23
 80031f2:	d425      	bmi.n	8003240 <VectorD4+0x60>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 80031f4:	06a0      	lsls	r0, r4, #26
 80031f6:	d417      	bmi.n	8003228 <VectorD4+0x48>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 80031f8:	0631      	lsls	r1, r6, #24
 80031fa:	d501      	bpl.n	8003200 <VectorD4+0x20>
 80031fc:	0622      	lsls	r2, r4, #24
 80031fe:	d446      	bmi.n	800328e <VectorD4+0xae>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8003200:	0663      	lsls	r3, r4, #25
 8003202:	d50d      	bpl.n	8003220 <VectorD4+0x40>
 8003204:	2320      	movs	r3, #32
 8003206:	f383 8811 	msr	BASEPRI, r3
 800320a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800320c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800320e:	4830      	ldr	r0, [pc, #192]	; (80032d0 <VectorD4+0xf0>)
 8003210:	429a      	cmp	r2, r3
 8003212:	d04a      	beq.n	80032aa <VectorD4+0xca>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8003214:	f026 0640 	bic.w	r6, r6, #64	; 0x40
 8003218:	602e      	str	r6, [r5, #0]
 800321a:	2300      	movs	r3, #0
 800321c:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
}
 8003220:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
 8003224:	f7fd be6c 	b.w	8000f00 <_port_irq_epilogue>
 8003228:	2320      	movs	r3, #32
 800322a:	f383 8811 	msr	BASEPRI, r3
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 800322e:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
 8003230:	4827      	ldr	r0, [pc, #156]	; (80032d0 <VectorD4+0xf0>)
 8003232:	b2c9      	uxtb	r1, r1
 8003234:	f7fe ff24 	bl	8002080 <sdIncomingDataI>
 8003238:	2300      	movs	r3, #0
 800323a:	f383 8811 	msr	BASEPRI, r3
 800323e:	e7db      	b.n	80031f8 <VectorD4+0x18>
 8003240:	2320      	movs	r3, #32
 8003242:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8003246:	4823      	ldr	r0, [pc, #140]	; (80032d4 <VectorD4+0xf4>)
 8003248:	f44f 7100 	mov.w	r1, #512	; 0x200
 800324c:	f7fe fba0 	bl	8001990 <chEvtBroadcastFlagsI>
 8003250:	2300      	movs	r3, #0
 8003252:	f383 8811 	msr	BASEPRI, r3
 8003256:	e7cd      	b.n	80031f4 <VectorD4+0x14>
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
    sts |= SD_OVERRUN_ERROR;
 8003258:	f014 0f08 	tst.w	r4, #8
 800325c:	bf0c      	ite	eq
 800325e:	2100      	moveq	r1, #0
 8003260:	2180      	movne	r1, #128	; 0x80
  if (isr & USART_ISR_PE)
 8003262:	07e3      	lsls	r3, r4, #31
    sts |= SD_PARITY_ERROR;
 8003264:	bf48      	it	mi
 8003266:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_ISR_FE)
 800326a:	07a0      	lsls	r0, r4, #30
    sts |= SD_FRAMING_ERROR;
 800326c:	bf48      	it	mi
 800326e:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (isr & USART_ISR_NE)
 8003272:	0762      	lsls	r2, r4, #29
    sts |= SD_NOISE_ERROR;
 8003274:	bf48      	it	mi
 8003276:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 800327a:	2320      	movs	r3, #32
 800327c:	f383 8811 	msr	BASEPRI, r3
 8003280:	4814      	ldr	r0, [pc, #80]	; (80032d4 <VectorD4+0xf4>)
 8003282:	f7fe fb85 	bl	8001990 <chEvtBroadcastFlagsI>
 8003286:	2300      	movs	r3, #0
 8003288:	f383 8811 	msr	BASEPRI, r3
 800328c:	e7b0      	b.n	80031f0 <VectorD4+0x10>
 800328e:	2320      	movs	r3, #32
 8003290:	f383 8811 	msr	BASEPRI, r3

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 8003294:	4810      	ldr	r0, [pc, #64]	; (80032d8 <VectorD4+0xf8>)
 8003296:	f7fe fca3 	bl	8001be0 <chOQGetI>
    if (b < Q_OK) {
 800329a:	2800      	cmp	r0, #0
 800329c:	db0d      	blt.n	80032ba <VectorD4+0xda>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 800329e:	b280      	uxth	r0, r0
 80032a0:	8528      	strh	r0, [r5, #40]	; 0x28
 80032a2:	2300      	movs	r3, #0
 80032a4:	f383 8811 	msr	BASEPRI, r3
 80032a8:	e7aa      	b.n	8003200 <VectorD4+0x20>
 80032aa:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80032ac:	2b00      	cmp	r3, #0
 80032ae:	d0b1      	beq.n	8003214 <VectorD4+0x34>
 80032b0:	3004      	adds	r0, #4
 80032b2:	2110      	movs	r1, #16
 80032b4:	f7fe fb6c 	bl	8001990 <chEvtBroadcastFlagsI>
 80032b8:	e7ac      	b.n	8003214 <VectorD4+0x34>
 80032ba:	4806      	ldr	r0, [pc, #24]	; (80032d4 <VectorD4+0xf4>)
 80032bc:	2108      	movs	r1, #8
 80032be:	f7fe fb67 	bl	8001990 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80032c2:	f026 03c0 	bic.w	r3, r6, #192	; 0xc0
 80032c6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80032ca:	602b      	str	r3, [r5, #0]
 80032cc:	e7e9      	b.n	80032a2 <VectorD4+0xc2>
 80032ce:	bf00      	nop
 80032d0:	2000119c 	.word	0x2000119c
 80032d4:	200011a0 	.word	0x200011a0
 80032d8:	200011cc 	.word	0x200011cc
 80032dc:	f3af 8000 	nop.w

080032e0 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 80032e0:	b510      	push	{r4, lr}

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 80032e2:	4c05      	ldr	r4, [pc, #20]	; (80032f8 <sd_lld_init+0x18>)
 80032e4:	4a05      	ldr	r2, [pc, #20]	; (80032fc <sd_lld_init+0x1c>)
 80032e6:	4620      	mov	r0, r4
 80032e8:	2100      	movs	r1, #0
 80032ea:	f7fe fe99 	bl	8002020 <sdObjectInit>
  SD1.usart = USART1;
 80032ee:	4a04      	ldr	r2, [pc, #16]	; (8003300 <sd_lld_init+0x20>)
  SD1.clock = STM32_USART1CLK;
 80032f0:	4b04      	ldr	r3, [pc, #16]	; (8003304 <sd_lld_init+0x24>)
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 80032f2:	6762      	str	r2, [r4, #116]	; 0x74
  SD1.clock = STM32_USART1CLK;
 80032f4:	67a3      	str	r3, [r4, #120]	; 0x78
 80032f6:	bd10      	pop	{r4, pc}
 80032f8:	2000119c 	.word	0x2000119c
 80032fc:	080031d1 	.word	0x080031d1
 8003300:	40013800 	.word	0x40013800
 8003304:	02255100 	.word	0x02255100
 8003308:	f3af 8000 	nop.w
 800330c:	f3af 8000 	nop.w

08003310 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8003310:	b570      	push	{r4, r5, r6, lr}

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8003312:	7a03      	ldrb	r3, [r0, #8]
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 8003314:	4c16      	ldr	r4, [pc, #88]	; (8003370 <sd_lld_start+0x60>)
 8003316:	2900      	cmp	r1, #0
 8003318:	bf18      	it	ne
 800331a:	460c      	movne	r4, r1

  if (sdp->state == SD_STOP) {
 800331c:	2b01      	cmp	r3, #1
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 800331e:	4606      	mov	r6, r0

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8003320:	d018      	beq.n	8003354 <sd_lld_start+0x44>

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8003322:	6862      	ldr	r2, [r4, #4]

  /* Baud rate setting.*/
  u->BRR = (uint16_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8003324:	68a5      	ldr	r5, [r4, #8]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8003326:	68e0      	ldr	r0, [r4, #12]
 8003328:	6f73      	ldr	r3, [r6, #116]	; 0x74
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;

  /* Baud rate setting.*/
  u->BRR = (uint16_t)(sdp->clock / config->speed);
 800332a:	6824      	ldr	r4, [r4, #0]
 800332c:	6fb1      	ldr	r1, [r6, #120]	; 0x78
 800332e:	fbb1 f1f4 	udiv	r1, r1, r4

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8003332:	f442 7296 	orr.w	r2, r2, #300	; 0x12c

  /* Baud rate setting.*/
  u->BRR = (uint16_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8003336:	f045 0440 	orr.w	r4, r5, #64	; 0x40
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;

  /* Baud rate setting.*/
  u->BRR = (uint16_t)(sdp->clock / config->speed);
 800333a:	b289      	uxth	r1, r1

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800333c:	f040 0001 	orr.w	r0, r0, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8003340:	f042 0201 	orr.w	r2, r2, #1
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFF;
 8003344:	f04f 35ff 	mov.w	r5, #4294967295
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;

  /* Baud rate setting.*/
  u->BRR = (uint16_t)(sdp->clock / config->speed);
 8003348:	60d9      	str	r1, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800334a:	605c      	str	r4, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800334c:	6098      	str	r0, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800334e:	601a      	str	r2, [r3, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFF;
 8003350:	621d      	str	r5, [r3, #32]
 8003352:	bd70      	pop	{r4, r5, r6, pc}
  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 8003354:	4b07      	ldr	r3, [pc, #28]	; (8003374 <sd_lld_start+0x64>)
 8003356:	4298      	cmp	r0, r3
 8003358:	d1e3      	bne.n	8003322 <sd_lld_start+0x12>
      rccEnableUSART1(FALSE);
 800335a:	4a07      	ldr	r2, [pc, #28]	; (8003378 <sd_lld_start+0x68>)
 800335c:	6993      	ldr	r3, [r2, #24]
 800335e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003362:	6193      	str	r3, [r2, #24]
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
 8003364:	2025      	movs	r0, #37	; 0x25
 8003366:	210c      	movs	r1, #12
 8003368:	f7ff f992 	bl	8002690 <nvicEnableVector>
 800336c:	e7d9      	b.n	8003322 <sd_lld_start+0x12>
 800336e:	bf00      	nop
 8003370:	080069c0 	.word	0x080069c0
 8003374:	2000119c 	.word	0x2000119c
 8003378:	40021000 	.word	0x40021000
 800337c:	f3af 8000 	nop.w

08003380 <usb_packet_write_from_queue>:
 *                      not exceed the maximum packet size for this endpoint.
 *
 * @notapi
 */
static void usb_packet_write_from_queue(stm32_usb_descriptor_t *udp,
                                        output_queue_t *oqp, size_t n) {
 8003380:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003384:	4690      	mov	r8, r2
  size_t nhw;
  syssts_t sts;
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8003386:	6802      	ldr	r2, [r0, #0]

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 8003388:	f8c0 8004 	str.w	r8, [r0, #4]
 */
static void usb_packet_write_from_queue(stm32_usb_descriptor_t *udp,
                                        output_queue_t *oqp, size_t n) {
  size_t nhw;
  syssts_t sts;
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 800338c:	f102 5200 	add.w	r2, r2, #536870912	; 0x20000000
 8003390:	f502 5240 	add.w	r2, r2, #12288	; 0x3000

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  nhw = n / 2;
  while (nhw > 0) {
 8003394:	ea5f 0e58 	movs.w	lr, r8, lsr #1
 *                      not exceed the maximum packet size for this endpoint.
 *
 * @notapi
 */
static void usb_packet_write_from_queue(stm32_usb_descriptor_t *udp,
                                        output_queue_t *oqp, size_t n) {
 8003398:	460c      	mov	r4, r1
  size_t nhw;
  syssts_t sts;
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 800339a:	ea4f 0242 	mov.w	r2, r2, lsl #1

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  nhw = n / 2;
  while (nhw > 0) {
 800339e:	d018      	beq.n	80033d2 <usb_packet_write_from_queue+0x52>
 80033a0:	690f      	ldr	r7, [r1, #16]
 80033a2:	4616      	mov	r6, r2
 80033a4:	4670      	mov	r0, lr
    stm32_usb_pma_t w;

    w  = (stm32_usb_pma_t)*oqp->q_rdptr++;
 80033a6:	69a1      	ldr	r1, [r4, #24]
 80033a8:	1c4b      	adds	r3, r1, #1
    if (oqp->q_rdptr >= oqp->q_top)
 80033aa:	429f      	cmp	r7, r3
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  nhw = n / 2;
  while (nhw > 0) {
    stm32_usb_pma_t w;

    w  = (stm32_usb_pma_t)*oqp->q_rdptr++;
 80033ac:	61a3      	str	r3, [r4, #24]
    if (oqp->q_rdptr >= oqp->q_top)
      oqp->q_rdptr = oqp->q_buffer;
 80033ae:	bf98      	it	ls
 80033b0:	68e3      	ldrls	r3, [r4, #12]
  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  nhw = n / 2;
  while (nhw > 0) {
    stm32_usb_pma_t w;

    w  = (stm32_usb_pma_t)*oqp->q_rdptr++;
 80033b2:	7809      	ldrb	r1, [r1, #0]
    if (oqp->q_rdptr >= oqp->q_top)
      oqp->q_rdptr = oqp->q_buffer;
    w |= (stm32_usb_pma_t)*oqp->q_rdptr++ << 8;
 80033b4:	1c5d      	adds	r5, r3, #1
 80033b6:	61a5      	str	r5, [r4, #24]
 80033b8:	781b      	ldrb	r3, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top)
 80033ba:	42af      	cmp	r7, r5
    stm32_usb_pma_t w;

    w  = (stm32_usb_pma_t)*oqp->q_rdptr++;
    if (oqp->q_rdptr >= oqp->q_top)
      oqp->q_rdptr = oqp->q_buffer;
    w |= (stm32_usb_pma_t)*oqp->q_rdptr++ << 8;
 80033bc:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
    if (oqp->q_rdptr >= oqp->q_top)
      oqp->q_rdptr = oqp->q_buffer;
 80033c0:	bf9c      	itt	ls
 80033c2:	68e1      	ldrls	r1, [r4, #12]
 80033c4:	61a1      	strls	r1, [r4, #24]
  syssts_t sts;
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  nhw = n / 2;
  while (nhw > 0) {
 80033c6:	3801      	subs	r0, #1
    if (oqp->q_rdptr >= oqp->q_top)
      oqp->q_rdptr = oqp->q_buffer;
    w |= (stm32_usb_pma_t)*oqp->q_rdptr++ << 8;
    if (oqp->q_rdptr >= oqp->q_top)
      oqp->q_rdptr = oqp->q_buffer;
    *pmap++ = w;
 80033c8:	f846 3b04 	str.w	r3, [r6], #4
  syssts_t sts;
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  nhw = n / 2;
  while (nhw > 0) {
 80033cc:	d1eb      	bne.n	80033a6 <usb_packet_write_from_queue+0x26>
 80033ce:	eb02 028e 	add.w	r2, r2, lr, lsl #2
    *pmap++ = w;
    nhw--;
  }

  /* Last byte for odd numbers.*/
  if ((n & 1) != 0) {
 80033d2:	f018 0f01 	tst.w	r8, #1
 80033d6:	d00a      	beq.n	80033ee <usb_packet_write_from_queue+0x6e>
    *pmap = (stm32_usb_pma_t)*oqp->q_rdptr++;
 80033d8:	69a1      	ldr	r1, [r4, #24]
    if (oqp->q_rdptr >= oqp->q_top)
 80033da:	6920      	ldr	r0, [r4, #16]
    nhw--;
  }

  /* Last byte for odd numbers.*/
  if ((n & 1) != 0) {
    *pmap = (stm32_usb_pma_t)*oqp->q_rdptr++;
 80033dc:	1c4b      	adds	r3, r1, #1
 80033de:	61a3      	str	r3, [r4, #24]
    if (oqp->q_rdptr >= oqp->q_top)
 80033e0:	4283      	cmp	r3, r0
    nhw--;
  }

  /* Last byte for odd numbers.*/
  if ((n & 1) != 0) {
    *pmap = (stm32_usb_pma_t)*oqp->q_rdptr++;
 80033e2:	7809      	ldrb	r1, [r1, #0]
    if (oqp->q_rdptr >= oqp->q_top)
      oqp->q_rdptr = oqp->q_buffer;
 80033e4:	bf28      	it	cs
 80033e6:	68e3      	ldrcs	r3, [r4, #12]
    nhw--;
  }

  /* Last byte for odd numbers.*/
  if ((n & 1) != 0) {
    *pmap = (stm32_usb_pma_t)*oqp->q_rdptr++;
 80033e8:	6011      	str	r1, [r2, #0]
    if (oqp->q_rdptr >= oqp->q_top)
      oqp->q_rdptr = oqp->q_buffer;
 80033ea:	bf28      	it	cs
 80033ec:	61a3      	strcs	r3, [r4, #24]
 *
 * @xclass
 */
static inline syssts_t osalSysGetStatusAndLockX(void)  {

  return chSysGetStatusAndLockX();
 80033ee:	f7fd fe57 	bl	80010a0 <chSysGetStatusAndLockX>
  }

  /* Updating queue.*/
  sts = osalSysGetStatusAndLockX();

  oqp->q_counter += n;
 80033f2:	68a2      	ldr	r2, [r4, #8]
 80033f4:	4442      	add	r2, r8
 80033f6:	4605      	mov	r5, r0
 80033f8:	60a2      	str	r2, [r4, #8]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 80033fa:	4620      	mov	r0, r4
 80033fc:	2100      	movs	r1, #0
 80033fe:	f7fe f987 	bl	8001710 <chThdDequeueAllI>
 *
 * @xclass
 */
static inline void osalSysRestoreStatusX(syssts_t sts) {

  chSysRestoreStatusX(sts);
 8003402:	4628      	mov	r0, r5
  osalThreadDequeueAllI(&oqp->q_waiting, Q_OK);

  osalSysRestoreStatusX(sts);
}
 8003404:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8003408:	f7fd be5a 	b.w	80010c0 <chSysRestoreStatusX>
 800340c:	f3af 8000 	nop.w

08003410 <Vector168>:
 */
CH_IRQ_HANDLER(STM32_USB1_HP_HANDLER) {

  CH_IRQ_PROLOGUE();

  CH_IRQ_EPILOGUE();
 8003410:	f7fd bd76 	b.w	8000f00 <_port_irq_epilogue>
 8003414:	f3af 8000 	nop.w
 8003418:	f3af 8000 	nop.w
 800341c:	f3af 8000 	nop.w

08003420 <Vector16C>:
/**
 * @brief   USB low priority interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 8003420:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t istr;
  USBDriver *usbp = &USBD1;

  CH_IRQ_PROLOGUE();

  istr = STM32_USB->ISTR;
 8003424:	4bbc      	ldr	r3, [pc, #752]	; (8003718 <Vector16C+0x2f8>)
 8003426:	6c5c      	ldr	r4, [r3, #68]	; 0x44

  /* USB bus reset condition handling.*/
  if (istr & ISTR_RESET) {
 8003428:	0563      	lsls	r3, r4, #21
/**
 * @brief   USB low priority interrupt handler.
 *
 * @isr
 */
CH_IRQ_HANDLER(STM32_USB1_LP_HANDLER) {
 800342a:	b085      	sub	sp, #20
  CH_IRQ_PROLOGUE();

  istr = STM32_USB->ISTR;

  /* USB bus reset condition handling.*/
  if (istr & ISTR_RESET) {
 800342c:	f100 8195 	bmi.w	800375a <Vector16C+0x33a>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
    STM32_USB->ISTR = ~ISTR_RESET;
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
 8003430:	0527      	lsls	r7, r4, #20
 8003432:	d511      	bpl.n	8003458 <Vector16C+0x38>
    STM32_USB->CNTR |= CNTR_FSUSP;
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8003434:	f8df b2e4 	ldr.w	fp, [pc, #740]	; 800371c <Vector16C+0x2fc>
    STM32_USB->ISTR = ~ISTR_RESET;
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
    STM32_USB->CNTR |= CNTR_FSUSP;
 8003438:	4ab7      	ldr	r2, [pc, #732]	; (8003718 <Vector16C+0x2f8>)
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800343a:	f8db 1004 	ldr.w	r1, [fp, #4]
    STM32_USB->ISTR = ~ISTR_RESET;
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
    STM32_USB->CNTR |= CNTR_FSUSP;
 800343e:	6c13      	ldr	r3, [r2, #64]	; 0x40
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8003440:	680d      	ldr	r5, [r1, #0]
    STM32_USB->ISTR = ~ISTR_RESET;
  }

  /* USB bus SUSPEND condition handling.*/
  if (istr & ISTR_SUSP) {
    STM32_USB->CNTR |= CNTR_FSUSP;
 8003442:	f043 0308 	orr.w	r3, r3, #8
 8003446:	6413      	str	r3, [r2, #64]	; 0x40
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8003448:	b115      	cbz	r5, 8003450 <Vector16C+0x30>
 800344a:	4658      	mov	r0, fp
 800344c:	2103      	movs	r1, #3
 800344e:	47a8      	blx	r5
#if STM32_USB_LOW_POWER_ON_SUSPEND
    STM32_USB->CNTR |= CNTR_LP_MODE;
#endif
    STM32_USB->ISTR = ~ISTR_SUSP;
 8003450:	4bb1      	ldr	r3, [pc, #708]	; (8003718 <Vector16C+0x2f8>)
 8003452:	f46f 6200 	mvn.w	r2, #2048	; 0x800
 8003456:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
 8003458:	04e6      	lsls	r6, r4, #19
 800345a:	d508      	bpl.n	800346e <Vector16C+0x4e>
    uint32_t fnr = STM32_USB->FNR;
 800345c:	4bae      	ldr	r3, [pc, #696]	; (8003718 <Vector16C+0x2f8>)
 800345e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    if (!(fnr & FNR_RXDP)) {
 8003460:	0415      	lsls	r5, r2, #16
 8003462:	f140 816a 	bpl.w	800373a <Vector16C+0x31a>
      /* Just noise, going back in SUSPEND mode, reference manual 22.4.5,
         table 169.*/
      STM32_USB->CNTR |= CNTR_LP_MODE;
    }
#endif
    STM32_USB->ISTR = ~ISTR_WKUP;
 8003466:	4bac      	ldr	r3, [pc, #688]	; (8003718 <Vector16C+0x2f8>)
 8003468:	f46f 5280 	mvn.w	r2, #4096	; 0x1000
 800346c:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* SOF handling.*/
  if (istr & ISTR_SOF) {
 800346e:	05a0      	lsls	r0, r4, #22
 8003470:	d50b      	bpl.n	800348a <Vector16C+0x6a>
    _usb_isr_invoke_sof_cb(usbp);
 8003472:	f8df b2a8 	ldr.w	fp, [pc, #680]	; 800371c <Vector16C+0x2fc>
 8003476:	f8db 3004 	ldr.w	r3, [fp, #4]
 800347a:	68db      	ldr	r3, [r3, #12]
 800347c:	b10b      	cbz	r3, 8003482 <Vector16C+0x62>
 800347e:	4658      	mov	r0, fp
 8003480:	4798      	blx	r3
    STM32_USB->ISTR = ~ISTR_SOF;
 8003482:	4ba5      	ldr	r3, [pc, #660]	; (8003718 <Vector16C+0x2f8>)
 8003484:	f46f 7200 	mvn.w	r2, #512	; 0x200
 8003488:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
 800348a:	0421      	lsls	r1, r4, #16
 800348c:	f140 80d0 	bpl.w	8003630 <Vector16C+0x210>
 8003490:	f8df b288 	ldr.w	fp, [pc, #648]	; 800371c <Vector16C+0x2fc>
    if (epr & EPR_CTR_TX) {
      size_t transmitted;
      /* IN endpoint, transmission.*/
      EPR_CLEAR_CTR_TX(ep);

      transmitted = (size_t)USB_GET_DESCRIPTOR(ep)->TXCOUNT0;
 8003494:	f8df a280 	ldr.w	sl, [pc, #640]	; 8003718 <Vector16C+0x2f8>

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
    size_t n;
    uint32_t ep;
    uint32_t epr = STM32_USB->EPR[ep = istr & ISTR_EP_ID_MASK];
 8003498:	f004 040f 	and.w	r4, r4, #15
 800349c:	ea4f 0884 	mov.w	r8, r4, lsl #2
 80034a0:	f108 4580 	add.w	r5, r8, #1073741824	; 0x40000000
 80034a4:	f505 45b8 	add.w	r5, r5, #23552	; 0x5c00
    const USBEndpointConfig *epcp = usbp->epc[ep];
 80034a8:	1ca6      	adds	r6, r4, #2

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
    size_t n;
    uint32_t ep;
    uint32_t epr = STM32_USB->EPR[ep = istr & ISTR_EP_ID_MASK];
 80034aa:	f8d5 9000 	ldr.w	r9, [r5]
    const USBEndpointConfig *epcp = usbp->epc[ep];
 80034ae:	eb0b 0386 	add.w	r3, fp, r6, lsl #2

    if (epr & EPR_CTR_TX) {
 80034b2:	f019 0f80 	tst.w	r9, #128	; 0x80
  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
    size_t n;
    uint32_t ep;
    uint32_t epr = STM32_USB->EPR[ep = istr & ISTR_EP_ID_MASK];
    const USBEndpointConfig *epcp = usbp->epc[ep];
 80034b6:	685f      	ldr	r7, [r3, #4]

    if (epr & EPR_CTR_TX) {
 80034b8:	d063      	beq.n	8003582 <Vector16C+0x162>
      size_t transmitted;
      /* IN endpoint, transmission.*/
      EPR_CLEAR_CTR_TX(ep);
 80034ba:	682b      	ldr	r3, [r5, #0]

      transmitted = (size_t)USB_GET_DESCRIPTOR(ep)->TXCOUNT0;
      epcp->in_state->txcnt  += transmitted;
 80034bc:	f8d7 e014 	ldr.w	lr, [r7, #20]
    const USBEndpointConfig *epcp = usbp->epc[ep];

    if (epr & EPR_CTR_TX) {
      size_t transmitted;
      /* IN endpoint, transmission.*/
      EPR_CLEAR_CTR_TX(ep);
 80034c0:	f423 4378 	bic.w	r3, r3, #63488	; 0xf800
 80034c4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80034c8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80034cc:	602b      	str	r3, [r5, #0]

      transmitted = (size_t)USB_GET_DESCRIPTOR(ep)->TXCOUNT0;
 80034ce:	f8da 3050 	ldr.w	r3, [sl, #80]	; 0x50
      epcp->in_state->txcnt  += transmitted;
 80034d2:	f8de 1008 	ldr.w	r1, [lr, #8]
      n = epcp->in_state->txsize - epcp->in_state->txcnt;
 80034d6:	f8de 2004 	ldr.w	r2, [lr, #4]
 80034da:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 80034de:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
    if (epr & EPR_CTR_TX) {
      size_t transmitted;
      /* IN endpoint, transmission.*/
      EPR_CLEAR_CTR_TX(ep);

      transmitted = (size_t)USB_GET_DESCRIPTOR(ep)->TXCOUNT0;
 80034e2:	00e0      	lsls	r0, r4, #3
 80034e4:	4403      	add	r3, r0
 80034e6:	005b      	lsls	r3, r3, #1
 80034e8:	685b      	ldr	r3, [r3, #4]
      epcp->in_state->txcnt  += transmitted;
 80034ea:	4419      	add	r1, r3
 80034ec:	f8ce 1008 	str.w	r1, [lr, #8]
      n = epcp->in_state->txsize - epcp->in_state->txcnt;
      if (n > 0) {
 80034f0:	1a51      	subs	r1, r2, r1
 80034f2:	f000 80ba 	beq.w	800366a <Vector16C+0x24a>
        /* Transfer not completed, there are more packets to send.*/
        if (n > epcp->in_maxsize)
 80034f6:	8a3a      	ldrh	r2, [r7, #16]
          n = epcp->in_maxsize;

        if (epcp->in_state->txqueued)
 80034f8:	f89e c000 	ldrb.w	ip, [lr]
 80034fc:	428a      	cmp	r2, r1
 80034fe:	bf28      	it	cs
 8003500:	460a      	movcs	r2, r1
 8003502:	f1bc 0f00 	cmp.w	ip, #0
 8003506:	f040 810b 	bne.w	8003720 <Vector16C+0x300>
          usb_packet_write_from_queue(USB_GET_DESCRIPTOR(ep),
                                      epcp->in_state->mode.queue.txqueue,
                                      n);
        else {
          epcp->in_state->mode.linear.txbuf += transmitted;
 800350a:	f8de 100c 	ldr.w	r1, [lr, #12]
 800350e:	eb01 0c03 	add.w	ip, r1, r3
 8003512:	f8ce c00c 	str.w	ip, [lr, #12]
          usb_packet_write_from_buffer(USB_GET_DESCRIPTOR(ep),
 8003516:	f8da 3050 	ldr.w	r3, [sl, #80]	; 0x50
 800351a:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800351e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8003522:	4418      	add	r0, r3
 8003524:	0040      	lsls	r0, r0, #1
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  n = (n + 1) / 2;
 8003526:	1c51      	adds	r1, r2, #1
 * @notapi
 */
static void usb_packet_write_from_buffer(stm32_usb_descriptor_t *udp,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8003528:	6803      	ldr	r3, [r0, #0]

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 800352a:	f8d0 e004 	ldr.w	lr, [r0, #4]
 800352e:	6042      	str	r2, [r0, #4]
 * @notapi
 */
static void usb_packet_write_from_buffer(stm32_usb_descriptor_t *udp,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 8003530:	f103 5200 	add.w	r2, r3, #536870912	; 0x20000000
 8003534:	f502 5240 	add.w	r2, r2, #12288	; 0x3000

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  n = (n + 1) / 2;
  while (n > 0) {
 8003538:	084b      	lsrs	r3, r1, #1
 * @notapi
 */
static void usb_packet_write_from_buffer(stm32_usb_descriptor_t *udp,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 800353a:	ea4f 0242 	mov.w	r2, r2, lsl #1

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  n = (n + 1) / 2;
  while (n > 0) {
 800353e:	d008      	beq.n	8003552 <Vector16C+0x132>
 8003540:	f1ac 0c02 	sub.w	ip, ip, #2
 8003544:	3a04      	subs	r2, #4
    /* Note, this line relies on the Cortex-M3/M4 ability to perform
       unaligned word accesses.*/
    *pmap++ = (stm32_usb_pma_t)*(const uint16_t *)buf;
 8003546:	f83c 1f02 	ldrh.w	r1, [ip, #2]!
 800354a:	f842 1f04 	str.w	r1, [r2, #4]!
                                         size_t n) {
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  n = (n + 1) / 2;
  while (n > 0) {
 800354e:	3b01      	subs	r3, #1
 8003550:	d1f9      	bne.n	8003546 <Vector16C+0x126>
 8003552:	2320      	movs	r3, #32
 8003554:	f383 8811 	msr	BASEPRI, r3
 8003558:	f108 4880 	add.w	r8, r8, #1073741824	; 0x40000000
 800355c:	f508 48b8 	add.w	r8, r8, #23552	; 0x5c00
 8003560:	2200      	movs	r2, #0
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8003562:	f8d8 3000 	ldr.w	r3, [r8]
 8003566:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 800356a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800356e:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8003572:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003576:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800357a:	f8c8 3000 	str.w	r3, [r8]
 800357e:	f382 8811 	msr	BASEPRI, r2
      else {
        /* Transfer completed, invokes the callback.*/
        _usb_isr_invoke_in_cb(usbp, ep);
      }
    }
    if (epr & EPR_CTR_RX) {
 8003582:	f419 4f00 	tst.w	r9, #32768	; 0x8000
 8003586:	d04e      	beq.n	8003626 <Vector16C+0x206>
      EPR_CLEAR_CTR_RX(ep);
 8003588:	682b      	ldr	r3, [r5, #0]
 800358a:	f423 4378 	bic.w	r3, r3, #63488	; 0xf800
 800358e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8003592:	f043 0380 	orr.w	r3, r3, #128	; 0x80
      /* OUT endpoint, receive.*/
      if (epr & EPR_SETUP) {
 8003596:	f419 6f00 	tst.w	r9, #2048	; 0x800
        /* Transfer completed, invokes the callback.*/
        _usb_isr_invoke_in_cb(usbp, ep);
      }
    }
    if (epr & EPR_CTR_RX) {
      EPR_CLEAR_CTR_RX(ep);
 800359a:	602b      	str	r3, [r5, #0]
      /* OUT endpoint, receive.*/
      if (epr & EPR_SETUP) {
 800359c:	d15d      	bne.n	800365a <Vector16C+0x23a>
        /* Setup packets handling, setup packets are handled using a
           specific callback.*/
        _usb_isr_invoke_setup_cb(usbp, ep);
      }
      else {
        stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 800359e:	f8da 3050 	ldr.w	r3, [sl, #80]	; 0x50
        n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;

        /* Reads the packet into the defined buffer.*/
        if (epcp->out_state->rxqueued)
 80035a2:	69b9      	ldr	r1, [r7, #24]
 80035a4:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 80035a8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
        /* Setup packets handling, setup packets are handled using a
           specific callback.*/
        _usb_isr_invoke_setup_cb(usbp, ep);
      }
      else {
        stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
 80035ac:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 80035b0:	005b      	lsls	r3, r3, #1
        n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;

        /* Reads the packet into the defined buffer.*/
        if (epcp->out_state->rxqueued)
 80035b2:	780a      	ldrb	r2, [r1, #0]
           specific callback.*/
        _usb_isr_invoke_setup_cb(usbp, ep);
      }
      else {
        stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
        n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;
 80035b4:	68d8      	ldr	r0, [r3, #12]
 80035b6:	9001      	str	r0, [sp, #4]
 80035b8:	f3c0 0809 	ubfx	r8, r0, #0, #10

        /* Reads the packet into the defined buffer.*/
        if (epcp->out_state->rxqueued)
 80035bc:	2a00      	cmp	r2, #0
 80035be:	d160      	bne.n	8003682 <Vector16C+0x262>
 *
 * @notapi
 */
static void usb_packet_read_to_buffer(stm32_usb_descriptor_t *udp,
                                      uint8_t *buf, size_t n) {
  stm32_usb_pma_t *pmap= USB_ADDR2PTR(udp->RXADDR0);
 80035c0:	689a      	ldr	r2, [r3, #8]
        if (epcp->out_state->rxqueued)
          usb_packet_read_to_queue(udp,
                                   epcp->out_state->mode.queue.rxqueue,
                                   n);
        else {
          usb_packet_read_to_buffer(udp,
 80035c2:	68c8      	ldr	r0, [r1, #12]
 *
 * @notapi
 */
static void usb_packet_read_to_buffer(stm32_usb_descriptor_t *udp,
                                      uint8_t *buf, size_t n) {
  stm32_usb_pma_t *pmap= USB_ADDR2PTR(udp->RXADDR0);
 80035c4:	f102 5200 	add.w	r2, r2, #536870912	; 0x20000000

  n = (n + 1) / 2;
 80035c8:	f108 0301 	add.w	r3, r8, #1
 *
 * @notapi
 */
static void usb_packet_read_to_buffer(stm32_usb_descriptor_t *udp,
                                      uint8_t *buf, size_t n) {
  stm32_usb_pma_t *pmap= USB_ADDR2PTR(udp->RXADDR0);
 80035cc:	f502 5240 	add.w	r2, r2, #12288	; 0x3000

  n = (n + 1) / 2;
  while (n > 0) {
 80035d0:	085b      	lsrs	r3, r3, #1
 *
 * @notapi
 */
static void usb_packet_read_to_buffer(stm32_usb_descriptor_t *udp,
                                      uint8_t *buf, size_t n) {
  stm32_usb_pma_t *pmap= USB_ADDR2PTR(udp->RXADDR0);
 80035d2:	ea4f 0242 	mov.w	r2, r2, lsl #1

  n = (n + 1) / 2;
  while (n > 0) {
 80035d6:	d009      	beq.n	80035ec <Vector16C+0x1cc>
 80035d8:	468e      	mov	lr, r1
    /* Note, this line relies on the Cortex-M3/M4 ability to perform
       unaligned word accesses.*/
    *(uint16_t *)buf = (uint16_t)*pmap++;
 80035da:	f852 1b04 	ldr.w	r1, [r2], #4
 80035de:	f820 1b02 	strh.w	r1, [r0], #2
static void usb_packet_read_to_buffer(stm32_usb_descriptor_t *udp,
                                      uint8_t *buf, size_t n) {
  stm32_usb_pma_t *pmap= USB_ADDR2PTR(udp->RXADDR0);

  n = (n + 1) / 2;
  while (n > 0) {
 80035e2:	3b01      	subs	r3, #1
 80035e4:	d1f9      	bne.n	80035da <Vector16C+0x1ba>
 80035e6:	f8de 000c 	ldr.w	r0, [lr, #12]
 80035ea:	4671      	mov	r1, lr
                                   n);
        else {
          usb_packet_read_to_buffer(udp,
                                    epcp->out_state->mode.linear.rxbuf,
                                    n);
          epcp->out_state->mode.linear.rxbuf += n;
 80035ec:	4440      	add	r0, r8
 80035ee:	60c8      	str	r0, [r1, #12]
        }
        /* Transaction data updated.*/
        epcp->out_state->rxcnt              += n;
        epcp->out_state->rxsize             -= n;
        epcp->out_state->rxpkts             -= 1;
 80035f0:	8a08      	ldrh	r0, [r1, #16]

        /* The transaction is completed if the specified number of packets
           has been received or the current packet is a short packet.*/
        if ((n < epcp->out_maxsize) || (epcp->out_state->rxpkts == 0)) {
 80035f2:	8a7f      	ldrh	r7, [r7, #18]
                                    epcp->out_state->mode.linear.rxbuf,
                                    n);
          epcp->out_state->mode.linear.rxbuf += n;
        }
        /* Transaction data updated.*/
        epcp->out_state->rxcnt              += n;
 80035f4:	688a      	ldr	r2, [r1, #8]
        epcp->out_state->rxsize             -= n;
 80035f6:	684b      	ldr	r3, [r1, #4]
        epcp->out_state->rxpkts             -= 1;
 80035f8:	3801      	subs	r0, #1
 80035fa:	b280      	uxth	r0, r0
                                    epcp->out_state->mode.linear.rxbuf,
                                    n);
          epcp->out_state->mode.linear.rxbuf += n;
        }
        /* Transaction data updated.*/
        epcp->out_state->rxcnt              += n;
 80035fc:	4442      	add	r2, r8
        epcp->out_state->rxsize             -= n;
 80035fe:	ebc8 0303 	rsb	r3, r8, r3
        epcp->out_state->rxpkts             -= 1;

        /* The transaction is completed if the specified number of packets
           has been received or the current packet is a short packet.*/
        if ((n < epcp->out_maxsize) || (epcp->out_state->rxpkts == 0)) {
 8003602:	45b8      	cmp	r8, r7
          epcp->out_state->mode.linear.rxbuf += n;
        }
        /* Transaction data updated.*/
        epcp->out_state->rxcnt              += n;
        epcp->out_state->rxsize             -= n;
        epcp->out_state->rxpkts             -= 1;
 8003604:	8208      	strh	r0, [r1, #16]
                                    epcp->out_state->mode.linear.rxbuf,
                                    n);
          epcp->out_state->mode.linear.rxbuf += n;
        }
        /* Transaction data updated.*/
        epcp->out_state->rxcnt              += n;
 8003606:	608a      	str	r2, [r1, #8]
        epcp->out_state->rxsize             -= n;
 8003608:	604b      	str	r3, [r1, #4]
        epcp->out_state->rxpkts             -= 1;

        /* The transaction is completed if the specified number of packets
           has been received or the current packet is a short packet.*/
        if ((n < epcp->out_maxsize) || (epcp->out_state->rxpkts == 0)) {
 800360a:	d316      	bcc.n	800363a <Vector16C+0x21a>
 800360c:	b1a8      	cbz	r0, 800363a <Vector16C+0x21a>
          /* Transfer complete, invokes the callback.*/
          _usb_isr_invoke_out_cb(usbp, ep);
        }
        else {
          /* Transfer not complete, there are more packets to receive.*/
          EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 800360e:	682b      	ldr	r3, [r5, #0]
 8003610:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8003614:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003618:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 800361c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003620:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003624:	602b      	str	r3, [r5, #0]
        }
      }
    }
    istr = STM32_USB->ISTR;
 8003626:	f8da 4044 	ldr.w	r4, [sl, #68]	; 0x44
    _usb_isr_invoke_sof_cb(usbp);
    STM32_USB->ISTR = ~ISTR_SOF;
  }

  /* Endpoint events handling.*/
  while (istr & ISTR_CTR) {
 800362a:	0423      	lsls	r3, r4, #16
 800362c:	f53f af34 	bmi.w	8003498 <Vector16C+0x78>
    }
    istr = STM32_USB->ISTR;
  }

  CH_IRQ_EPILOGUE();
}
 8003630:	b005      	add	sp, #20
 8003632:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      }
    }
    istr = STM32_USB->ISTR;
  }

  CH_IRQ_EPILOGUE();
 8003636:	f7fd bc63 	b.w	8000f00 <_port_irq_epilogue>

        /* The transaction is completed if the specified number of packets
           has been received or the current packet is a short packet.*/
        if ((n < epcp->out_maxsize) || (epcp->out_state->rxpkts == 0)) {
          /* Transfer complete, invokes the callback.*/
          _usb_isr_invoke_out_cb(usbp, ep);
 800363a:	eb0b 0686 	add.w	r6, fp, r6, lsl #2
 800363e:	f8bb 300a 	ldrh.w	r3, [fp, #10]
 8003642:	6872      	ldr	r2, [r6, #4]
 8003644:	4835      	ldr	r0, [pc, #212]	; (800371c <Vector16C+0x2fc>)
 8003646:	68d2      	ldr	r2, [r2, #12]
 8003648:	2101      	movs	r1, #1
 800364a:	40a1      	lsls	r1, r4
 800364c:	ea23 0301 	bic.w	r3, r3, r1
 8003650:	f8ab 300a 	strh.w	r3, [fp, #10]
 8003654:	4621      	mov	r1, r4
 8003656:	4790      	blx	r2
 8003658:	e7e5      	b.n	8003626 <Vector16C+0x206>
      EPR_CLEAR_CTR_RX(ep);
      /* OUT endpoint, receive.*/
      if (epr & EPR_SETUP) {
        /* Setup packets handling, setup packets are handled using a
           specific callback.*/
        _usb_isr_invoke_setup_cb(usbp, ep);
 800365a:	eb0b 0686 	add.w	r6, fp, r6, lsl #2
 800365e:	4621      	mov	r1, r4
 8003660:	6873      	ldr	r3, [r6, #4]
 8003662:	482e      	ldr	r0, [pc, #184]	; (800371c <Vector16C+0x2fc>)
 8003664:	685b      	ldr	r3, [r3, #4]
 8003666:	4798      	blx	r3
 8003668:	e7dd      	b.n	8003626 <Vector16C+0x206>
        usb_lld_start_in(usbp, ep);
        osalSysUnlockFromISR();
      }
      else {
        /* Transfer completed, invokes the callback.*/
        _usb_isr_invoke_in_cb(usbp, ep);
 800366a:	4b2c      	ldr	r3, [pc, #176]	; (800371c <Vector16C+0x2fc>)
 800366c:	482b      	ldr	r0, [pc, #172]	; (800371c <Vector16C+0x2fc>)
 800366e:	891b      	ldrh	r3, [r3, #8]
 8003670:	68ba      	ldr	r2, [r7, #8]
 8003672:	2101      	movs	r1, #1
 8003674:	40a1      	lsls	r1, r4
 8003676:	ea23 0301 	bic.w	r3, r3, r1
 800367a:	8103      	strh	r3, [r0, #8]
 800367c:	4621      	mov	r1, r4
 800367e:	4790      	blx	r2
 8003680:	e77f      	b.n	8003582 <Vector16C+0x162>
 * @notapi
 */
static void usb_packet_read_to_queue(stm32_usb_descriptor_t *udp,
                                     input_queue_t *iqp, size_t n) {
  size_t nhw;
  stm32_usb_pma_t *pmap= USB_ADDR2PTR(udp->RXADDR0);
 8003682:	689b      	ldr	r3, [r3, #8]
        stm32_usb_descriptor_t *udp = USB_GET_DESCRIPTOR(ep);
        n = (size_t)udp->RXCOUNT0 & RXCOUNT_COUNT_MASK;

        /* Reads the packet into the defined buffer.*/
        if (epcp->out_state->rxqueued)
          usb_packet_read_to_queue(udp,
 8003684:	68c8      	ldr	r0, [r1, #12]
 * @notapi
 */
static void usb_packet_read_to_queue(stm32_usb_descriptor_t *udp,
                                     input_queue_t *iqp, size_t n) {
  size_t nhw;
  stm32_usb_pma_t *pmap= USB_ADDR2PTR(udp->RXADDR0);
 8003686:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800368a:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800368e:	005b      	lsls	r3, r3, #1

  nhw = n / 2;
  while (nhw > 0) {
 8003690:	ea5f 0258 	movs.w	r2, r8, lsr #1
 * @notapi
 */
static void usb_packet_read_to_queue(stm32_usb_descriptor_t *udp,
                                     input_queue_t *iqp, size_t n) {
  size_t nhw;
  stm32_usb_pma_t *pmap= USB_ADDR2PTR(udp->RXADDR0);
 8003694:	9302      	str	r3, [sp, #8]

  nhw = n / 2;
  while (nhw > 0) {
 8003696:	9203      	str	r2, [sp, #12]
 8003698:	d021      	beq.n	80036de <Vector16C+0x2be>
 800369a:	4611      	mov	r1, r2
 800369c:	469e      	mov	lr, r3
    stm32_usb_pma_t w;

    w = *pmap++;
    *iqp->q_wrptr++ = (uint8_t)w;
 800369e:	6943      	ldr	r3, [r0, #20]

  nhw = n / 2;
  while (nhw > 0) {
    stm32_usb_pma_t w;

    w = *pmap++;
 80036a0:	f85e 2b04 	ldr.w	r2, [lr], #4
    *iqp->q_wrptr++ = (uint8_t)w;
 80036a4:	f103 0901 	add.w	r9, r3, #1
 80036a8:	f8c0 9014 	str.w	r9, [r0, #20]
 80036ac:	701a      	strb	r2, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top)
 80036ae:	6903      	ldr	r3, [r0, #16]
      iqp->q_wrptr = iqp->q_buffer;
    *iqp->q_wrptr++ = (uint8_t)(w >> 8);
 80036b0:	ea4f 2c12 	mov.w	ip, r2, lsr #8
  while (nhw > 0) {
    stm32_usb_pma_t w;

    w = *pmap++;
    *iqp->q_wrptr++ = (uint8_t)w;
    if (iqp->q_wrptr >= iqp->q_top)
 80036b4:	6942      	ldr	r2, [r0, #20]
 80036b6:	429a      	cmp	r2, r3
      iqp->q_wrptr = iqp->q_buffer;
 80036b8:	bf28      	it	cs
 80036ba:	68c2      	ldrcs	r2, [r0, #12]
    *iqp->q_wrptr++ = (uint8_t)(w >> 8);
 80036bc:	1c53      	adds	r3, r2, #1
 80036be:	6143      	str	r3, [r0, #20]
 80036c0:	f882 c000 	strb.w	ip, [r2]
    if (iqp->q_wrptr >= iqp->q_top)
 80036c4:	6903      	ldr	r3, [r0, #16]
 80036c6:	6942      	ldr	r2, [r0, #20]
 80036c8:	429a      	cmp	r2, r3
      iqp->q_wrptr = iqp->q_buffer;
 80036ca:	bf24      	itt	cs
 80036cc:	68c3      	ldrcs	r3, [r0, #12]
 80036ce:	6143      	strcs	r3, [r0, #20]
                                     input_queue_t *iqp, size_t n) {
  size_t nhw;
  stm32_usb_pma_t *pmap= USB_ADDR2PTR(udp->RXADDR0);

  nhw = n / 2;
  while (nhw > 0) {
 80036d0:	3901      	subs	r1, #1
 80036d2:	d1e4      	bne.n	800369e <Vector16C+0x27e>
 80036d4:	9b02      	ldr	r3, [sp, #8]
 80036d6:	9a03      	ldr	r2, [sp, #12]
 80036d8:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80036dc:	9302      	str	r3, [sp, #8]
    if (iqp->q_wrptr >= iqp->q_top)
      iqp->q_wrptr = iqp->q_buffer;
    nhw--;
  }
  /* Last byte for odd numbers.*/
  if ((n & 1) != 0) {
 80036de:	9b01      	ldr	r3, [sp, #4]
 80036e0:	07da      	lsls	r2, r3, #31
 80036e2:	d50b      	bpl.n	80036fc <Vector16C+0x2dc>
    *iqp->q_wrptr++ = (uint8_t)*pmap;
 80036e4:	6943      	ldr	r3, [r0, #20]
 80036e6:	9a02      	ldr	r2, [sp, #8]
 80036e8:	1c59      	adds	r1, r3, #1
 80036ea:	6812      	ldr	r2, [r2, #0]
 80036ec:	6141      	str	r1, [r0, #20]
 80036ee:	701a      	strb	r2, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top)
 80036f0:	6903      	ldr	r3, [r0, #16]
 80036f2:	6942      	ldr	r2, [r0, #20]
 80036f4:	429a      	cmp	r2, r3
      iqp->q_wrptr = iqp->q_buffer;
 80036f6:	bf24      	itt	cs
 80036f8:	68c3      	ldrcs	r3, [r0, #12]
 80036fa:	6143      	strcs	r3, [r0, #20]
 80036fc:	2320      	movs	r3, #32
 80036fe:	f383 8811 	msr	BASEPRI, r3
  }

  /* Updating queue.*/
  osalSysLockFromISR();

  iqp->q_counter += n;
 8003702:	6883      	ldr	r3, [r0, #8]
 8003704:	4443      	add	r3, r8
 8003706:	6083      	str	r3, [r0, #8]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8003708:	2100      	movs	r1, #0
 800370a:	f7fe f801 	bl	8001710 <chThdDequeueAllI>
 800370e:	2300      	movs	r3, #0
 8003710:	f383 8811 	msr	BASEPRI, r3
 8003714:	69b9      	ldr	r1, [r7, #24]
 8003716:	e76b      	b.n	80035f0 <Vector16C+0x1d0>
 8003718:	40005c00 	.word	0x40005c00
 800371c:	20001218 	.word	0x20001218
        /* Transfer not completed, there are more packets to send.*/
        if (n > epcp->in_maxsize)
          n = epcp->in_maxsize;

        if (epcp->in_state->txqueued)
          usb_packet_write_from_queue(USB_GET_DESCRIPTOR(ep),
 8003720:	f8da 3050 	ldr.w	r3, [sl, #80]	; 0x50
 8003724:	f8de 100c 	ldr.w	r1, [lr, #12]
 8003728:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800372c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8003730:	4418      	add	r0, r3
 8003732:	0040      	lsls	r0, r0, #1
 8003734:	f7ff fe24 	bl	8003380 <usb_packet_write_from_queue>
 8003738:	e70b      	b.n	8003552 <Vector16C+0x132>
  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
    uint32_t fnr = STM32_USB->FNR;
    if (!(fnr & FNR_RXDP)) {
      STM32_USB->CNTR &= ~CNTR_FSUSP;
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 800373a:	f8df b044 	ldr.w	fp, [pc, #68]	; 8003780 <Vector16C+0x360>

  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
    uint32_t fnr = STM32_USB->FNR;
    if (!(fnr & FNR_RXDP)) {
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 800373e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8003740:	f8db 1004 	ldr.w	r1, [fp, #4]
 8003744:	680d      	ldr	r5, [r1, #0]

  /* USB bus WAKEUP condition handling.*/
  if (istr & ISTR_WKUP) {
    uint32_t fnr = STM32_USB->FNR;
    if (!(fnr & FNR_RXDP)) {
      STM32_USB->CNTR &= ~CNTR_FSUSP;
 8003746:	f022 0208 	bic.w	r2, r2, #8
 800374a:	641a      	str	r2, [r3, #64]	; 0x40
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 800374c:	2d00      	cmp	r5, #0
 800374e:	f43f ae8a 	beq.w	8003466 <Vector16C+0x46>
 8003752:	4658      	mov	r0, fp
 8003754:	2104      	movs	r1, #4
 8003756:	47a8      	blx	r5
 8003758:	e685      	b.n	8003466 <Vector16C+0x46>

  istr = STM32_USB->ISTR;

  /* USB bus reset condition handling.*/
  if (istr & ISTR_RESET) {
    _usb_reset(usbp);
 800375a:	f8df b024 	ldr.w	fp, [pc, #36]	; 8003780 <Vector16C+0x360>
 800375e:	4658      	mov	r0, fp
 8003760:	f7fe fd3e 	bl	80021e0 <_usb_reset>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8003764:	f8db 3004 	ldr.w	r3, [fp, #4]
 8003768:	681b      	ldr	r3, [r3, #0]
 800376a:	b113      	cbz	r3, 8003772 <Vector16C+0x352>
 800376c:	4658      	mov	r0, fp
 800376e:	2100      	movs	r1, #0
 8003770:	4798      	blx	r3
    STM32_USB->ISTR = ~ISTR_RESET;
 8003772:	4b02      	ldr	r3, [pc, #8]	; (800377c <Vector16C+0x35c>)
 8003774:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8003778:	645a      	str	r2, [r3, #68]	; 0x44
 800377a:	e659      	b.n	8003430 <Vector16C+0x10>
 800377c:	40005c00 	.word	0x40005c00
 8003780:	20001218 	.word	0x20001218
 8003784:	f3af 8000 	nop.w
 8003788:	f3af 8000 	nop.w
 800378c:	f3af 8000 	nop.w

08003790 <usb_lld_init>:
 * @notapi
 */
void usb_lld_init(void) {

  /* Driver initialization.*/
  usbObjectInit(&USBD1);
 8003790:	4801      	ldr	r0, [pc, #4]	; (8003798 <usb_lld_init+0x8>)
 8003792:	f7fe bcdd 	b.w	8002150 <usbObjectInit>
 8003796:	bf00      	nop
 8003798:	20001218 	.word	0x20001218
 800379c:	f3af 8000 	nop.w

080037a0 <usb_lld_set_address>:
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {

  STM32_USB->DADDR = (uint32_t)(usbp->address) | DADDR_EF;
 80037a0:	f890 307e 	ldrb.w	r3, [r0, #126]	; 0x7e
 80037a4:	4a02      	ldr	r2, [pc, #8]	; (80037b0 <usb_lld_set_address+0x10>)
 80037a6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80037aa:	64d3      	str	r3, [r2, #76]	; 0x4c
 80037ac:	4770      	bx	lr
 80037ae:	bf00      	nop
 80037b0:	40005c00 	.word	0x40005c00
 80037b4:	f3af 8000 	nop.w
 80037b8:	f3af 8000 	nop.w
 80037bc:	f3af 8000 	nop.w

080037c0 <usb_lld_init_endpoint>:
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint16_t nblocks, epr;
  stm32_usb_descriptor_t *dp;
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80037c0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 80037c4:	b4f0      	push	{r4, r5, r6, r7}
  uint16_t nblocks, epr;
  stm32_usb_descriptor_t *dp;
  const USBEndpointConfig *epcp = usbp->epc[ep];
 80037c6:	68db      	ldr	r3, [r3, #12]

  /* Setting the endpoint type.*/
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 80037c8:	681a      	ldr	r2, [r3, #0]
 80037ca:	f002 0203 	and.w	r2, r2, #3
 80037ce:	3a01      	subs	r2, #1
 80037d0:	2a02      	cmp	r2, #2
 80037d2:	bf9c      	itt	ls
 80037d4:	4c2e      	ldrls	r4, [pc, #184]	; (8003890 <usb_lld_init_endpoint+0xd0>)
 80037d6:	f834 6012 	ldrhls.w	r6, [r4, r2, lsl #1]
  default:
    epr = EPR_EP_TYPE_CONTROL;
  }

  /* IN endpoint initially in NAK mode.*/
  if (epcp->in_cb != NULL)
 80037da:	689a      	ldr	r2, [r3, #8]
  uint16_t nblocks, epr;
  stm32_usb_descriptor_t *dp;
  const USBEndpointConfig *epcp = usbp->epc[ep];

  /* Setting the endpoint type.*/
  switch (epcp->ep_mode & USB_EP_MODE_TYPE) {
 80037dc:	bf88      	it	hi
 80037de:	f44f 7600 	movhi.w	r6, #512	; 0x200
  default:
    epr = EPR_EP_TYPE_CONTROL;
  }

  /* IN endpoint initially in NAK mode.*/
  if (epcp->in_cb != NULL)
 80037e2:	b10a      	cbz	r2, 80037e8 <usb_lld_init_endpoint+0x28>
    epr |= EPR_STAT_TX_NAK;
 80037e4:	f046 0620 	orr.w	r6, r6, #32

  /* OUT endpoint initially in NAK mode.*/
  if (epcp->out_cb != NULL)
 80037e8:	68da      	ldr	r2, [r3, #12]
 80037ea:	b10a      	cbz	r2, 80037f0 <usb_lld_init_endpoint+0x30>
    epr |= EPR_STAT_RX_NAK;
 80037ec:	f446 5600 	orr.w	r6, r6, #8192	; 0x2000

  /* EPxR register setup.*/
  EPR_SET(ep, epr | ep);
 80037f0:	ea46 0401 	orr.w	r4, r6, r1
 80037f4:	f424 4478 	bic.w	r4, r4, #63488	; 0xf800
 80037f8:	008a      	lsls	r2, r1, #2
 80037fa:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 80037fe:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8003802:	f502 42b8 	add.w	r2, r2, #23552	; 0x5c00
 8003806:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
 800380a:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 800380e:	6014      	str	r4, [r2, #0]
  EPR_TOGGLE(ep, epr);
 8003810:	6814      	ldr	r4, [r2, #0]

  /* Endpoint size and address initialization.*/
  if (epcp->out_maxsize > 62)
 8003812:	8a5d      	ldrh	r5, [r3, #18]
  if (epcp->out_cb != NULL)
    epr |= EPR_STAT_RX_NAK;

  /* EPxR register setup.*/
  EPR_SET(ep, epr | ep);
  EPR_TOGGLE(ep, epr);
 8003814:	f647 0770 	movw	r7, #30832	; 0x7870
 8003818:	4037      	ands	r7, r6
 800381a:	407c      	eors	r4, r7
 800381c:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
 8003820:	f044 0480 	orr.w	r4, r4, #128	; 0x80

  /* Endpoint size and address initialization.*/
  if (epcp->out_maxsize > 62)
 8003824:	2d3e      	cmp	r5, #62	; 0x3e
  if (epcp->out_cb != NULL)
    epr |= EPR_STAT_RX_NAK;

  /* EPxR register setup.*/
  EPR_SET(ep, epr | ep);
  EPR_TOGGLE(ep, epr);
 8003826:	6014      	str	r4, [r2, #0]

  /* Endpoint size and address initialization.*/
  if (epcp->out_maxsize > 62)
    nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
 8003828:	f105 34ff 	add.w	r4, r5, #4294967295
  /* EPxR register setup.*/
  EPR_SET(ep, epr | ep);
  EPR_TOGGLE(ep, epr);

  /* Endpoint size and address initialization.*/
  if (epcp->out_maxsize > 62)
 800382c:	d826      	bhi.n	800387c <usb_lld_init_endpoint+0xbc>
    nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
              0x8000;
  else
    nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
 800382e:	f044 0401 	orr.w	r4, r4, #1
 8003832:	3401      	adds	r4, #1
 8003834:	eb04 74d4 	add.w	r4, r4, r4, lsr #31
 8003838:	0264      	lsls	r4, r4, #9
 800383a:	f404 447c 	and.w	r4, r4, #64512	; 0xfc00
  dp = USB_GET_DESCRIPTOR(ep);
 800383e:	4a15      	ldr	r2, [pc, #84]	; (8003894 <usb_lld_init_endpoint+0xd4>)
  dp->TXCOUNT0 = 0;
  dp->RXCOUNT0 = nblocks;
  dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8003840:	8a1e      	ldrh	r6, [r3, #16]
  if (epcp->out_maxsize > 62)
    nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
              0x8000;
  else
    nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
  dp = USB_GET_DESCRIPTOR(ep);
 8003842:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8003844:	f102 5300 	add.w	r3, r2, #536870912	; 0x20000000
 8003848:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800384c:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8003850:	0049      	lsls	r1, r1, #1
  dp->TXCOUNT0 = 0;
 8003852:	2300      	movs	r3, #0
 8003854:	684a      	ldr	r2, [r1, #4]
 8003856:	604b      	str	r3, [r1, #4]
  dp->RXCOUNT0 = nblocks;
 8003858:	68cb      	ldr	r3, [r1, #12]
 800385a:	60cc      	str	r4, [r1, #12]
 * @param[in] size      size of the packet buffer to allocate
 */
static uint32_t usb_pm_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 800385c:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80
  usbp->pmnext += size;
 8003860:	1993      	adds	r3, r2, r6
 8003862:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
  else
    nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
  dp = USB_GET_DESCRIPTOR(ep);
  dp->TXCOUNT0 = 0;
  dp->RXCOUNT0 = nblocks;
  dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
 8003866:	680b      	ldr	r3, [r1, #0]
 8003868:	600a      	str	r2, [r1, #0]
 * @param[in] size      size of the packet buffer to allocate
 */
static uint32_t usb_pm_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 800386a:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
  usbp->pmnext += size;
 800386e:	441d      	add	r5, r3
 8003870:	f8c0 5080 	str.w	r5, [r0, #128]	; 0x80
    nblocks = ((((epcp->out_maxsize - 1) | 1) + 1) / 2) << 10;
  dp = USB_GET_DESCRIPTOR(ep);
  dp->TXCOUNT0 = 0;
  dp->RXCOUNT0 = nblocks;
  dp->TXADDR0  = usb_pm_alloc(usbp, epcp->in_maxsize);
  dp->RXADDR0  = usb_pm_alloc(usbp, epcp->out_maxsize);
 8003874:	688a      	ldr	r2, [r1, #8]
 8003876:	608b      	str	r3, [r1, #8]
}
 8003878:	bcf0      	pop	{r4, r5, r6, r7}
 800387a:	4770      	bx	lr
  EPR_SET(ep, epr | ep);
  EPR_TOGGLE(ep, epr);

  /* Endpoint size and address initialization.*/
  if (epcp->out_maxsize > 62)
    nblocks = (((((epcp->out_maxsize - 1) | 0x1f) + 1) / 32) << 10) |
 800387c:	f044 041f 	orr.w	r4, r4, #31
 8003880:	3401      	adds	r4, #1
 8003882:	1164      	asrs	r4, r4, #5
 8003884:	ea6f 64c4 	mvn.w	r4, r4, lsl #27
 8003888:	ea6f 4454 	mvn.w	r4, r4, lsr #17
 800388c:	b2a4      	uxth	r4, r4
 800388e:	e7d6      	b.n	800383e <usb_lld_init_endpoint+0x7e>
 8003890:	08006a00 	.word	0x08006a00
 8003894:	40005c00 	.word	0x40005c00
 8003898:	f3af 8000 	nop.w
 800389c:	f3af 8000 	nop.w

080038a0 <usb_lld_reset>:
  STM32_USB->DADDR  = DADDR_EF;
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
 80038a0:	6841      	ldr	r1, [r0, #4]
 */
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = 0;
 80038a2:	4b0e      	ldr	r3, [pc, #56]	; (80038dc <usb_lld_reset+0x3c>)
  STM32_USB->DADDR  = DADDR_EF;
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
 80038a4:	68c9      	ldr	r1, [r1, #12]
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 80038a6:	b5f0      	push	{r4, r5, r6, r7, lr}
  STM32_USB->DADDR  = DADDR_EF;
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
 80038a8:	2900      	cmp	r1, #0
 */
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = 0;
 80038aa:	f04f 0400 	mov.w	r4, #0

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
 80038ae:	4d0c      	ldr	r5, [pc, #48]	; (80038e0 <usb_lld_reset+0x40>)
 */
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = 0;
 80038b0:	651c      	str	r4, [r3, #80]	; 0x50
  cntr              = /*CNTR_ESOFM | */ CNTR_RESETM  | CNTR_SUSPM |
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
    cntr |= CNTR_SOFM;
 80038b2:	bf0c      	ite	eq
 80038b4:	f44f 471c 	moveq.w	r7, #39936	; 0x9c00
 80038b8:	f44f 471e 	movne.w	r7, #40448	; 0x9e00
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = 0;
  STM32_USB->ISTR   = 0;
  STM32_USB->DADDR  = DADDR_EF;
 80038bc:	f04f 0e80 	mov.w	lr, #128	; 0x80
 */
static void usb_pm_reset(USBDriver *usbp) {

  /* The first 64 bytes are reserved for the descriptors table. The effective
     available RAM for endpoint buffers is just 448 bytes.*/
  usbp->pmnext = 64;
 80038c0:	2640      	movs	r6, #64	; 0x40
void usb_lld_reset(USBDriver *usbp) {
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = 0;
  STM32_USB->ISTR   = 0;
 80038c2:	645c      	str	r4, [r3, #68]	; 0x44
  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
  usb_lld_init_endpoint(usbp, 0);
 80038c4:	4621      	mov	r1, r4
  uint32_t cntr;

  /* Post reset initialization.*/
  STM32_USB->BTABLE = 0;
  STM32_USB->ISTR   = 0;
  STM32_USB->DADDR  = DADDR_EF;
 80038c6:	f8c3 e04c 	str.w	lr, [r3, #76]	; 0x4c
                      CNTR_WKUPM | /*CNTR_ERRM | CNTR_PMAOVRM |*/ CNTR_CTRM;
  /* The SOF interrupt is only enabled if a callback is defined for
     this service because it is an high rate source.*/
  if (usbp->config->sof_cb != NULL)
    cntr |= CNTR_SOFM;
  STM32_USB->CNTR = cntr;
 80038ca:	641f      	str	r7, [r3, #64]	; 0x40
 */
static void usb_pm_reset(USBDriver *usbp) {

  /* The first 64 bytes are reserved for the descriptors table. The effective
     available RAM for endpoint buffers is just 448 bytes.*/
  usbp->pmnext = 64;
 80038cc:	f8c0 6080 	str.w	r6, [r0, #128]	; 0x80

  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
 80038d0:	60c5      	str	r5, [r0, #12]
  usb_lld_init_endpoint(usbp, 0);
}
 80038d2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  /* Resets the packet memory allocator.*/
  usb_pm_reset(usbp);

  /* EP0 initialization.*/
  usbp->epc[0] = &ep0config;
  usb_lld_init_endpoint(usbp, 0);
 80038d6:	f7ff bf73 	b.w	80037c0 <usb_lld_init_endpoint>
 80038da:	bf00      	nop
 80038dc:	40005c00 	.word	0x40005c00
 80038e0:	080069d0 	.word	0x080069d0
 80038e4:	f3af 8000 	nop.w
 80038e8:	f3af 8000 	nop.w
 80038ec:	f3af 8000 	nop.w

080038f0 <usb_lld_get_status_out>:
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) {
 80038f0:	4b05      	ldr	r3, [pc, #20]	; (8003908 <usb_lld_get_status_out+0x18>)
 80038f2:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 80038f6:	f410 5040 	ands.w	r0, r0, #12288	; 0x3000
 80038fa:	d004      	beq.n	8003906 <usb_lld_get_status_out+0x16>
 80038fc:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
  case EPR_STAT_RX_DIS:
    return EP_STATUS_DISABLED;
  case EPR_STAT_RX_STALL:
    return EP_STATUS_STALLED;
  default:
    return EP_STATUS_ACTIVE;
 8003900:	bf0c      	ite	eq
 8003902:	2001      	moveq	r0, #1
 8003904:	2002      	movne	r0, #2
  }
}
 8003906:	4770      	bx	lr
 8003908:	40005c00 	.word	0x40005c00
 800390c:	f3af 8000 	nop.w

08003910 <usb_lld_get_status_in>:
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  switch (STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) {
 8003910:	4b05      	ldr	r3, [pc, #20]	; (8003928 <usb_lld_get_status_in+0x18>)
 8003912:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 8003916:	f010 0030 	ands.w	r0, r0, #48	; 0x30
 800391a:	d003      	beq.n	8003924 <usb_lld_get_status_in+0x14>
 800391c:	2810      	cmp	r0, #16
  case EPR_STAT_TX_DIS:
    return EP_STATUS_DISABLED;
  case EPR_STAT_TX_STALL:
    return EP_STATUS_STALLED;
  default:
    return EP_STATUS_ACTIVE;
 800391e:	bf0c      	ite	eq
 8003920:	2001      	moveq	r0, #1
 8003922:	2002      	movne	r0, #2
  }
}
 8003924:	4770      	bx	lr
 8003926:	bf00      	nop
 8003928:	40005c00 	.word	0x40005c00
 800392c:	f3af 8000 	nop.w

08003930 <usb_lld_read_setup>:
  stm32_usb_pma_t *pmap;
  stm32_usb_descriptor_t *udp;
  uint32_t n;

  (void)usbp;
  udp = USB_GET_DESCRIPTOR(ep);
 8003930:	4b0b      	ldr	r3, [pc, #44]	; (8003960 <usb_lld_read_setup+0x30>)
 8003932:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8003934:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 8003938:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 800393c:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8003940:	0049      	lsls	r1, r1, #1
 8003942:	f102 0008 	add.w	r0, r2, #8
  pmap = USB_ADDR2PTR(udp->RXADDR0);
 8003946:	688b      	ldr	r3, [r1, #8]
 8003948:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 800394c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8003950:	005b      	lsls	r3, r3, #1
  for (n = 0; n < 4; n++) {
    *(uint16_t *)buf = (uint16_t)*pmap++;
 8003952:	f853 1b04 	ldr.w	r1, [r3], #4
 8003956:	f822 1b02 	strh.w	r1, [r2], #2
  uint32_t n;

  (void)usbp;
  udp = USB_GET_DESCRIPTOR(ep);
  pmap = USB_ADDR2PTR(udp->RXADDR0);
  for (n = 0; n < 4; n++) {
 800395a:	4282      	cmp	r2, r0
 800395c:	d1f9      	bne.n	8003952 <usb_lld_read_setup+0x22>
    *(uint16_t *)buf = (uint16_t)*pmap++;
    buf += 2;
  }
}
 800395e:	4770      	bx	lr
 8003960:	40005c00 	.word	0x40005c00
 8003964:	f3af 8000 	nop.w
 8003968:	f3af 8000 	nop.w
 800396c:	f3af 8000 	nop.w

08003970 <usb_lld_prepare_receive>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8003970:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8003974:	68c9      	ldr	r1, [r1, #12]
 8003976:	698a      	ldr	r2, [r1, #24]

  /* Transfer initialization.*/
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
 8003978:	6853      	ldr	r3, [r2, #4]
 800397a:	b133      	cbz	r3, 800398a <usb_lld_prepare_receive+0x1a>
    osp->rxpkts = 1;
  else
    osp->rxpkts = (uint16_t)((osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 800397c:	8a49      	ldrh	r1, [r1, #18]
 800397e:	3b01      	subs	r3, #1
 8003980:	440b      	add	r3, r1
 8003982:	fbb3 f3f1 	udiv	r3, r3, r1
 8003986:	8213      	strh	r3, [r2, #16]
 8003988:	4770      	bx	lr
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  /* Transfer initialization.*/
  if (osp->rxsize == 0)         /* Special case for zero sized packets.*/
    osp->rxpkts = 1;
 800398a:	2301      	movs	r3, #1
 800398c:	8213      	strh	r3, [r2, #16]
 800398e:	4770      	bx	lr

08003990 <usb_lld_prepare_transmit>:
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003990:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
 8003994:	b430      	push	{r4, r5}
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8003996:	68c2      	ldr	r2, [r0, #12]
 8003998:	6953      	ldr	r3, [r2, #20]

  /* Transfer initialization.*/
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
 800399a:	8a10      	ldrh	r0, [r2, #16]
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
  size_t n;
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  /* Transfer initialization.*/
  n = isp->txsize;
 800399c:	685a      	ldr	r2, [r3, #4]
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
 800399e:	460d      	mov	r5, r1
  /* Transfer initialization.*/
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
    n = (size_t)usbp->epc[ep]->in_maxsize;

  if (isp->txqueued)
 80039a0:	7819      	ldrb	r1, [r3, #0]
 80039a2:	4282      	cmp	r2, r0
 80039a4:	bf28      	it	cs
 80039a6:	4602      	movcs	r2, r0
 80039a8:	b9f9      	cbnz	r1, 80039ea <usb_lld_prepare_transmit+0x5a>
    usb_packet_write_from_queue(USB_GET_DESCRIPTOR(ep),
                                isp->mode.queue.txqueue, n);
  else
    usb_packet_write_from_buffer(USB_GET_DESCRIPTOR(ep),
 80039aa:	4916      	ldr	r1, [pc, #88]	; (8003a04 <usb_lld_prepare_transmit+0x74>)
 80039ac:	68dc      	ldr	r4, [r3, #12]
 80039ae:	6d08      	ldr	r0, [r1, #80]	; 0x50
 80039b0:	f100 5000 	add.w	r0, r0, #536870912	; 0x20000000
 80039b4:	f500 5040 	add.w	r0, r0, #12288	; 0x3000
 80039b8:	eb00 00c5 	add.w	r0, r0, r5, lsl #3
 80039bc:	0040      	lsls	r0, r0, #1
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  n = (n + 1) / 2;
 80039be:	1c53      	adds	r3, r2, #1
 * @notapi
 */
static void usb_packet_write_from_buffer(stm32_usb_descriptor_t *udp,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 80039c0:	6801      	ldr	r1, [r0, #0]

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
 80039c2:	6845      	ldr	r5, [r0, #4]
 80039c4:	6042      	str	r2, [r0, #4]
 * @notapi
 */
static void usb_packet_write_from_buffer(stm32_usb_descriptor_t *udp,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 80039c6:	f101 5200 	add.w	r2, r1, #536870912	; 0x20000000
 80039ca:	f502 5240 	add.w	r2, r2, #12288	; 0x3000

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  n = (n + 1) / 2;
  while (n > 0) {
 80039ce:	085b      	lsrs	r3, r3, #1
 * @notapi
 */
static void usb_packet_write_from_buffer(stm32_usb_descriptor_t *udp,
                                         const uint8_t *buf,
                                         size_t n) {
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);
 80039d0:	ea4f 0242 	mov.w	r2, r2, lsl #1

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  n = (n + 1) / 2;
  while (n > 0) {
 80039d4:	d007      	beq.n	80039e6 <usb_lld_prepare_transmit+0x56>
 80039d6:	1ea1      	subs	r1, r4, #2
 80039d8:	3a04      	subs	r2, #4
    /* Note, this line relies on the Cortex-M3/M4 ability to perform
       unaligned word accesses.*/
    *pmap++ = (stm32_usb_pma_t)*(const uint16_t *)buf;
 80039da:	f831 0f02 	ldrh.w	r0, [r1, #2]!
 80039de:	f842 0f04 	str.w	r0, [r2, #4]!
                                         size_t n) {
  stm32_usb_pma_t *pmap = USB_ADDR2PTR(udp->TXADDR0);

  udp->TXCOUNT0 = (stm32_usb_pma_t)n;
  n = (n + 1) / 2;
  while (n > 0) {
 80039e2:	3b01      	subs	r3, #1
 80039e4:	d1f9      	bne.n	80039da <usb_lld_prepare_transmit+0x4a>
    usb_packet_write_from_queue(USB_GET_DESCRIPTOR(ep),
                                isp->mode.queue.txqueue, n);
  else
    usb_packet_write_from_buffer(USB_GET_DESCRIPTOR(ep),
                                 isp->mode.linear.txbuf, n);
}
 80039e6:	bc30      	pop	{r4, r5}
 80039e8:	4770      	bx	lr
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
    n = (size_t)usbp->epc[ep]->in_maxsize;

  if (isp->txqueued)
    usb_packet_write_from_queue(USB_GET_DESCRIPTOR(ep),
 80039ea:	4806      	ldr	r0, [pc, #24]	; (8003a04 <usb_lld_prepare_transmit+0x74>)
 80039ec:	68d9      	ldr	r1, [r3, #12]
 80039ee:	6d00      	ldr	r0, [r0, #80]	; 0x50
 80039f0:	f100 5000 	add.w	r0, r0, #536870912	; 0x20000000
 80039f4:	f500 5040 	add.w	r0, r0, #12288	; 0x3000
 80039f8:	eb00 00c5 	add.w	r0, r0, r5, lsl #3
 80039fc:	0040      	lsls	r0, r0, #1
                                isp->mode.queue.txqueue, n);
  else
    usb_packet_write_from_buffer(USB_GET_DESCRIPTOR(ep),
                                 isp->mode.linear.txbuf, n);
}
 80039fe:	bc30      	pop	{r4, r5}
  n = isp->txsize;
  if (n > (size_t)usbp->epc[ep]->in_maxsize)
    n = (size_t)usbp->epc[ep]->in_maxsize;

  if (isp->txqueued)
    usb_packet_write_from_queue(USB_GET_DESCRIPTOR(ep),
 8003a00:	f7ff bcbe 	b.w	8003380 <usb_packet_write_from_queue>
 8003a04:	40005c00 	.word	0x40005c00
 8003a08:	f3af 8000 	nop.w
 8003a0c:	f3af 8000 	nop.w

08003a10 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8003a10:	0089      	lsls	r1, r1, #2
 8003a12:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8003a16:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_VALID);
 8003a1a:	680b      	ldr	r3, [r1, #0]
 8003a1c:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8003a20:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003a24:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8003a28:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003a2c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003a30:	600b      	str	r3, [r1, #0]
 8003a32:	4770      	bx	lr
 8003a34:	f3af 8000 	nop.w
 8003a38:	f3af 8000 	nop.w
 8003a3c:	f3af 8000 	nop.w

08003a40 <usb_lld_start_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8003a40:	0089      	lsls	r1, r1, #2
 8003a42:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8003a46:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_VALID);
 8003a4a:	680b      	ldr	r3, [r1, #0]
 8003a4c:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8003a50:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003a54:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8003a58:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003a5c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003a60:	600b      	str	r3, [r1, #0]
 8003a62:	4770      	bx	lr
 8003a64:	f3af 8000 	nop.w
 8003a68:	f3af 8000 	nop.w
 8003a6c:	f3af 8000 	nop.w

08003a70 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 8003a70:	0089      	lsls	r1, r1, #2
 8003a72:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8003a76:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  EPR_SET_STAT_RX(ep, EPR_STAT_RX_STALL);
 8003a7a:	680b      	ldr	r3, [r1, #0]
 8003a7c:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8003a80:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003a84:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 8003a88:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003a8c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003a90:	600b      	str	r3, [r1, #0]
 8003a92:	4770      	bx	lr
 8003a94:	f3af 8000 	nop.w
 8003a98:	f3af 8000 	nop.w
 8003a9c:	f3af 8000 	nop.w

08003aa0 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 8003aa0:	0089      	lsls	r1, r1, #2
 8003aa2:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8003aa6:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  EPR_SET_STAT_TX(ep, EPR_STAT_TX_STALL);
 8003aaa:	680b      	ldr	r3, [r1, #0]
 8003aac:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8003ab0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003ab4:	f083 0310 	eor.w	r3, r3, #16
 8003ab8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003abc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003ac0:	600b      	str	r3, [r1, #0]
 8003ac2:	4770      	bx	lr
 8003ac4:	f3af 8000 	nop.w
 8003ac8:	f3af 8000 	nop.w
 8003acc:	f3af 8000 	nop.w

08003ad0 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8003ad0:	0089      	lsls	r1, r1, #2
 8003ad2:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8003ad6:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_RX_MASK) != EPR_STAT_RX_VALID)
 8003ada:	680b      	ldr	r3, [r1, #0]
 8003adc:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8003ae0:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8003ae4:	d009      	beq.n	8003afa <usb_lld_clear_out+0x2a>
    EPR_SET_STAT_TX(ep, EPR_STAT_RX_NAK);
 8003ae6:	680b      	ldr	r3, [r1, #0]
 8003ae8:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8003aec:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003af0:	f443 4320 	orr.w	r3, r3, #40960	; 0xa000
 8003af4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003af8:	600b      	str	r3, [r1, #0]
 8003afa:	4770      	bx	lr
 8003afc:	f3af 8000 	nop.w

08003b00 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8003b00:	0089      	lsls	r1, r1, #2
 8003b02:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8003b06:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00

  (void)usbp;

  /* Makes sure to not put to NAK an endpoint that is already
     transferring.*/
  if ((STM32_USB->EPR[ep] & EPR_STAT_TX_MASK) != EPR_STAT_TX_VALID)
 8003b0a:	680b      	ldr	r3, [r1, #0]
 8003b0c:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8003b10:	2b30      	cmp	r3, #48	; 0x30
 8003b12:	d00b      	beq.n	8003b2c <usb_lld_clear_in+0x2c>
    EPR_SET_STAT_TX(ep, EPR_STAT_TX_NAK);
 8003b14:	680b      	ldr	r3, [r1, #0]
 8003b16:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8003b1a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003b1e:	f083 0320 	eor.w	r3, r3, #32
 8003b22:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003b26:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003b2a:	600b      	str	r3, [r1, #0]
 8003b2c:	4770      	bx	lr
 8003b2e:	bf00      	nop

08003b30 <__early_init>:
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
 8003b30:	f7fe bf96 	b.w	8002a60 <stm32_clock_init>
 8003b34:	f3af 8000 	nop.w
 8003b38:	f3af 8000 	nop.w
 8003b3c:	f3af 8000 	nop.w

08003b40 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
 8003b40:	4770      	bx	lr
 8003b42:	bf00      	nop
 8003b44:	f3af 8000 	nop.w
 8003b48:	f3af 8000 	nop.w
 8003b4c:	f3af 8000 	nop.w

08003b50 <driversInit>:
#include "drivers.h"

void driversInit(void)
{
#if defined(DRIVER_USE_DAC) && DRIVER_USE_DAC
  dacInit();
 8003b50:	f000 b806 	b.w	8003b60 <dacInit>
 8003b54:	f3af 8000 	nop.w
 8003b58:	f3af 8000 	nop.w
 8003b5c:	f3af 8000 	nop.w

08003b60 <dacInit>:
 *
 * @init
 */
void dacInit(void) {

  dac_lld_init();
 8003b60:	f000 b82e 	b.w	8003bc0 <dac_lld_init>
 8003b64:	f3af 8000 	nop.w
 8003b68:	f3af 8000 	nop.w
 8003b6c:	f3af 8000 	nop.w

08003b70 <dacObjectInit>:
 * @init
 */
void dacObjectInit(DACDriver *dacp) {

  dacp->state = DAC_STOP;
  dacp->config = NULL;
 8003b70:	2300      	movs	r3, #0
 *
 * @init
 */
void dacObjectInit(DACDriver *dacp) {

  dacp->state = DAC_STOP;
 8003b72:	2201      	movs	r2, #1
 8003b74:	7002      	strb	r2, [r0, #0]
  dacp->config = NULL;
 8003b76:	6103      	str	r3, [r0, #16]
#if DAC_USE_WAIT
  dacp->thread = NULL;
 8003b78:	6143      	str	r3, [r0, #20]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8003b7a:	3018      	adds	r0, #24
 8003b7c:	f7fd be28 	b.w	80017d0 <chMtxObjectInit>

08003b80 <dacStart>:
 * @param[in] dacp      pointer to the @p DACDriver object
 * @param[in] config    pointer to the @p DACConfig object
 *
 * @api
 */
void dacStart(DACDriver *dacp, const DACConfig *config) {
 8003b80:	b510      	push	{r4, lr}
 8003b82:	2320      	movs	r3, #32
 8003b84:	4604      	mov	r4, r0
 8003b86:	f383 8811 	msr	BASEPRI, r3
  osalSysLock();

  osalDbgAssert((dacp->state == DAC_STOP) || (dacp->state == DAC_READY),
                "invalid state");

  dacp->config = config;
 8003b8a:	6101      	str	r1, [r0, #16]
  dac_lld_start(dacp);
 8003b8c:	f000 f848 	bl	8003c20 <dac_lld_start>
  dacp->state = DAC_READY;
 8003b90:	2302      	movs	r3, #2
 8003b92:	7023      	strb	r3, [r4, #0]
 8003b94:	2300      	movs	r3, #0
 8003b96:	f383 8811 	msr	BASEPRI, r3
 8003b9a:	bd10      	pop	{r4, pc}
 8003b9c:	f3af 8000 	nop.w

08003ba0 <dacConvertOne>:
 * @param[in] dacp      pointer to the @p DACDriver object
 * @param[in] value     the value to output
 *
 * @api
 */
void dacConvertOne(DACDriver *dacp, dacsample_t value) {
 8003ba0:	b510      	push	{r4, lr}
  osalDbgAssert((dacp->state == DAC_READY) ||
              (dacp->state == DAC_COMPLETE) ||
              (dacp->state == DAC_ERROR),
              "not ready");

  dacp->state = DAC_ACTIVE;
 8003ba2:	2303      	movs	r3, #3
 * @param[in] dacp      pointer to the @p DACDriver object
 * @param[in] value     the value to output
 *
 * @api
 */
void dacConvertOne(DACDriver *dacp, dacsample_t value) {
 8003ba4:	4604      	mov	r4, r0
  osalDbgAssert((dacp->state == DAC_READY) ||
              (dacp->state == DAC_COMPLETE) ||
              (dacp->state == DAC_ERROR),
              "not ready");

  dacp->state = DAC_ACTIVE;
 8003ba6:	7003      	strb	r3, [r0, #0]
  dac_lld_single_convert(dacp, value);
 8003ba8:	f000 f852 	bl	8003c50 <dac_lld_single_convert>
  dacp->state = DAC_READY;
 8003bac:	2302      	movs	r3, #2
 8003bae:	7023      	strb	r3, [r4, #0]
 8003bb0:	bd10      	pop	{r4, pc}
 8003bb2:	bf00      	nop
 8003bb4:	f3af 8000 	nop.w
 8003bb8:	f3af 8000 	nop.w
 8003bbc:	f3af 8000 	nop.w

08003bc0 <dac_lld_init>:
/**
 * @brief   Low level DAC driver initialization.
 *
 * @notapi
 */
void dac_lld_init(void) {
 8003bc0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

#if STM32_DAC_USE_CHN1
  dacObjectInit(&DACD1);
 8003bc4:	4d10      	ldr	r5, [pc, #64]	; (8003c08 <dac_lld_init+0x48>)
                  STM32_DMA_CR_TEIE |                                         \
                  STM32_DMA_CR_MINC | STM32_DMA_CR_TCIE;
#endif

#if STM32_DAC_USE_CHN2
  dacObjectInit(&DACD2);
 8003bc6:	4c11      	ldr	r4, [pc, #68]	; (8003c0c <dac_lld_init+0x4c>)
#if STM32_DAC_USE_CHN1
  dacObjectInit(&DACD1);
  DACD1.dac     = DAC1;
  DACD1.tim     = STM32_TIM6;
  DACD1.irqprio = STM32_DAC_CHN1_IRQ_PRIORITY;
  DACD1.dma     = STM32_DMA_STREAM(STM32_DAC_CHN1_DMA_STREAM);
 8003bc8:	4e11      	ldr	r6, [pc, #68]	; (8003c10 <dac_lld_init+0x50>)
 */
void dac_lld_init(void) {

#if STM32_DAC_USE_CHN1
  dacObjectInit(&DACD1);
  DACD1.dac     = DAC1;
 8003bca:	f8df 9050 	ldr.w	r9, [pc, #80]	; 8003c1c <dac_lld_init+0x5c>
 * @notapi
 */
void dac_lld_init(void) {

#if STM32_DAC_USE_CHN1
  dacObjectInit(&DACD1);
 8003bce:	4628      	mov	r0, r5
 8003bd0:	f7ff ffce 	bl	8003b70 <dacObjectInit>
  DACD1.dac     = DAC1;
  DACD1.tim     = STM32_TIM6;
  DACD1.irqprio = STM32_DAC_CHN1_IRQ_PRIORITY;
 8003bd4:	f04f 080a 	mov.w	r8, #10
void dac_lld_init(void) {

#if STM32_DAC_USE_CHN1
  dacObjectInit(&DACD1);
  DACD1.dac     = DAC1;
  DACD1.tim     = STM32_TIM6;
 8003bd8:	4b0e      	ldr	r3, [pc, #56]	; (8003c14 <dac_lld_init+0x54>)
 8003bda:	62eb      	str	r3, [r5, #44]	; 0x2c
  DACD1.irqprio = STM32_DAC_CHN1_IRQ_PRIORITY;
  DACD1.dma     = STM32_DMA_STREAM(STM32_DAC_CHN1_DMA_STREAM);
  DACD1.dmamode = STM32_DMA_CR_CHSEL(DAC_CHN1_DMA_CHANNEL) |                  \
 8003bdc:	f242 079a 	movw	r7, #8346	; 0x209a
                  STM32_DMA_CR_TEIE |                                         \
                  STM32_DMA_CR_MINC | STM32_DMA_CR_TCIE;
#endif

#if STM32_DAC_USE_CHN2
  dacObjectInit(&DACD2);
 8003be0:	4620      	mov	r0, r4
#if STM32_DAC_USE_CHN1
  dacObjectInit(&DACD1);
  DACD1.dac     = DAC1;
  DACD1.tim     = STM32_TIM6;
  DACD1.irqprio = STM32_DAC_CHN1_IRQ_PRIORITY;
  DACD1.dma     = STM32_DMA_STREAM(STM32_DAC_CHN1_DMA_STREAM);
 8003be2:	636e      	str	r6, [r5, #52]	; 0x34
 */
void dac_lld_init(void) {

#if STM32_DAC_USE_CHN1
  dacObjectInit(&DACD1);
  DACD1.dac     = DAC1;
 8003be4:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
  DACD1.tim     = STM32_TIM6;
  DACD1.irqprio = STM32_DAC_CHN1_IRQ_PRIORITY;
 8003be8:	f8c5 8030 	str.w	r8, [r5, #48]	; 0x30
  DACD1.dma     = STM32_DMA_STREAM(STM32_DAC_CHN1_DMA_STREAM);
  DACD1.dmamode = STM32_DMA_CR_CHSEL(DAC_CHN1_DMA_CHANNEL) |                  \
 8003bec:	63af      	str	r7, [r5, #56]	; 0x38
#if STM32_DAC_USE_CHN2
  dacObjectInit(&DACD2);
  DACD2.dac     = DAC1;
  DACD2.tim     = STM32_TIM7;
  DACD2.irqprio = STM32_DAC_CHN2_IRQ_PRIORITY;
  DACD2.dma     = STM32_DMA_STREAM(STM32_DAC_CHN2_DMA_STREAM);
 8003bee:	360c      	adds	r6, #12
                  STM32_DMA_CR_TEIE |                                         \
                  STM32_DMA_CR_MINC | STM32_DMA_CR_TCIE;
#endif

#if STM32_DAC_USE_CHN2
  dacObjectInit(&DACD2);
 8003bf0:	f7ff ffbe 	bl	8003b70 <dacObjectInit>
  DACD2.dac     = DAC1;
  DACD2.tim     = STM32_TIM7;
 8003bf4:	4b08      	ldr	r3, [pc, #32]	; (8003c18 <dac_lld_init+0x58>)
                  STM32_DMA_CR_MINC | STM32_DMA_CR_TCIE;
#endif

#if STM32_DAC_USE_CHN2
  dacObjectInit(&DACD2);
  DACD2.dac     = DAC1;
 8003bf6:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
  DACD2.tim     = STM32_TIM7;
  DACD2.irqprio = STM32_DAC_CHN2_IRQ_PRIORITY;
  DACD2.dma     = STM32_DMA_STREAM(STM32_DAC_CHN2_DMA_STREAM);
 8003bfa:	6366      	str	r6, [r4, #52]	; 0x34

#if STM32_DAC_USE_CHN2
  dacObjectInit(&DACD2);
  DACD2.dac     = DAC1;
  DACD2.tim     = STM32_TIM7;
  DACD2.irqprio = STM32_DAC_CHN2_IRQ_PRIORITY;
 8003bfc:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
  DACD2.dma     = STM32_DMA_STREAM(STM32_DAC_CHN2_DMA_STREAM);
  DACD2.dmamode = STM32_DMA_CR_CHSEL(DAC_CHN2_DMA_CHANNEL) |                  \
 8003c00:	63a7      	str	r7, [r4, #56]	; 0x38
#endif

#if STM32_DAC_USE_CHN2
  dacObjectInit(&DACD2);
  DACD2.dac     = DAC1;
  DACD2.tim     = STM32_TIM7;
 8003c02:	62e3      	str	r3, [r4, #44]	; 0x2c
 8003c04:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8003c08:	200012b8 	.word	0x200012b8
 8003c0c:	200012f8 	.word	0x200012f8
 8003c10:	0800699c 	.word	0x0800699c
 8003c14:	40001000 	.word	0x40001000
 8003c18:	40001400 	.word	0x40001400
 8003c1c:	40007400 	.word	0x40007400

08003c20 <dac_lld_start>:
 * @notapi
 */
void dac_lld_start(DACDriver *dacp) {

#if STM32_DAC_USE_CHN1
  if (&DACD1 == dacp) {
 8003c20:	4b06      	ldr	r3, [pc, #24]	; (8003c3c <dac_lld_start+0x1c>)
 8003c22:	4298      	cmp	r0, r3
 8003c24:	d003      	beq.n	8003c2e <dac_lld_start+0xe>
    rccEnableDAC1(FALSE);
  }
#endif
#if STM32_DAC_USE_CHN2
  if (&DACD2 == dacp) {
 8003c26:	4b06      	ldr	r3, [pc, #24]	; (8003c40 <dac_lld_start+0x20>)
 8003c28:	4298      	cmp	r0, r3
 8003c2a:	d000      	beq.n	8003c2e <dac_lld_start+0xe>
 8003c2c:	4770      	bx	lr
    rccEnableDAC1(FALSE);
 8003c2e:	4a05      	ldr	r2, [pc, #20]	; (8003c44 <dac_lld_start+0x24>)
 8003c30:	69d3      	ldr	r3, [r2, #28]
 8003c32:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8003c36:	61d3      	str	r3, [r2, #28]
 8003c38:	4770      	bx	lr
 8003c3a:	bf00      	nop
 8003c3c:	200012b8 	.word	0x200012b8
 8003c40:	200012f8 	.word	0x200012f8
 8003c44:	40021000 	.word	0x40021000
 8003c48:	f3af 8000 	nop.w
 8003c4c:	f3af 8000 	nop.w

08003c50 <dac_lld_single_convert>:
 * @param[in] dacp      pointer to the @p DACDriver object
 * @param[in] value     the value to output
 *
 * @notapi
 */
void dac_lld_single_convert(DACDriver *dacp, dacsample_t value) {
 8003c50:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t dataoffset = 0;
  uint32_t regshift = 0;
  volatile dacsample_t* data = NULL;
	
#if STM32_DAC_USE_CHN2
  if (&DACD2 == dacp) {
 8003c52:	4e2b      	ldr	r6, [pc, #172]	; (8003d00 <dac_lld_single_convert+0xb0>)
 8003c54:	42b0      	cmp	r0, r6
 8003c56:	d03e      	beq.n	8003cd6 <dac_lld_single_convert+0x86>
 8003c58:	2700      	movs	r7, #0
 8003c5a:	f8df e0ac 	ldr.w	lr, [pc, #172]	; 8003d08 <dac_lld_single_convert+0xb8>
 *
 * @notapi
 */
void dac_lld_single_convert(DACDriver *dacp, dacsample_t value) {
	
  uint32_t dataoffset = 0;
 8003c5e:	463c      	mov	r4, r7
    regshift = 16;
    dataoffset = 12;
  }
#endif

  switch (dacp->config->dhrm) {
 8003c60:	6902      	ldr	r2, [r0, #16]
 8003c62:	7813      	ldrb	r3, [r2, #0]
 8003c64:	2b05      	cmp	r3, #5
 8003c66:	d83e      	bhi.n	8003ce6 <dac_lld_single_convert+0x96>
 8003c68:	e8df f003 	tbb	[pc, r3]
 8003c6c:	2d27211b 	.word	0x2d27211b
 8003c70:	0331      	.short	0x0331
      break;
    case DAC_DHRM_12BIT_LEFT_DUAL:
      data = (dacsample_t*)&dacp->dac->DHR12LD;
      break;
    case DAC_DHRM_8BIT_RIGHT_DUAL:
      data = (dacsample_t*)&dacp->dac->DHR8RD;
 8003c72:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003c74:	f103 0428 	add.w	r4, r3, #40	; 0x28
      break;
#endif
  }
  
  dacp->dac->CR &=  ~(STM32_DAC_CR_MASK << regshift);
 8003c78:	681d      	ldr	r5, [r3, #0]
  dacp->dac->CR |= ((STM32_DAC_CR_EN | dacp->config->cr_flags) << regshift);
 8003c7a:	6852      	ldr	r2, [r2, #4]
      data = (dacsample_t*)&dacp->dac->DHR8RD;
      break;
#endif
  }
  
  dacp->dac->CR &=  ~(STM32_DAC_CR_MASK << regshift);
 8003c7c:	ea0e 0505 	and.w	r5, lr, r5
 8003c80:	601d      	str	r5, [r3, #0]
  dacp->dac->CR |= ((STM32_DAC_CR_EN | dacp->config->cr_flags) << regshift);
 8003c82:	681d      	ldr	r5, [r3, #0]
 8003c84:	f042 0201 	orr.w	r2, r2, #1
 8003c88:	40ba      	lsls	r2, r7
 8003c8a:	432a      	orrs	r2, r5
 8003c8c:	601a      	str	r2, [r3, #0]
  
  if (data != NULL)
 8003c8e:	b104      	cbz	r4, 8003c92 <dac_lld_single_convert+0x42>
    *data = value;
 8003c90:	8021      	strh	r1, [r4, #0]
  
#if STM32_DAC_USE_CHN1
  if (&DACD1 == dacp) {
 8003c92:	4a1c      	ldr	r2, [pc, #112]	; (8003d04 <dac_lld_single_convert+0xb4>)
 8003c94:	4290      	cmp	r0, r2
 8003c96:	d023      	beq.n	8003ce0 <dac_lld_single_convert+0x90>
    dacp->dac->SWTRIGR = DAC_SWTRIGR_SWTRIG1;
  }
#endif
#if STM32_DAC_USE_CHN2
  if (&DACD2 == dacp) {
 8003c98:	42b0      	cmp	r0, r6
    dacp->dac->SWTRIGR = DAC_SWTRIGR_SWTRIG2;
 8003c9a:	bf04      	itt	eq
 8003c9c:	2202      	moveq	r2, #2
 8003c9e:	605a      	streq	r2, [r3, #4]
 8003ca0:	bdf0      	pop	{r4, r5, r6, r7, pc}
#endif

  switch (dacp->config->dhrm) {
    /* Sets the DAC data register */
    case DAC_DHRM_12BIT_RIGHT:
      data = (dacsample_t*)&dacp->dac->DHR12R1 + dataoffset;
 8003ca2:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003ca4:	f103 0508 	add.w	r5, r3, #8
 8003ca8:	eb05 0444 	add.w	r4, r5, r4, lsl #1
      break;
 8003cac:	e7e4      	b.n	8003c78 <dac_lld_single_convert+0x28>
    case DAC_DHRM_12BIT_LEFT:
      data = (dacsample_t*)&dacp->dac->DHR12L1 + dataoffset;
 8003cae:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003cb0:	f103 050c 	add.w	r5, r3, #12
 8003cb4:	eb05 0444 	add.w	r4, r5, r4, lsl #1
      break;
 8003cb8:	e7de      	b.n	8003c78 <dac_lld_single_convert+0x28>
    case DAC_DHRM_8BIT_RIGHT:
      data = (dacsample_t*)&dacp->dac->DHR8R1 + dataoffset;
 8003cba:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003cbc:	f103 0510 	add.w	r5, r3, #16
 8003cc0:	eb05 0444 	add.w	r4, r5, r4, lsl #1
      break;
 8003cc4:	e7d8      	b.n	8003c78 <dac_lld_single_convert+0x28>
#if defined(STM32_HAS_DAC_CHN2) && STM32_HAS_DAC_CHN2
    case DAC_DHRM_12BIT_RIGHT_DUAL:
      data = (dacsample_t*)&dacp->dac->DHR12RD;
 8003cc6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003cc8:	f103 0420 	add.w	r4, r3, #32
      break;
 8003ccc:	e7d4      	b.n	8003c78 <dac_lld_single_convert+0x28>
    case DAC_DHRM_12BIT_LEFT_DUAL:
      data = (dacsample_t*)&dacp->dac->DHR12LD;
 8003cce:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003cd0:	f103 0424 	add.w	r4, r3, #36	; 0x24
      break;
 8003cd4:	e7d0      	b.n	8003c78 <dac_lld_single_convert+0x28>
  uint32_t dataoffset = 0;
  uint32_t regshift = 0;
  volatile dacsample_t* data = NULL;
	
#if STM32_DAC_USE_CHN2
  if (&DACD2 == dacp) {
 8003cd6:	f8df e034 	ldr.w	lr, [pc, #52]	; 8003d0c <dac_lld_single_convert+0xbc>
 8003cda:	2710      	movs	r7, #16
    regshift = 16;
    dataoffset = 12;
 8003cdc:	240c      	movs	r4, #12
 8003cde:	e7bf      	b.n	8003c60 <dac_lld_single_convert+0x10>
  if (data != NULL)
    *data = value;
  
#if STM32_DAC_USE_CHN1
  if (&DACD1 == dacp) {
    dacp->dac->SWTRIGR = DAC_SWTRIGR_SWTRIG1;
 8003ce0:	2201      	movs	r2, #1
 8003ce2:	605a      	str	r2, [r3, #4]
 8003ce4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003ce6:	6a83      	ldr	r3, [r0, #40]	; 0x28
      break;
#endif
  }
  
  dacp->dac->CR &=  ~(STM32_DAC_CR_MASK << regshift);
  dacp->dac->CR |= ((STM32_DAC_CR_EN | dacp->config->cr_flags) << regshift);
 8003ce8:	6852      	ldr	r2, [r2, #4]
      data = (dacsample_t*)&dacp->dac->DHR8RD;
      break;
#endif
  }
  
  dacp->dac->CR &=  ~(STM32_DAC_CR_MASK << regshift);
 8003cea:	681d      	ldr	r5, [r3, #0]
 8003cec:	ea0e 0505 	and.w	r5, lr, r5
 8003cf0:	601d      	str	r5, [r3, #0]
  dacp->dac->CR |= ((STM32_DAC_CR_EN | dacp->config->cr_flags) << regshift);
 8003cf2:	6819      	ldr	r1, [r3, #0]
 8003cf4:	f042 0201 	orr.w	r2, r2, #1
 8003cf8:	40ba      	lsls	r2, r7
 8003cfa:	430a      	orrs	r2, r1
 8003cfc:	601a      	str	r2, [r3, #0]
 8003cfe:	e7c8      	b.n	8003c92 <dac_lld_single_convert+0x42>
 8003d00:	200012f8 	.word	0x200012f8
 8003d04:	200012b8 	.word	0x200012b8
 8003d08:	fffff001 	.word	0xfffff001
 8003d0c:	f001ffff 	.word	0xf001ffff

08003d10 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8003d10:	b40e      	push	{r1, r2, r3}
 8003d12:	b500      	push	{lr}
 8003d14:	b082      	sub	sp, #8
 8003d16:	aa03      	add	r2, sp, #12
 8003d18:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8003d1c:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8003d1e:	f000 fa0f 	bl	8004140 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8003d22:	b002      	add	sp, #8
 8003d24:	f85d eb04 	ldr.w	lr, [sp], #4
 8003d28:	b003      	add	sp, #12
 8003d2a:	4770      	bx	lr
 8003d2c:	f3af 8000 	nop.w

08003d30 <cmd_systime>:
}

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8003d30:	2900      	cmp	r1, #0
 8003d32:	dd03      	ble.n	8003d3c <cmd_systime+0xc>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8003d34:	4907      	ldr	r1, [pc, #28]	; (8003d54 <cmd_systime+0x24>)
 8003d36:	4a08      	ldr	r2, [pc, #32]	; (8003d58 <cmd_systime+0x28>)
 8003d38:	f7ff bfea 	b.w	8003d10 <chprintf>
 8003d3c:	2320      	movs	r3, #32
 8003d3e:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003d42:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8003d46:	2300      	movs	r3, #0
 8003d48:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8003d4a:	f383 8811 	msr	BASEPRI, r3
  (void)argv;
  if (argc > 0) {
    usage(chp, "systime");
    return;
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 8003d4e:	4903      	ldr	r1, [pc, #12]	; (8003d5c <cmd_systime+0x2c>)
 8003d50:	f7ff bfde 	b.w	8003d10 <chprintf>
 8003d54:	08006ac0 	.word	0x08006ac0
 8003d58:	08006acc 	.word	0x08006acc
 8003d5c:	08006ad4 	.word	0x08006ad4

08003d60 <cmd_info>:
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8003d60:	2900      	cmp	r1, #0
 8003d62:	dd03      	ble.n	8003d6c <cmd_info+0xc>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8003d64:	4919      	ldr	r1, [pc, #100]	; (8003dcc <cmd_info+0x6c>)
 8003d66:	4a1a      	ldr	r2, [pc, #104]	; (8003dd0 <cmd_info+0x70>)
 8003d68:	f7ff bfd2 	b.w	8003d10 <chprintf>
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003d6c:	b510      	push	{r4, lr}
  if (argc > 0) {
    usage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 8003d6e:	4919      	ldr	r1, [pc, #100]	; (8003dd4 <cmd_info+0x74>)
 8003d70:	4a19      	ldr	r2, [pc, #100]	; (8003dd8 <cmd_info+0x78>)
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003d72:	b082      	sub	sp, #8
 8003d74:	4604      	mov	r4, r0
  if (argc > 0) {
    usage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 8003d76:	f7ff ffcb 	bl	8003d10 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s\r\n", PORT_COMPILER_NAME);
 8003d7a:	4620      	mov	r0, r4
 8003d7c:	4917      	ldr	r1, [pc, #92]	; (8003ddc <cmd_info+0x7c>)
 8003d7e:	4a18      	ldr	r2, [pc, #96]	; (8003de0 <cmd_info+0x80>)
 8003d80:	f7ff ffc6 	bl	8003d10 <chprintf>
#endif
  chprintf(chp, "Architecture: %s\r\n", PORT_ARCHITECTURE_NAME);
 8003d84:	4620      	mov	r0, r4
 8003d86:	4917      	ldr	r1, [pc, #92]	; (8003de4 <cmd_info+0x84>)
 8003d88:	4a17      	ldr	r2, [pc, #92]	; (8003de8 <cmd_info+0x88>)
 8003d8a:	f7ff ffc1 	bl	8003d10 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s\r\n", PORT_CORE_VARIANT_NAME);
 8003d8e:	4620      	mov	r0, r4
 8003d90:	4916      	ldr	r1, [pc, #88]	; (8003dec <cmd_info+0x8c>)
 8003d92:	4a17      	ldr	r2, [pc, #92]	; (8003df0 <cmd_info+0x90>)
 8003d94:	f7ff ffbc 	bl	8003d10 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s\r\n", PORT_INFO);
 8003d98:	4620      	mov	r0, r4
 8003d9a:	4916      	ldr	r1, [pc, #88]	; (8003df4 <cmd_info+0x94>)
 8003d9c:	4a16      	ldr	r2, [pc, #88]	; (8003df8 <cmd_info+0x98>)
 8003d9e:	f7ff ffb7 	bl	8003d10 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s\r\n", PLATFORM_NAME);
 8003da2:	4620      	mov	r0, r4
 8003da4:	4915      	ldr	r1, [pc, #84]	; (8003dfc <cmd_info+0x9c>)
 8003da6:	4a16      	ldr	r2, [pc, #88]	; (8003e00 <cmd_info+0xa0>)
 8003da8:	f7ff ffb2 	bl	8003d10 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s\r\n", BOARD_NAME);
 8003dac:	4620      	mov	r0, r4
 8003dae:	4915      	ldr	r1, [pc, #84]	; (8003e04 <cmd_info+0xa4>)
 8003db0:	4a15      	ldr	r2, [pc, #84]	; (8003e08 <cmd_info+0xa8>)
 8003db2:	f7ff ffad 	bl	8003d10 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
 8003db6:	4b15      	ldr	r3, [pc, #84]	; (8003e0c <cmd_info+0xac>)
 8003db8:	9300      	str	r3, [sp, #0]
 8003dba:	4620      	mov	r0, r4
 8003dbc:	4914      	ldr	r1, [pc, #80]	; (8003e10 <cmd_info+0xb0>)
 8003dbe:	4a15      	ldr	r2, [pc, #84]	; (8003e14 <cmd_info+0xb4>)
 8003dc0:	4b15      	ldr	r3, [pc, #84]	; (8003e18 <cmd_info+0xb8>)
 8003dc2:	f7ff ffa5 	bl	8003d10 <chprintf>
#endif
#endif
}
 8003dc6:	b002      	add	sp, #8
 8003dc8:	bd10      	pop	{r4, pc}
 8003dca:	bf00      	nop
 8003dcc:	08006ac0 	.word	0x08006ac0
 8003dd0:	08006adc 	.word	0x08006adc
 8003dd4:	08006ae4 	.word	0x08006ae4
 8003dd8:	08006af8 	.word	0x08006af8
 8003ddc:	08006b04 	.word	0x08006b04
 8003de0:	08006b18 	.word	0x08006b18
 8003de4:	08006b60 	.word	0x08006b60
 8003de8:	08006b74 	.word	0x08006b74
 8003dec:	08006b80 	.word	0x08006b80
 8003df0:	08006b94 	.word	0x08006b94
 8003df4:	08006ba0 	.word	0x08006ba0
 8003df8:	08006bb4 	.word	0x08006bb4
 8003dfc:	08006bcc 	.word	0x08006bcc
 8003e00:	08006be0 	.word	0x08006be0
 8003e04:	08006bfc 	.word	0x08006bfc
 8003e08:	08006c10 	.word	0x08006c10
 8003e0c:	08006c60 	.word	0x08006c60
 8003e10:	08006c38 	.word	0x08006c38
 8003e14:	08006c50 	.word	0x08006c50
 8003e18:	08006c5c 	.word	0x08006c5c
 8003e1c:	f3af 8000 	nop.w

08003e20 <_strtok.constprop.2>:
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 8003e20:	b538      	push	{r3, r4, r5, lr}
 8003e22:	460d      	mov	r5, r1
  char *token;
  if (str)
 8003e24:	4604      	mov	r4, r0
 8003e26:	b190      	cbz	r0, 8003e4e <_strtok.constprop.2+0x2e>
    *saveptr = str;
 8003e28:	6028      	str	r0, [r5, #0]
  token = *saveptr;

  if (!token)
    return NULL;

  token += strspn(token, delim);
 8003e2a:	4620      	mov	r0, r4
 8003e2c:	490b      	ldr	r1, [pc, #44]	; (8003e5c <_strtok.constprop.2+0x3c>)
 8003e2e:	f002 fd1f 	bl	8006870 <strspn>
 8003e32:	4404      	add	r4, r0
  *saveptr = strpbrk(token, delim);
 8003e34:	4620      	mov	r0, r4
 8003e36:	4909      	ldr	r1, [pc, #36]	; (8003e5c <_strtok.constprop.2+0x3c>)
 8003e38:	f002 fcf2 	bl	8006820 <strpbrk>
  if (*saveptr)
 8003e3c:	b160      	cbz	r0, 8003e58 <_strtok.constprop.2+0x38>
    *(*saveptr)++ = '\0';
 8003e3e:	1c42      	adds	r2, r0, #1
 8003e40:	2300      	movs	r3, #0
 8003e42:	602a      	str	r2, [r5, #0]
 8003e44:	7003      	strb	r3, [r0, #0]

  return *token ? token : NULL;
 8003e46:	7823      	ldrb	r3, [r4, #0]
 8003e48:	b123      	cbz	r3, 8003e54 <_strtok.constprop.2+0x34>
 8003e4a:	4620      	mov	r0, r4
}
 8003e4c:	bd38      	pop	{r3, r4, r5, pc}

static char *_strtok(char *str, const char *delim, char **saveptr) {
  char *token;
  if (str)
    *saveptr = str;
  token = *saveptr;
 8003e4e:	680c      	ldr	r4, [r1, #0]

  if (!token)
 8003e50:	2c00      	cmp	r4, #0
 8003e52:	d1ea      	bne.n	8003e2a <_strtok.constprop.2+0xa>
    return NULL;
 8003e54:	2000      	movs	r0, #0
 8003e56:	bd38      	pop	{r3, r4, r5, pc}

  token += strspn(token, delim);
  *saveptr = strpbrk(token, delim);
 8003e58:	6028      	str	r0, [r5, #0]
 8003e5a:	e7f4      	b.n	8003e46 <_strtok.constprop.2+0x26>
 8003e5c:	08006c6c 	.word	0x08006c6c

08003e60 <shellInit>:
 8003e60:	4b01      	ldr	r3, [pc, #4]	; (8003e68 <shellInit+0x8>)
 8003e62:	601b      	str	r3, [r3, #0]
 8003e64:	4770      	bx	lr
 8003e66:	bf00      	nop
 8003e68:	20001338 	.word	0x20001338
 8003e6c:	f3af 8000 	nop.w

08003e70 <shellExit>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
 8003e70:	b510      	push	{r4, lr}
 8003e72:	2320      	movs	r3, #32
 8003e74:	4604      	mov	r4, r0
 8003e76:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, 0);
 8003e7a:	4804      	ldr	r0, [pc, #16]	; (8003e8c <shellExit+0x1c>)
 8003e7c:	2100      	movs	r1, #0
 8003e7e:	f7fd fd87 	bl	8001990 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 8003e82:	4620      	mov	r0, r4
}
 8003e84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 8003e88:	f7fd bbc2 	b.w	8001610 <chThdExitS>
 8003e8c:	20001338 	.word	0x20001338

08003e90 <shellCreate>:
 * @retval NULL         thread creation failed because memory allocation.
 *
 * @api
 */
#if CH_CFG_USE_HEAP && CH_CFG_USE_DYNAMIC
thread_t *shellCreate(const ShellConfig *scp, size_t size, tprio_t prio) {
 8003e90:	b500      	push	{lr}
 8003e92:	b083      	sub	sp, #12

  return chThdCreateFromHeap(NULL, size, prio, shell_thread, (void *)scp);
 8003e94:	4b03      	ldr	r3, [pc, #12]	; (8003ea4 <shellCreate+0x14>)
 8003e96:	9000      	str	r0, [sp, #0]
 8003e98:	2000      	movs	r0, #0
 8003e9a:	f7fd fc79 	bl	8001790 <chThdCreateFromHeap>
}
 8003e9e:	b003      	add	sp, #12
 8003ea0:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ea4:	08003f51 	.word	0x08003f51
 8003ea8:	f3af 8000 	nop.w
 8003eac:	f3af 8000 	nop.w

08003eb0 <shellGetLine>:
 * @retval TRUE         the channel was reset or CTRL-D pressed.
 * @retval FALSE        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 8003eb0:	b5f0      	push	{r4, r5, r6, r7, lr}
      *p = 0;
      return FALSE;
    }
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 8003eb2:	3a01      	subs	r2, #1
 * @retval TRUE         the channel was reset or CTRL-D pressed.
 * @retval FALSE        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 8003eb4:	b083      	sub	sp, #12
 8003eb6:	460e      	mov	r6, r1
      *p = 0;
      return FALSE;
    }
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 8003eb8:	188f      	adds	r7, r1, r2
 * @retval TRUE         the channel was reset or CTRL-D pressed.
 * @retval FALSE        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 8003eba:	4604      	mov	r4, r0
 8003ebc:	460d      	mov	r5, r1
  char *p = line;

  while (TRUE) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
 8003ebe:	6823      	ldr	r3, [r4, #0]
 8003ec0:	4620      	mov	r0, r4
 8003ec2:	685b      	ldr	r3, [r3, #4]
 8003ec4:	f10d 0107 	add.w	r1, sp, #7
 8003ec8:	2201      	movs	r2, #1
 8003eca:	4798      	blx	r3
 8003ecc:	b348      	cbz	r0, 8003f22 <shellGetLine+0x72>
      return TRUE;
    if (c == 4) {
 8003ece:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8003ed2:	2904      	cmp	r1, #4
 8003ed4:	d028      	beq.n	8003f28 <shellGetLine+0x78>
      chprintf(chp, "^D");
      return TRUE;
    }
    if ((c == 8) || (c == 127)) {
 8003ed6:	2908      	cmp	r1, #8
 8003ed8:	d010      	beq.n	8003efc <shellGetLine+0x4c>
 8003eda:	297f      	cmp	r1, #127	; 0x7f
 8003edc:	d00e      	beq.n	8003efc <shellGetLine+0x4c>
        chSequentialStreamPut(chp, c);
        p--;
      }
      continue;
    }
    if (c == '\r') {
 8003ede:	290d      	cmp	r1, #13
 8003ee0:	d029      	beq.n	8003f36 <shellGetLine+0x86>
      chprintf(chp, "\r\n");
      *p = 0;
      return FALSE;
    }
    if (c < 0x20)
 8003ee2:	291f      	cmp	r1, #31
 8003ee4:	d9eb      	bls.n	8003ebe <shellGetLine+0xe>
      continue;
    if (p < line + size - 1) {
 8003ee6:	42bd      	cmp	r5, r7
 8003ee8:	d2e9      	bcs.n	8003ebe <shellGetLine+0xe>
      chSequentialStreamPut(chp, c);
 8003eea:	6823      	ldr	r3, [r4, #0]
 8003eec:	4620      	mov	r0, r4
 8003eee:	689b      	ldr	r3, [r3, #8]
 8003ef0:	4798      	blx	r3
      *p++ = (char)c;
 8003ef2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003ef6:	702b      	strb	r3, [r5, #0]
 8003ef8:	3501      	adds	r5, #1
 8003efa:	e7e0      	b.n	8003ebe <shellGetLine+0xe>
    if (c == 4) {
      chprintf(chp, "^D");
      return TRUE;
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
 8003efc:	42b5      	cmp	r5, r6
        chSequentialStreamPut(chp, c);
 8003efe:	4620      	mov	r0, r4
    if (c == 4) {
      chprintf(chp, "^D");
      return TRUE;
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
 8003f00:	d0dd      	beq.n	8003ebe <shellGetLine+0xe>
        chSequentialStreamPut(chp, c);
 8003f02:	6823      	ldr	r3, [r4, #0]
 8003f04:	689b      	ldr	r3, [r3, #8]
 8003f06:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x20);
 8003f08:	6823      	ldr	r3, [r4, #0]
 8003f0a:	4620      	mov	r0, r4
 8003f0c:	689b      	ldr	r3, [r3, #8]
 8003f0e:	2120      	movs	r1, #32
 8003f10:	4798      	blx	r3
        chSequentialStreamPut(chp, c);
 8003f12:	6823      	ldr	r3, [r4, #0]
 8003f14:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8003f18:	689b      	ldr	r3, [r3, #8]
 8003f1a:	4620      	mov	r0, r4
        p--;
 8003f1c:	3d01      	subs	r5, #1
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
        chSequentialStreamPut(chp, c);
        chSequentialStreamPut(chp, 0x20);
        chSequentialStreamPut(chp, c);
 8003f1e:	4798      	blx	r3
 8003f20:	e7cd      	b.n	8003ebe <shellGetLine+0xe>

  while (TRUE) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
      return TRUE;
 8003f22:	2001      	movs	r0, #1
    if (p < line + size - 1) {
      chSequentialStreamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
 8003f24:	b003      	add	sp, #12
 8003f26:	bdf0      	pop	{r4, r5, r6, r7, pc}
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
      return TRUE;
    if (c == 4) {
      chprintf(chp, "^D");
 8003f28:	4620      	mov	r0, r4
 8003f2a:	4907      	ldr	r1, [pc, #28]	; (8003f48 <shellGetLine+0x98>)
 8003f2c:	f7ff fef0 	bl	8003d10 <chprintf>
      return TRUE;
 8003f30:	2001      	movs	r0, #1
    if (p < line + size - 1) {
      chSequentialStreamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
 8003f32:	b003      	add	sp, #12
 8003f34:	bdf0      	pop	{r4, r5, r6, r7, pc}
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, "\r\n");
 8003f36:	4620      	mov	r0, r4
 8003f38:	4904      	ldr	r1, [pc, #16]	; (8003f4c <shellGetLine+0x9c>)
 8003f3a:	f7ff fee9 	bl	8003d10 <chprintf>
      *p = 0;
 8003f3e:	2000      	movs	r0, #0
 8003f40:	7028      	strb	r0, [r5, #0]
    if (p < line + size - 1) {
      chSequentialStreamPut(chp, c);
      *p++ = (char)c;
    }
  }
}
 8003f42:	b003      	add	sp, #12
 8003f44:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003f46:	bf00      	nop
 8003f48:	08006c70 	.word	0x08006c70
 8003f4c:	08006c0c 	.word	0x08006c0c

08003f50 <shell_thread>:
 * @param[in] p         pointer to a @p BaseSequentialStream object
 * @return              Termination reason.
 * @retval MSG_OK       terminated by command.
 * @retval MSG_RESET    terminated by reset condition on the I/O channel.
 */
static msg_t shell_thread(void *p) {
 8003f50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
 8003f54:	4b56      	ldr	r3, [pc, #344]	; (80040b0 <shell_thread+0x160>)
 * @retval MSG_OK       terminated by command.
 * @retval MSG_RESET    terminated by reset condition on the I/O channel.
 */
static msg_t shell_thread(void *p) {
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
 8003f56:	6806      	ldr	r6, [r0, #0]
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
 8003f58:	699b      	ldr	r3, [r3, #24]
 8003f5a:	4a56      	ldr	r2, [pc, #344]	; (80040b4 <shell_thread+0x164>)
 * @retval MSG_RESET    terminated by reset condition on the I/O channel.
 */
static msg_t shell_thread(void *p) {
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
 8003f5c:	f8d0 8004 	ldr.w	r8, [r0, #4]
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 8003f60:	4955      	ldr	r1, [pc, #340]	; (80040b8 <shell_thread+0x168>)
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
 8003f62:	619a      	str	r2, [r3, #24]
 * @param[in] p         pointer to a @p BaseSequentialStream object
 * @return              Termination reason.
 * @retval MSG_OK       terminated by command.
 * @retval MSG_RESET    terminated by reset condition on the I/O channel.
 */
static msg_t shell_thread(void *p) {
 8003f64:	b096      	sub	sp, #88	; 0x58
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 8003f66:	4630      	mov	r0, r6
 8003f68:	f7ff fed2 	bl	8003d10 <chprintf>
  while (TRUE) {
    chprintf(chp, "ch> ");
 8003f6c:	4953      	ldr	r1, [pc, #332]	; (80040bc <shell_thread+0x16c>)
 8003f6e:	4630      	mov	r0, r6
 8003f70:	f7ff fece 	bl	8003d10 <chprintf>
    if (shellGetLine(chp, line, sizeof(line))) {
 8003f74:	4630      	mov	r0, r6
 8003f76:	a906      	add	r1, sp, #24
 8003f78:	2240      	movs	r2, #64	; 0x40
 8003f7a:	f7ff ff99 	bl	8003eb0 <shellGetLine>
 8003f7e:	4604      	mov	r4, r0
 8003f80:	bb78      	cbnz	r0, 8003fe2 <shell_thread+0x92>
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 8003f82:	4669      	mov	r1, sp
 8003f84:	a806      	add	r0, sp, #24
 8003f86:	f7ff ff4b 	bl	8003e20 <_strtok.constprop.2>
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8003f8a:	4669      	mov	r1, sp
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 8003f8c:	4607      	mov	r7, r0
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8003f8e:	2000      	movs	r0, #0
 8003f90:	ad01      	add	r5, sp, #4
 8003f92:	f7ff ff45 	bl	8003e20 <_strtok.constprop.2>
 8003f96:	b150      	cbz	r0, 8003fae <shell_thread+0x5e>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8003f98:	2c04      	cmp	r4, #4
 8003f9a:	d01b      	beq.n	8003fd4 <shell_thread+0x84>
        chprintf(chp, "too many arguments\r\n");
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 8003f9c:	f845 0b04 	str.w	r0, [r5], #4
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8003fa0:	4669      	mov	r1, sp
 8003fa2:	2000      	movs	r0, #0
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments\r\n");
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 8003fa4:	3401      	adds	r4, #1
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8003fa6:	f7ff ff3b 	bl	8003e20 <_strtok.constprop.2>
 8003faa:	2800      	cmp	r0, #0
 8003fac:	d1f4      	bne.n	8003f98 <shell_thread+0x48>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 8003fae:	ab16      	add	r3, sp, #88	; 0x58
 8003fb0:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8003fb4:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
 8003fb8:	2f00      	cmp	r7, #0
 8003fba:	d0d7      	beq.n	8003f6c <shell_thread+0x1c>
      if (strcasecmp(cmd, "exit") == 0) {
 8003fbc:	4638      	mov	r0, r7
 8003fbe:	4940      	ldr	r1, [pc, #256]	; (80040c0 <shell_thread+0x170>)
 8003fc0:	f002 fc06 	bl	80067d0 <strcasecmp>
 8003fc4:	b9c0      	cbnz	r0, 8003ff8 <shell_thread+0xa8>
        if (n > 0) {
 8003fc6:	b184      	cbz	r4, 8003fea <shell_thread+0x9a>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8003fc8:	4630      	mov	r0, r6
 8003fca:	493e      	ldr	r1, [pc, #248]	; (80040c4 <shell_thread+0x174>)
 8003fcc:	4a3c      	ldr	r2, [pc, #240]	; (80040c0 <shell_thread+0x170>)
 8003fce:	f7ff fe9f 	bl	8003d10 <chprintf>
    args[n] = NULL;
    if (cmd != NULL) {
      if (strcasecmp(cmd, "exit") == 0) {
        if (n > 0) {
          usage(chp, "exit");
          continue;
 8003fd2:	e7cb      	b.n	8003f6c <shell_thread+0x1c>
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments\r\n");
 8003fd4:	4630      	mov	r0, r6
 8003fd6:	493c      	ldr	r1, [pc, #240]	; (80040c8 <shell_thread+0x178>)
 8003fd8:	f7ff fe9a 	bl	8003d10 <chprintf>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 8003fdc:	2300      	movs	r3, #0
 8003fde:	9305      	str	r3, [sp, #20]
 8003fe0:	e7c4      	b.n	8003f6c <shell_thread+0x1c>
  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
  while (TRUE) {
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
 8003fe2:	4630      	mov	r0, r6
 8003fe4:	4939      	ldr	r1, [pc, #228]	; (80040cc <shell_thread+0x17c>)
 8003fe6:	f7ff fe93 	bl	8003d10 <chprintf>
        chprintf(chp, "%s", cmd);
        chprintf(chp, " ?\r\n");
      }
    }
  }
  shellExit(MSG_OK);
 8003fea:	2000      	movs	r0, #0
 8003fec:	f7ff ff40 	bl	8003e70 <shellExit>
  /* Never executed, silencing a warning.*/
  return 0;
}
 8003ff0:	2000      	movs	r0, #0
 8003ff2:	b016      	add	sp, #88	; 0x58
 8003ff4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          usage(chp, "exit");
          continue;
        }
        break;
      }
      else if (strcasecmp(cmd, "help") == 0) {
 8003ff8:	4638      	mov	r0, r7
 8003ffa:	4935      	ldr	r1, [pc, #212]	; (80040d0 <shell_thread+0x180>)
 8003ffc:	f002 fbe8 	bl	80067d0 <strcasecmp>
 8004000:	b930      	cbnz	r0, 8004010 <shell_thread+0xc0>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8004002:	4630      	mov	r0, r6
          continue;
        }
        break;
      }
      else if (strcasecmp(cmd, "help") == 0) {
        if (n > 0) {
 8004004:	b1b4      	cbz	r4, 8004034 <shell_thread+0xe4>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8004006:	492f      	ldr	r1, [pc, #188]	; (80040c4 <shell_thread+0x174>)
 8004008:	4a31      	ldr	r2, [pc, #196]	; (80040d0 <shell_thread+0x180>)
 800400a:	f7ff fe81 	bl	8003d10 <chprintf>
        break;
      }
      else if (strcasecmp(cmd, "help") == 0) {
        if (n > 0) {
          usage(chp, "help");
          continue;
 800400e:	e7ad      	b.n	8003f6c <shell_thread+0x1c>
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8004010:	4d30      	ldr	r5, [pc, #192]	; (80040d4 <shell_thread+0x184>)
 8004012:	6828      	ldr	r0, [r5, #0]
 8004014:	b918      	cbnz	r0, 800401e <shell_thread+0xce>
 8004016:	e030      	b.n	800407a <shell_thread+0x12a>
 8004018:	f855 0f08 	ldr.w	r0, [r5, #8]!
 800401c:	b368      	cbz	r0, 800407a <shell_thread+0x12a>
    if (strcasecmp(scp->sc_name, name) == 0) {
 800401e:	4639      	mov	r1, r7
 8004020:	f002 fbd6 	bl	80067d0 <strcasecmp>
 8004024:	2800      	cmp	r0, #0
 8004026:	d1f7      	bne.n	8004018 <shell_thread+0xc8>
      scp->sc_function(chp, argc, argv);
 8004028:	686b      	ldr	r3, [r5, #4]
 800402a:	4621      	mov	r1, r4
 800402c:	4630      	mov	r0, r6
 800402e:	aa01      	add	r2, sp, #4
 8004030:	4798      	blx	r3
 8004032:	e79b      	b.n	8003f6c <shell_thread+0x1c>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8004034:	4d27      	ldr	r5, [pc, #156]	; (80040d4 <shell_thread+0x184>)
      else if (strcasecmp(cmd, "help") == 0) {
        if (n > 0) {
          usage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help exit ");
 8004036:	4928      	ldr	r1, [pc, #160]	; (80040d8 <shell_thread+0x188>)
 8004038:	f7ff fe6a 	bl	8003d10 <chprintf>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 800403c:	682a      	ldr	r2, [r5, #0]
 800403e:	462c      	mov	r4, r5
 8004040:	b13a      	cbz	r2, 8004052 <shell_thread+0x102>
    chprintf(chp, "%s ", scp->sc_name);
 8004042:	4630      	mov	r0, r6
 8004044:	4925      	ldr	r1, [pc, #148]	; (80040dc <shell_thread+0x18c>)
 8004046:	f7ff fe63 	bl	8003d10 <chprintf>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 800404a:	f854 2f08 	ldr.w	r2, [r4, #8]!
 800404e:	2a00      	cmp	r2, #0
 8004050:	d1f7      	bne.n	8004042 <shell_thread+0xf2>
          usage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help exit ");
        list_commands(chp, local_commands);
        if (scp != NULL)
 8004052:	f1b8 0f00 	cmp.w	r8, #0
 8004056:	d00b      	beq.n	8004070 <shell_thread+0x120>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8004058:	f8d8 2000 	ldr.w	r2, [r8]
 800405c:	b142      	cbz	r2, 8004070 <shell_thread+0x120>
 800405e:	4644      	mov	r4, r8
    chprintf(chp, "%s ", scp->sc_name);
 8004060:	4630      	mov	r0, r6
 8004062:	491e      	ldr	r1, [pc, #120]	; (80040dc <shell_thread+0x18c>)
 8004064:	f7ff fe54 	bl	8003d10 <chprintf>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8004068:	f854 2f08 	ldr.w	r2, [r4, #8]!
 800406c:	2a00      	cmp	r2, #0
 800406e:	d1f7      	bne.n	8004060 <shell_thread+0x110>
        }
        chprintf(chp, "Commands: help exit ");
        list_commands(chp, local_commands);
        if (scp != NULL)
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
 8004070:	4630      	mov	r0, r6
 8004072:	491b      	ldr	r1, [pc, #108]	; (80040e0 <shell_thread+0x190>)
 8004074:	f7ff fe4c 	bl	8003d10 <chprintf>
 8004078:	e778      	b.n	8003f6c <shell_thread+0x1c>
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 800407a:	f1b8 0f00 	cmp.w	r8, #0
 800407e:	d00d      	beq.n	800409c <shell_thread+0x14c>
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8004080:	f8d8 0000 	ldr.w	r0, [r8]
 8004084:	b150      	cbz	r0, 800409c <shell_thread+0x14c>
 8004086:	4645      	mov	r5, r8
 8004088:	e002      	b.n	8004090 <shell_thread+0x140>
 800408a:	f855 0f08 	ldr.w	r0, [r5, #8]!
 800408e:	b128      	cbz	r0, 800409c <shell_thread+0x14c>
    if (strcasecmp(scp->sc_name, name) == 0) {
 8004090:	4639      	mov	r1, r7
 8004092:	f002 fb9d 	bl	80067d0 <strcasecmp>
 8004096:	2800      	cmp	r0, #0
 8004098:	d1f7      	bne.n	800408a <shell_thread+0x13a>
 800409a:	e7c5      	b.n	8004028 <shell_thread+0xd8>
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
        chprintf(chp, "%s", cmd);
 800409c:	463a      	mov	r2, r7
 800409e:	4630      	mov	r0, r6
 80040a0:	4910      	ldr	r1, [pc, #64]	; (80040e4 <shell_thread+0x194>)
 80040a2:	f7ff fe35 	bl	8003d10 <chprintf>
        chprintf(chp, " ?\r\n");
 80040a6:	4630      	mov	r0, r6
 80040a8:	490f      	ldr	r1, [pc, #60]	; (80040e8 <shell_thread+0x198>)
 80040aa:	f7ff fe31 	bl	8003d10 <chprintf>
 80040ae:	e75d      	b.n	8003f6c <shell_thread+0x1c>
 80040b0:	20000ef0 	.word	0x20000ef0
 80040b4:	08006c74 	.word	0x08006c74
 80040b8:	08006c7c 	.word	0x08006c7c
 80040bc:	08006c94 	.word	0x08006c94
 80040c0:	08006cc0 	.word	0x08006cc0
 80040c4:	08006ac0 	.word	0x08006ac0
 80040c8:	08006ca8 	.word	0x08006ca8
 80040cc:	08006c9c 	.word	0x08006c9c
 80040d0:	08006cc8 	.word	0x08006cc8
 80040d4:	20000800 	.word	0x20000800
 80040d8:	08006cd0 	.word	0x08006cd0
 80040dc:	08006ce8 	.word	0x08006ce8
 80040e0:	08006c0c 	.word	0x08006c0c
 80040e4:	08006cec 	.word	0x08006cec
 80040e8:	08006cf0 	.word	0x08006cf0
 80040ec:	f3af 8000 	nop.w

080040f0 <long_to_string_with_divisor.constprop.0>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 80040f0:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 80040f2:	f100 070b 	add.w	r7, r0, #11
 80040f6:	463c      	mov	r4, r7
 80040f8:	460d      	mov	r5, r1
  do {
    i = (int)(l % radix);
 80040fa:	fbb1 f6f2 	udiv	r6, r1, r2
 80040fe:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 8004102:	f101 0330 	add.w	r3, r1, #48	; 0x30
    if (i > '9')
 8004106:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8004108:	bfc8      	it	gt
 800410a:	f101 0337 	addgt.w	r3, r1, #55	; 0x37
    *--q = i;
 800410e:	b2db      	uxtb	r3, r3
 8004110:	f804 3d01 	strb.w	r3, [r4, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
 8004114:	fbb5 f5f2 	udiv	r5, r5, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 8004118:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 800411a:	2d00      	cmp	r5, #0
 800411c:	d1ed      	bne.n	80040fa <long_to_string_with_divisor.constprop.0+0xa>

  i = (int)(p + MAX_FILLER - q);
 800411e:	1b3a      	subs	r2, r7, r4
 8004120:	4402      	add	r2, r0
 8004122:	e001      	b.n	8004128 <long_to_string_with_divisor.constprop.0+0x38>
 8004124:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  do
    *p++ = *q++;
 8004128:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 800412c:	4290      	cmp	r0, r2
 800412e:	d1f9      	bne.n	8004124 <long_to_string_with_divisor.constprop.0+0x34>

  return p;
}
 8004130:	bcf0      	pop	{r4, r5, r6, r7}
 8004132:	4770      	bx	lr
 8004134:	f3af 8000 	nop.w
 8004138:	f3af 8000 	nop.w
 800413c:	f3af 8000 	nop.w

08004140 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8004140:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004144:	b087      	sub	sp, #28
 8004146:	4615      	mov	r5, r2
 8004148:	f10d 030d 	add.w	r3, sp, #13
 800414c:	aa03      	add	r2, sp, #12
 800414e:	1a9b      	subs	r3, r3, r2
 8004150:	4681      	mov	r9, r0
 8004152:	468a      	mov	sl, r1
 8004154:	9301      	str	r3, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8004156:	f04f 0800 	mov.w	r8, #0
 800415a:	468b      	mov	fp, r1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 800415c:	f89b 1000 	ldrb.w	r1, [fp]
 8004160:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 8004164:	b179      	cbz	r1, 8004186 <chvprintf+0x46>
      return n;
    if (c != '%') {
 8004166:	2925      	cmp	r1, #37	; 0x25
 8004168:	d011      	beq.n	800418e <chvprintf+0x4e>
      chSequentialStreamPut(chp, (uint8_t)c);
 800416a:	f8d9 2000 	ldr.w	r2, [r9]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 800416e:	469b      	mov	fp, r3
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
 8004170:	6892      	ldr	r2, [r2, #8]
 8004172:	4648      	mov	r0, r9
 8004174:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8004176:	f89b 1000 	ldrb.w	r1, [fp]
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
 800417a:	f108 0801 	add.w	r8, r8, #1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 800417e:	f10b 0301 	add.w	r3, fp, #1
    if (c == 0)
 8004182:	2900      	cmp	r1, #0
 8004184:	d1ef      	bne.n	8004166 <chvprintf+0x26>
      chSequentialStreamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8004186:	4640      	mov	r0, r8
 8004188:	b007      	add	sp, #28
 800418a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 800418e:	f89b 2001 	ldrb.w	r2, [fp, #1]
 8004192:	2a2d      	cmp	r2, #45	; 0x2d
 8004194:	bf03      	ittte	eq
 8004196:	f89b 2002 	ldrbeq.w	r2, [fp, #2]
      fmt++;
 800419a:	f10b 0302 	addeq.w	r3, fp, #2
      left_align = TRUE;
 800419e:	f04f 0a01 	moveq.w	sl, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 80041a2:	f04f 0a00 	movne.w	sl, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 80041a6:	2a30      	cmp	r2, #48	; 0x30
 80041a8:	bf03      	ittte	eq
 80041aa:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 80041ac:	3301      	addeq	r3, #1
      filler = '0';
 80041ae:	2730      	moveq	r7, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 80041b0:	2720      	movne	r7, #32
 80041b2:	1c59      	adds	r1, r3, #1
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 80041b4:	2600      	movs	r6, #0
 80041b6:	e006      	b.n	80041c6 <chvprintf+0x86>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 80041b8:	782b      	ldrb	r3, [r5, #0]
 80041ba:	3504      	adds	r5, #4
 80041bc:	f89b 2000 	ldrb.w	r2, [fp]
      else
        break;
      width = width * 10 + c;
 80041c0:	eb03 0640 	add.w	r6, r3, r0, lsl #1
 80041c4:	3101      	adds	r1, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 80041c6:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 80041ca:	b2db      	uxtb	r3, r3
 80041cc:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 80041ce:	468b      	mov	fp, r1
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 80041d0:	eb06 0086 	add.w	r0, r6, r6, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 80041d4:	d9f2      	bls.n	80041bc <chvprintf+0x7c>
        c -= '0';
      else if (c == '*')
 80041d6:	2a2a      	cmp	r2, #42	; 0x2a
 80041d8:	d0ee      	beq.n	80041b8 <chvprintf+0x78>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 80041da:	2a2e      	cmp	r2, #46	; 0x2e
 80041dc:	f04f 0100 	mov.w	r1, #0
 80041e0:	d043      	beq.n	800426a <chvprintf+0x12a>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80041e2:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 80041e6:	2b4c      	cmp	r3, #76	; 0x4c
 80041e8:	d04e      	beq.n	8004288 <chvprintf+0x148>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80041ea:	f1a2 0044 	sub.w	r0, r2, #68	; 0x44
 80041ee:	2834      	cmp	r0, #52	; 0x34
 80041f0:	f200 80f7 	bhi.w	80043e2 <chvprintf+0x2a2>
 80041f4:	e8df f010 	tbh	[pc, r0, lsl #1]
 80041f8:	00f500ea 	.word	0x00f500ea
 80041fc:	00f500f5 	.word	0x00f500f5
 8004200:	00ea00f5 	.word	0x00ea00f5
 8004204:	00f500f5 	.word	0x00f500f5
 8004208:	00f500f5 	.word	0x00f500f5
 800420c:	00e800f5 	.word	0x00e800f5
 8004210:	00f500f5 	.word	0x00f500f5
 8004214:	00f500f5 	.word	0x00f500f5
 8004218:	00dd00f5 	.word	0x00dd00f5
 800421c:	00f500f5 	.word	0x00f500f5
 8004220:	00f500f2 	.word	0x00f500f2
 8004224:	00f500f5 	.word	0x00f500f5
 8004228:	00f500f5 	.word	0x00f500f5
 800422c:	00f500f5 	.word	0x00f500f5
 8004230:	00f500f5 	.word	0x00f500f5
 8004234:	00a100f5 	.word	0x00a100f5
 8004238:	00f500ea 	.word	0x00f500ea
 800423c:	00f500f5 	.word	0x00f500f5
 8004240:	00ea00f5 	.word	0x00ea00f5
 8004244:	00f500f5 	.word	0x00f500f5
 8004248:	00f500f5 	.word	0x00f500f5
 800424c:	00e800f5 	.word	0x00e800f5
 8004250:	00f500f5 	.word	0x00f500f5
 8004254:	007100f5 	.word	0x007100f5
 8004258:	00dd00f5 	.word	0x00dd00f5
 800425c:	00f500f5 	.word	0x00f500f5
 8004260:	00f2      	.short	0x00f2
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 8004262:	782b      	ldrb	r3, [r5, #0]
 8004264:	3504      	adds	r5, #4
        else
          break;
        precision *= 10;
        precision += c;
 8004266:	eb03 0140 	add.w	r1, r3, r0, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 800426a:	f81b 2b01 	ldrb.w	r2, [fp], #1
        if (c >= '0' && c <= '9')
 800426e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8004272:	b2db      	uxtb	r3, r3
 8004274:	2b09      	cmp	r3, #9
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 8004276:	eb01 0081 	add.w	r0, r1, r1, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 800427a:	d9f4      	bls.n	8004266 <chvprintf+0x126>
          c -= '0';
        else if (c == '*')
 800427c:	2a2a      	cmp	r2, #42	; 0x2a
 800427e:	d0f0      	beq.n	8004262 <chvprintf+0x122>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8004280:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 8004284:	2b4c      	cmp	r3, #76	; 0x4c
 8004286:	d1b0      	bne.n	80041ea <chvprintf+0xaa>
      is_long = TRUE;
      if (*fmt)
 8004288:	f89b 3000 	ldrb.w	r3, [fp]
 800428c:	2b00      	cmp	r3, #0
 800428e:	f000 80a8 	beq.w	80043e2 <chvprintf+0x2a2>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8004292:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 8004296:	f10b 0b01 	add.w	fp, fp, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800429a:	2a34      	cmp	r2, #52	; 0x34
 800429c:	f200 80a0 	bhi.w	80043e0 <chvprintf+0x2a0>
 80042a0:	e8df f002 	tbb	[pc, r2]
 80042a4:	9e9e9e94 	.word	0x9e9e9e94
 80042a8:	9e9e949e 	.word	0x9e9e949e
 80042ac:	929e9e9e 	.word	0x929e9e9e
 80042b0:	9e9e9e9e 	.word	0x9e9e9e9e
 80042b4:	9e9e879e 	.word	0x9e9e879e
 80042b8:	9e9e9e9c 	.word	0x9e9e9e9c
 80042bc:	9e9e9e9e 	.word	0x9e9e9e9e
 80042c0:	4b9e9e9e 	.word	0x4b9e9e9e
 80042c4:	9e9e9e94 	.word	0x9e9e9e94
 80042c8:	9e9e949e 	.word	0x9e9e949e
 80042cc:	929e9e9e 	.word	0x929e9e9e
 80042d0:	1b9e9e9e 	.word	0x1b9e9e9e
 80042d4:	9e9e879e 	.word	0x9e9e879e
 80042d8:	9c          	.byte	0x9c
 80042d9:	00          	.byte	0x00
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 80042da:	682c      	ldr	r4, [r5, #0]
        s = "(null)";
 80042dc:	4b5a      	ldr	r3, [pc, #360]	; (8004448 <chvprintf+0x308>)
 80042de:	2c00      	cmp	r4, #0
 80042e0:	bf08      	it	eq
 80042e2:	461c      	moveq	r4, r3
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 80042e4:	3504      	adds	r5, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 80042e6:	7823      	ldrb	r3, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
 80042e8:	2900      	cmp	r1, #0
 80042ea:	f000 8094 	beq.w	8004416 <chvprintf+0x2d6>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 80042ee:	2b00      	cmp	r3, #0
 80042f0:	f000 8096 	beq.w	8004420 <chvprintf+0x2e0>
 80042f4:	3901      	subs	r1, #1
 80042f6:	4620      	mov	r0, r4
 80042f8:	e001      	b.n	80042fe <chvprintf+0x1be>
 80042fa:	3901      	subs	r1, #1
 80042fc:	d403      	bmi.n	8004306 <chvprintf+0x1c6>
 80042fe:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8004302:	2b00      	cmp	r3, #0
 8004304:	d1f9      	bne.n	80042fa <chvprintf+0x1ba>
 8004306:	1b00      	subs	r0, r0, r4
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8004308:	1a36      	subs	r6, r6, r0
 800430a:	1e43      	subs	r3, r0, #1
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 800430c:	2720      	movs	r7, #32
 800430e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8004312:	f1ba 0f00 	cmp.w	sl, #0
 8004316:	d01f      	beq.n	8004358 <chvprintf+0x218>
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8004318:	2b00      	cmp	r3, #0
 800431a:	9300      	str	r3, [sp, #0]
 800431c:	da34      	bge.n	8004388 <chvprintf+0x248>
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800431e:	2e00      	cmp	r6, #0
 8004320:	f43f af1c 	beq.w	800415c <chvprintf+0x1c>
 8004324:	4634      	mov	r4, r6
      chSequentialStreamPut(chp, (uint8_t)filler);
 8004326:	f8d9 3000 	ldr.w	r3, [r9]
 800432a:	4648      	mov	r0, r9
 800432c:	689b      	ldr	r3, [r3, #8]
 800432e:	4639      	mov	r1, r7
 8004330:	4798      	blx	r3
    while (--i >= 0) {
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8004332:	3c01      	subs	r4, #1
 8004334:	d1f7      	bne.n	8004326 <chvprintf+0x1e6>
 8004336:	44b0      	add	r8, r6
 8004338:	e710      	b.n	800415c <chvprintf+0x1c>

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 800433a:	682b      	ldr	r3, [r5, #0]
 800433c:	f88d 300c 	strb.w	r3, [sp, #12]
 8004340:	9b01      	ldr	r3, [sp, #4]
 8004342:	3504      	adds	r5, #4
 8004344:	4618      	mov	r0, r3
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 8004346:	2720      	movs	r7, #32
 8004348:	3b01      	subs	r3, #1
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 800434a:	ac03      	add	r4, sp, #12
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 800434c:	1a36      	subs	r6, r6, r0
 800434e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      width = 0;
    if (left_align == FALSE)
 8004352:	f1ba 0f00 	cmp.w	sl, #0
 8004356:	d1df      	bne.n	8004318 <chvprintf+0x1d8>
 8004358:	9300      	str	r3, [sp, #0]
      width = -width;
 800435a:	f1c6 0a00 	rsb	sl, r6, #0
    if (width < 0) {
 800435e:	f1ba 0f00 	cmp.w	sl, #0
 8004362:	d045      	beq.n	80043f0 <chvprintf+0x2b0>
      if (*s == '-' && filler == '0') {
 8004364:	7821      	ldrb	r1, [r4, #0]
 8004366:	292d      	cmp	r1, #45	; 0x2d
 8004368:	d047      	beq.n	80043fa <chvprintf+0x2ba>
        chSequentialStreamPut(chp, (uint8_t)*s++);
        n++;
 800436a:	4656      	mov	r6, sl
        i--;
      }
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
 800436c:	f8d9 3000 	ldr.w	r3, [r9]
 8004370:	4648      	mov	r0, r9
 8004372:	689b      	ldr	r3, [r3, #8]
 8004374:	4639      	mov	r1, r7
 8004376:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8004378:	3601      	adds	r6, #1
 800437a:	d1f7      	bne.n	800436c <chvprintf+0x22c>
    }
    while (--i >= 0) {
 800437c:	9b00      	ldr	r3, [sp, #0]
 800437e:	2b00      	cmp	r3, #0
 8004380:	ebca 0808 	rsb	r8, sl, r8
 8004384:	f6ff aeea 	blt.w	800415c <chvprintf+0x1c>
 8004388:	f8dd a000 	ldr.w	sl, [sp]
      chSequentialStreamPut(chp, (uint8_t)*s++);
 800438c:	f8d9 3000 	ldr.w	r3, [r9]
 8004390:	f814 1b01 	ldrb.w	r1, [r4], #1
 8004394:	689b      	ldr	r3, [r3, #8]
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8004396:	f10a 3aff 	add.w	sl, sl, #4294967295
      chSequentialStreamPut(chp, (uint8_t)*s++);
 800439a:	4648      	mov	r0, r9
 800439c:	4798      	blx	r3
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800439e:	f1ba 3fff 	cmp.w	sl, #4294967295
 80043a2:	d1f3      	bne.n	800438c <chvprintf+0x24c>
 80043a4:	9b00      	ldr	r3, [sp, #0]
 80043a6:	f108 0801 	add.w	r8, r8, #1
 80043aa:	2b00      	cmp	r3, #0
 80043ac:	bfa8      	it	ge
 80043ae:	4498      	addge	r8, r3
 80043b0:	e7b5      	b.n	800431e <chvprintf+0x1de>
      c = 16;
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
      goto unsigned_common;
 80043b2:	220a      	movs	r2, #10
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 80043b4:	6829      	ldr	r1, [r5, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80043b6:	a803      	add	r0, sp, #12
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 80043b8:	3504      	adds	r5, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80043ba:	f7ff fe99 	bl	80040f0 <long_to_string_with_divisor.constprop.0>
 80043be:	ab03      	add	r3, sp, #12
 80043c0:	1ac0      	subs	r0, r0, r3
 80043c2:	1e43      	subs	r3, r0, #1
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80043c4:	ac03      	add	r4, sp, #12
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
 80043c6:	e7c1      	b.n	800434c <chvprintf+0x20c>
 80043c8:	2208      	movs	r2, #8
 80043ca:	e7f3      	b.n	80043b4 <chvprintf+0x274>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 80043cc:	6829      	ldr	r1, [r5, #0]
      if (l < 0) {
 80043ce:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 80043d0:	f105 0504 	add.w	r5, r5, #4
      if (l < 0) {
 80043d4:	db2e      	blt.n	8004434 <chvprintf+0x2f4>
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 80043d6:	a803      	add	r0, sp, #12
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80043d8:	220a      	movs	r2, #10
 80043da:	e7ee      	b.n	80043ba <chvprintf+0x27a>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80043dc:	2210      	movs	r2, #16
 80043de:	e7e9      	b.n	80043b4 <chvprintf+0x274>
 80043e0:	461a      	mov	r2, r3
 80043e2:	9b01      	ldr	r3, [sp, #4]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 80043e4:	f88d 200c 	strb.w	r2, [sp, #12]
 80043e8:	4618      	mov	r0, r3
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80043ea:	ac03      	add	r4, sp, #12
 80043ec:	3b01      	subs	r3, #1
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
      break;
 80043ee:	e7ad      	b.n	800434c <chvprintf+0x20c>
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80043f0:	9b00      	ldr	r3, [sp, #0]
 80043f2:	2b00      	cmp	r3, #0
 80043f4:	4656      	mov	r6, sl
 80043f6:	dac7      	bge.n	8004388 <chvprintf+0x248>
 80043f8:	e6b0      	b.n	800415c <chvprintf+0x1c>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 80043fa:	2f30      	cmp	r7, #48	; 0x30
 80043fc:	d1b5      	bne.n	800436a <chvprintf+0x22a>
        chSequentialStreamPut(chp, (uint8_t)*s++);
 80043fe:	f8d9 3000 	ldr.w	r3, [r9]
 8004402:	4648      	mov	r0, r9
 8004404:	689b      	ldr	r3, [r3, #8]
 8004406:	4798      	blx	r3
 8004408:	9b00      	ldr	r3, [sp, #0]
 800440a:	3b01      	subs	r3, #1
 800440c:	3401      	adds	r4, #1
        n++;
 800440e:	f108 0801 	add.w	r8, r8, #1
 8004412:	9300      	str	r3, [sp, #0]
 8004414:	e7a9      	b.n	800436a <chvprintf+0x22a>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8004416:	f647 71fe 	movw	r1, #32766	; 0x7ffe
 800441a:	2b00      	cmp	r3, #0
 800441c:	f47f af6b 	bne.w	80042f6 <chvprintf+0x1b6>
 8004420:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8004424:	f1ba 0f00 	cmp.w	sl, #0
 8004428:	d10b      	bne.n	8004442 <chvprintf+0x302>
 800442a:	f04f 33ff 	mov.w	r3, #4294967295
 800442e:	9300      	str	r3, [sp, #0]
 8004430:	2720      	movs	r7, #32
 8004432:	e792      	b.n	800435a <chvprintf+0x21a>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8004434:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8004436:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8004438:	f88d 300c 	strb.w	r3, [sp, #12]
 800443c:	f10d 000d 	add.w	r0, sp, #13
 8004440:	e7ca      	b.n	80043d8 <chvprintf+0x298>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8004442:	2720      	movs	r7, #32
 8004444:	e76b      	b.n	800431e <chvprintf+0x1de>
 8004446:	bf00      	nop
 8004448:	08006d00 	.word	0x08006d00
 800444c:	f3af 8000 	nop.w

08004450 <atoh>:

int atoh(char *p, int *value) {
  int tmp = 0;
  int ret_val = 0;
  int loop_count = 0;
  while (*p != 0) {
 8004450:	7803      	ldrb	r3, [r0, #0]
 8004452:	b343      	cbz	r3, 80044a6 <atoh+0x56>

/* Code: */
/* #include "ch.h" */
/* #include "chprintf.h" */

int atoh(char *p, int *value) {
 8004454:	b4f0      	push	{r4, r5, r6, r7}
  int tmp = 0;
  int ret_val = 0;
  int loop_count = 0;
  while (*p != 0) {
 8004456:	2200      	movs	r2, #0
 8004458:	f100 0708 	add.w	r7, r0, #8
 800445c:	e005      	b.n	800446a <atoh+0x1a>
    tmp = tmp << 4;
    if ((*p>='0') && (*p<='9')) {
      tmp += (*p-'0');
 800445e:	4422      	add	r2, r4
    }      
    else {
      ret_val = 1;
      return(ret_val);
    }
    if (loop_count++>=8) {
 8004460:	42b8      	cmp	r0, r7
 8004462:	d014      	beq.n	800448e <atoh+0x3e>

int atoh(char *p, int *value) {
  int tmp = 0;
  int ret_val = 0;
  int loop_count = 0;
  while (*p != 0) {
 8004464:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8004468:	b1cb      	cbz	r3, 800449e <atoh+0x4e>
    tmp = tmp << 4;
    if ((*p>='0') && (*p<='9')) {
 800446a:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
 800446e:	b2e5      	uxtb	r5, r4
 8004470:	2d09      	cmp	r5, #9
      tmp += (*p-'0');
    }
    else if ((*p>='a') && (*p<='f')) {
 8004472:	f1a3 0661 	sub.w	r6, r3, #97	; 0x61
int atoh(char *p, int *value) {
  int tmp = 0;
  int ret_val = 0;
  int loop_count = 0;
  while (*p != 0) {
    tmp = tmp << 4;
 8004476:	ea4f 1202 	mov.w	r2, r2, lsl #4
    if ((*p>='0') && (*p<='9')) {
 800447a:	d9f0      	bls.n	800445e <atoh+0xe>
      tmp += (*p-'0');
    }
    else if ((*p>='a') && (*p<='f')) {
 800447c:	2e05      	cmp	r6, #5
      tmp += (*p-'a') + 10;
    }
    else if ((*p>='A') && (*p<='F')) {
 800447e:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
    tmp = tmp << 4;
    if ((*p>='0') && (*p<='9')) {
      tmp += (*p-'0');
    }
    else if ((*p>='a') && (*p<='f')) {
      tmp += (*p-'a') + 10;
 8004482:	f1a3 0557 	sub.w	r5, r3, #87	; 0x57
  while (*p != 0) {
    tmp = tmp << 4;
    if ((*p>='0') && (*p<='9')) {
      tmp += (*p-'0');
    }
    else if ((*p>='a') && (*p<='f')) {
 8004486:	d805      	bhi.n	8004494 <atoh+0x44>
    }      
    else {
      ret_val = 1;
      return(ret_val);
    }
    if (loop_count++>=8) {
 8004488:	42b8      	cmp	r0, r7
    tmp = tmp << 4;
    if ((*p>='0') && (*p<='9')) {
      tmp += (*p-'0');
    }
    else if ((*p>='a') && (*p<='f')) {
      tmp += (*p-'a') + 10;
 800448a:	442a      	add	r2, r5
    }      
    else {
      ret_val = 1;
      return(ret_val);
    }
    if (loop_count++>=8) {
 800448c:	d1ea      	bne.n	8004464 <atoh+0x14>
    else if ((*p>='A') && (*p<='F')) {
      tmp += (*p-'A') + 10;
    }      
    else {
      ret_val = 1;
      return(ret_val);
 800448e:	2001      	movs	r0, #1
    }     
    p++;
  }
  *value = tmp;
  return(ret_val);
}
 8004490:	bcf0      	pop	{r4, r5, r6, r7}
 8004492:	4770      	bx	lr
      tmp += (*p-'0');
    }
    else if ((*p>='a') && (*p<='f')) {
      tmp += (*p-'a') + 10;
    }
    else if ((*p>='A') && (*p<='F')) {
 8004494:	2c05      	cmp	r4, #5
 8004496:	d8fa      	bhi.n	800448e <atoh+0x3e>
      tmp += (*p-'A') + 10;
 8004498:	3b37      	subs	r3, #55	; 0x37
 800449a:	441a      	add	r2, r3
 800449c:	e7e0      	b.n	8004460 <atoh+0x10>
      return(ret_val);
    }     
    p++;
  }
  *value = tmp;
  return(ret_val);
 800449e:	2000      	movs	r0, #0
      ret_val = 1;
      return(ret_val);
    }     
    p++;
  }
  *value = tmp;
 80044a0:	600a      	str	r2, [r1, #0]
  return(ret_val);
}
 80044a2:	bcf0      	pop	{r4, r5, r6, r7}
 80044a4:	4770      	bx	lr
      ret_val = 1;
      return(ret_val);
    }     
    p++;
  }
  *value = tmp;
 80044a6:	600b      	str	r3, [r1, #0]
  return(ret_val);
 80044a8:	2000      	movs	r0, #0
}
 80044aa:	4770      	bx	lr
 80044ac:	f3af 8000 	nop.w

080044b0 <convFloat>:
#include "arm_math.h"

static double PRECISION = 0.00000001;
// static int MAX_NUMBER_STRING_SIZE = 32;

char * convFloat(char *s, float n) {
 80044b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80044b4:	b085      	sub	sp, #20
 80044b6:	ee10 ba10 	vmov	fp, s0
 80044ba:	9001      	str	r0, [sp, #4]
  // handle special cases
  if (isnan(n)) {
 80044bc:	f000 fd00 	bl	8004ec0 <__fpclassifyf>
 80044c0:	2800      	cmp	r0, #0
 80044c2:	f000 8099 	beq.w	80045f8 <convFloat+0x148>
    strcpy(s, "nan");
  } else if (isinf(n)) {
 80044c6:	ee00 ba10 	vmov	s0, fp
 80044ca:	f000 fcf9 	bl	8004ec0 <__fpclassifyf>
 80044ce:	2801      	cmp	r0, #1
 80044d0:	f000 812d 	beq.w	800472e <convFloat+0x27e>
    strcpy(s, "inf");
  } else if (n == 0.0) {
 80044d4:	ee07 ba90 	vmov	s15, fp
 80044d8:	eef5 7a40 	vcmp.f32	s15, #0.0
 80044dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80044e0:	f000 80aa 	beq.w	8004638 <convFloat+0x188>
    strcpy(s, "0");
  } else {
    int digit, m, m1;
    char *c = s;
    int neg = (n < 0);
    if (neg)
 80044e4:	ee07 ba90 	vmov	s15, fp
 80044e8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80044ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80044f0:	f140 808a 	bpl.w	8004608 <convFloat+0x158>
      n = -n;
 80044f4:	f08b 4b00 	eor.w	fp, fp, #2147483648	; 0x80000000
    // calculate magnitude
    m = log10(n);
 80044f8:	4658      	mov	r0, fp
 80044fa:	f7fc f8dd 	bl	80006b8 <__aeabi_f2d>
 80044fe:	4606      	mov	r6, r0
 8004500:	460f      	mov	r7, r1
 8004502:	ec47 6b10 	vmov	d0, r6, r7
 8004506:	f000 fcfb 	bl	8004f00 <log10>
 800450a:	ec51 0b10 	vmov	r0, r1, d0
 800450e:	f7fc fbc7 	bl	8000ca0 <__aeabi_d2iz>
    int useExp = (m >= 14 || (neg && m >= 9) || m <= -9);
 8004512:	280d      	cmp	r0, #13
    char *c = s;
    int neg = (n < 0);
    if (neg)
      n = -n;
    // calculate magnitude
    m = log10(n);
 8004514:	4605      	mov	r5, r0
    int useExp = (m >= 14 || (neg && m >= 9) || m <= -9);
 8004516:	f340 8097 	ble.w	8004648 <convFloat+0x198>
    if (neg)
      *(c++) = '-';
 800451a:	9901      	ldr	r1, [sp, #4]
 800451c:	232d      	movs	r3, #45	; 0x2d
 800451e:	700b      	strb	r3, [r1, #0]
 8004520:	f101 0a01 	add.w	sl, r1, #1
    char *c = s;
    int neg = (n < 0);
    if (neg)
      n = -n;
    // calculate magnitude
    m = log10(n);
 8004524:	462c      	mov	r4, r5
    int useExp = (m >= 14 || (neg && m >= 9) || m <= -9);
    if (neg)
      *(c++) = '-';
    // set up for scientific notation
    if (useExp) {
      if (m < 0)
 8004526:	2d00      	cmp	r5, #0
 8004528:	f2c0 80f4 	blt.w	8004714 <convFloat+0x264>
	m -= 1.0;
      n = n / pow(10.0, m);
 800452c:	4620      	mov	r0, r4
 800452e:	f7fc f8b1 	bl	8000694 <__aeabi_i2d>
 8004532:	ed9f 0b8b 	vldr	d0, [pc, #556]	; 8004760 <convFloat+0x2b0>
 8004536:	ec41 0b11 	vmov	d1, r0, r1
 800453a:	f000 fd69 	bl	8005010 <pow>
 800453e:	4630      	mov	r0, r6
 8004540:	ec53 2b10 	vmov	r2, r3, d0
 8004544:	4639      	mov	r1, r7
 8004546:	f7fc fa35 	bl	80009b4 <__aeabi_ddiv>
 800454a:	f7fc fbd1 	bl	8000cf0 <__aeabi_d2f>
 800454e:	2301      	movs	r3, #1
 8004550:	4683      	mov	fp, r0
 8004552:	9302      	str	r3, [sp, #8]
      m1 = m;
      m = 0;
    }
    if (m < 1.0) {
      m = 0;
 8004554:	2500      	movs	r5, #0
 8004556:	9403      	str	r4, [sp, #12]
    }
    // convert the number
    while (n > PRECISION || m >= 0) {
 8004558:	4658      	mov	r0, fp
 800455a:	f7fc f8ad 	bl	80006b8 <__aeabi_f2d>
 800455e:	a386      	add	r3, pc, #536	; (adr r3, 8004778 <convFloat+0x2c8>)
 8004560:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004564:	4680      	mov	r8, r0
 8004566:	4689      	mov	r9, r1
 8004568:	f7fc fb90 	bl	8000c8c <__aeabi_dcmpgt>
 800456c:	b910      	cbnz	r0, 8004574 <convFloat+0xc4>
 800456e:	2d00      	cmp	r5, #0
 8004570:	f2c0 8087 	blt.w	8004682 <convFloat+0x1d2>
      double weight = pow(10.0, m);
 8004574:	4628      	mov	r0, r5
 8004576:	f7fc f88d 	bl	8000694 <__aeabi_i2d>
 800457a:	ed9f 0b79 	vldr	d0, [pc, #484]	; 8004760 <convFloat+0x2b0>
 800457e:	ec41 0b11 	vmov	d1, r0, r1
 8004582:	f000 fd45 	bl	8005010 <pow>
 8004586:	ec57 6b10 	vmov	r6, r7, d0
      if (weight > 0 && !isinf(weight)) {
 800458a:	ee10 0a10 	vmov	r0, s0
 800458e:	4639      	mov	r1, r7
 8004590:	2200      	movs	r2, #0
 8004592:	2300      	movs	r3, #0
 8004594:	f7fc fb7a 	bl	8000c8c <__aeabi_dcmpgt>
 8004598:	ec47 6b10 	vmov	d0, r6, r7
 800459c:	b338      	cbz	r0, 80045ee <convFloat+0x13e>
 800459e:	f000 fc5f 	bl	8004e60 <__fpclassifyd>
 80045a2:	2801      	cmp	r0, #1
	digit = floor(n / weight);
 80045a4:	4632      	mov	r2, r6
 80045a6:	463b      	mov	r3, r7
 80045a8:	4640      	mov	r0, r8
 80045aa:	4649      	mov	r1, r9
      m = 0;
    }
    // convert the number
    while (n > PRECISION || m >= 0) {
      double weight = pow(10.0, m);
      if (weight > 0 && !isinf(weight)) {
 80045ac:	d01f      	beq.n	80045ee <convFloat+0x13e>
	digit = floor(n / weight);
 80045ae:	f7fc fa01 	bl	80009b4 <__aeabi_ddiv>
 80045b2:	ec41 0b10 	vmov	d0, r0, r1
 80045b6:	f000 fbc3 	bl	8004d40 <floor>
 80045ba:	ec51 0b10 	vmov	r0, r1, d0
 80045be:	f7fc fb6f 	bl	8000ca0 <__aeabi_d2iz>
 80045c2:	4604      	mov	r4, r0
	n -= (digit * weight);
 80045c4:	f7fc f866 	bl	8000694 <__aeabi_i2d>
 80045c8:	4632      	mov	r2, r6
 80045ca:	463b      	mov	r3, r7
 80045cc:	f7fc f8c8 	bl	8000760 <__aeabi_dmul>
 80045d0:	4602      	mov	r2, r0
 80045d2:	460b      	mov	r3, r1
 80045d4:	4640      	mov	r0, r8
 80045d6:	4649      	mov	r1, r9
 80045d8:	f7fb ff0e 	bl	80003f8 <__aeabi_dsub>
 80045dc:	f7fc fb88 	bl	8000cf0 <__aeabi_d2f>
	*(c++) = '0' + digit;
 80045e0:	f104 0c30 	add.w	ip, r4, #48	; 0x30
 80045e4:	f88a c000 	strb.w	ip, [sl]
    // convert the number
    while (n > PRECISION || m >= 0) {
      double weight = pow(10.0, m);
      if (weight > 0 && !isinf(weight)) {
	digit = floor(n / weight);
	n -= (digit * weight);
 80045e8:	4683      	mov	fp, r0
	*(c++) = '0' + digit;
 80045ea:	f10a 0a01 	add.w	sl, sl, #1
      }
      if (m == 0 && n > 0)
 80045ee:	2d00      	cmp	r5, #0
 80045f0:	f000 80a5 	beq.w	800473e <convFloat+0x28e>
	*(c++) = '.';
      m--;
 80045f4:	3d01      	subs	r5, #1
 80045f6:	e7af      	b.n	8004558 <convFloat+0xa8>
// static int MAX_NUMBER_STRING_SIZE = 32;

char * convFloat(char *s, float n) {
  // handle special cases
  if (isnan(n)) {
    strcpy(s, "nan");
 80045f8:	4b5b      	ldr	r3, [pc, #364]	; (8004768 <convFloat+0x2b8>)
 80045fa:	6818      	ldr	r0, [r3, #0]
 80045fc:	9b01      	ldr	r3, [sp, #4]
 80045fe:	6018      	str	r0, [r3, #0]
      c += m;
    }
    *(c) = '\0';
  }
  return s;
}
 8004600:	9801      	ldr	r0, [sp, #4]
 8004602:	b005      	add	sp, #20
 8004604:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    char *c = s;
    int neg = (n < 0);
    if (neg)
      n = -n;
    // calculate magnitude
    m = log10(n);
 8004608:	4658      	mov	r0, fp
 800460a:	f7fc f855 	bl	80006b8 <__aeabi_f2d>
 800460e:	4606      	mov	r6, r0
 8004610:	460f      	mov	r7, r1
 8004612:	ec47 6b10 	vmov	d0, r6, r7
 8004616:	f000 fc73 	bl	8004f00 <log10>
 800461a:	ec51 0b10 	vmov	r0, r1, d0
 800461e:	f7fc fb3f 	bl	8000ca0 <__aeabi_d2iz>
    int useExp = (m >= 14 || (neg && m >= 9) || m <= -9);
 8004622:	280d      	cmp	r0, #13
    char *c = s;
    int neg = (n < 0);
    if (neg)
      n = -n;
    // calculate magnitude
    m = log10(n);
 8004624:	4605      	mov	r5, r0
    int useExp = (m >= 14 || (neg && m >= 9) || m <= -9);
 8004626:	dc03      	bgt.n	8004630 <convFloat+0x180>
 8004628:	f110 0f08 	cmn.w	r0, #8
 800462c:	f280 8084 	bge.w	8004738 <convFloat+0x288>
    char *c = s;
    int neg = (n < 0);
    if (neg)
      n = -n;
    // calculate magnitude
    m = log10(n);
 8004630:	462c      	mov	r4, r5
 8004632:	f8dd a004 	ldr.w	sl, [sp, #4]
 8004636:	e776      	b.n	8004526 <convFloat+0x76>
  if (isnan(n)) {
    strcpy(s, "nan");
  } else if (isinf(n)) {
    strcpy(s, "inf");
  } else if (n == 0.0) {
    strcpy(s, "0");
 8004638:	4b4c      	ldr	r3, [pc, #304]	; (800476c <convFloat+0x2bc>)
 800463a:	9a01      	ldr	r2, [sp, #4]
 800463c:	881b      	ldrh	r3, [r3, #0]
      c += m;
    }
    *(c) = '\0';
  }
  return s;
}
 800463e:	9801      	ldr	r0, [sp, #4]
  if (isnan(n)) {
    strcpy(s, "nan");
  } else if (isinf(n)) {
    strcpy(s, "inf");
  } else if (n == 0.0) {
    strcpy(s, "0");
 8004640:	8013      	strh	r3, [r2, #0]
      c += m;
    }
    *(c) = '\0';
  }
  return s;
}
 8004642:	b005      	add	sp, #20
 8004644:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    int neg = (n < 0);
    if (neg)
      n = -n;
    // calculate magnitude
    m = log10(n);
    int useExp = (m >= 14 || (neg && m >= 9) || m <= -9);
 8004648:	2808      	cmp	r0, #8
 800464a:	f73f af66 	bgt.w	800451a <convFloat+0x6a>
 800464e:	f110 0f08 	cmn.w	r0, #8
 8004652:	f6ff af62 	blt.w	800451a <convFloat+0x6a>
    if (neg)
      *(c++) = '-';
 8004656:	9901      	ldr	r1, [sp, #4]
 8004658:	232d      	movs	r3, #45	; 0x2d
 800465a:	700b      	strb	r3, [r1, #0]
 800465c:	f101 0a01 	add.w	sl, r1, #1
	m -= 1.0;
      n = n / pow(10.0, m);
      m1 = m;
      m = 0;
    }
    if (m < 1.0) {
 8004660:	ee07 5a90 	vmov	s15, r5
 8004664:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8004668:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 800466c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8004670:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004674:	bf4b      	itete	mi
 8004676:	2500      	movmi	r5, #0
 8004678:	2300      	movpl	r3, #0
      m = 0;
 800467a:	9502      	strmi	r5, [sp, #8]
 800467c:	9302      	strpl	r3, [sp, #8]
 800467e:	9403      	str	r4, [sp, #12]
 8004680:	e76a      	b.n	8004558 <convFloat+0xa8>
      }
      if (m == 0 && n > 0)
	*(c++) = '.';
      m--;
    }
    if (useExp) {
 8004682:	9b02      	ldr	r3, [sp, #8]
 8004684:	9c03      	ldr	r4, [sp, #12]
 8004686:	4656      	mov	r6, sl
 8004688:	b3a3      	cbz	r3, 80046f4 <convFloat+0x244>
      // convert the exponent
      int i, j;
      *(c++) = 'e';
 800468a:	2365      	movs	r3, #101	; 0x65
      if (m1 > 0) {
 800468c:	2c00      	cmp	r4, #0
      m--;
    }
    if (useExp) {
      // convert the exponent
      int i, j;
      *(c++) = 'e';
 800468e:	f88a 3000 	strb.w	r3, [sl]
      if (m1 > 0) {
 8004692:	dd35      	ble.n	8004700 <convFloat+0x250>
	*(c++) = '+';
 8004694:	232b      	movs	r3, #43	; 0x2b
 8004696:	f88a 3001 	strb.w	r3, [sl, #1]
 800469a:	f10a 0a02 	add.w	sl, sl, #2
 800469e:	2100      	movs	r1, #0
	*(c++) = '-';
	m1 = -m1;
      }
      m = 0;
      while (m1 > 0) {
	*(c++) = '0' + m1 % 10;
 80046a0:	4833      	ldr	r0, [pc, #204]	; (8004770 <convFloat+0x2c0>)
 80046a2:	e000      	b.n	80046a6 <convFloat+0x1f6>
	m1 /= 10;
	m++;
 80046a4:	4631      	mov	r1, r6
	*(c++) = '-';
	m1 = -m1;
      }
      m = 0;
      while (m1 > 0) {
	*(c++) = '0' + m1 % 10;
 80046a6:	fb80 3204 	smull	r3, r2, r0, r4
 80046aa:	17e3      	asrs	r3, r4, #31
 80046ac:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 80046b0:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80046b4:	eba4 0442 	sub.w	r4, r4, r2, lsl #1
 80046b8:	3430      	adds	r4, #48	; 0x30
 80046ba:	f80a 4b01 	strb.w	r4, [sl], #1
	m1 /= 10;
	m++;
 80046be:	1c4e      	adds	r6, r1, #1
      } else {
	*(c++) = '-';
	m1 = -m1;
      }
      m = 0;
      while (m1 > 0) {
 80046c0:	461c      	mov	r4, r3
 80046c2:	2b00      	cmp	r3, #0
 80046c4:	d1ee      	bne.n	80046a4 <convFloat+0x1f4>
	*(c++) = '0' + m1 % 10;
	m1 /= 10;
	m++;
      }
      c -= m;
 80046c6:	ebc6 0a0a 	rsb	sl, r6, sl
      for (i = 0, j = m-1; i<j; i++, j--) {
 80046ca:	b191      	cbz	r1, 80046f2 <convFloat+0x242>
 80046cc:	4650      	mov	r0, sl
 80046ce:	eb0a 0501 	add.w	r5, sl, r1
	// swap without temporary
	c[i] ^= c[j];
 80046d2:	7803      	ldrb	r3, [r0, #0]
 80046d4:	782a      	ldrb	r2, [r5, #0]
 80046d6:	405a      	eors	r2, r3
 80046d8:	7002      	strb	r2, [r0, #0]
	c[j] ^= c[i];
 80046da:	782b      	ldrb	r3, [r5, #0]
 80046dc:	4053      	eors	r3, r2
 80046de:	f805 3901 	strb.w	r3, [r5], #-1
	c[i] ^= c[j];
 80046e2:	7802      	ldrb	r2, [r0, #0]
	*(c++) = '0' + m1 % 10;
	m1 /= 10;
	m++;
      }
      c -= m;
      for (i = 0, j = m-1; i<j; i++, j--) {
 80046e4:	3401      	adds	r4, #1
	// swap without temporary
	c[i] ^= c[j];
	c[j] ^= c[i];
	c[i] ^= c[j];
 80046e6:	4053      	eors	r3, r2
 80046e8:	1b0a      	subs	r2, r1, r4
	*(c++) = '0' + m1 % 10;
	m1 /= 10;
	m++;
      }
      c -= m;
      for (i = 0, j = m-1; i<j; i++, j--) {
 80046ea:	4294      	cmp	r4, r2
	// swap without temporary
	c[i] ^= c[j];
	c[j] ^= c[i];
	c[i] ^= c[j];
 80046ec:	f800 3b01 	strb.w	r3, [r0], #1
	*(c++) = '0' + m1 % 10;
	m1 /= 10;
	m++;
      }
      c -= m;
      for (i = 0, j = m-1; i<j; i++, j--) {
 80046f0:	dbef      	blt.n	80046d2 <convFloat+0x222>
	// swap without temporary
	c[i] ^= c[j];
	c[j] ^= c[i];
	c[i] ^= c[j];
      }
      c += m;
 80046f2:	4456      	add	r6, sl
    }
    *(c) = '\0';
  }
  return s;
}
 80046f4:	9801      	ldr	r0, [sp, #4]
	c[j] ^= c[i];
	c[i] ^= c[j];
      }
      c += m;
    }
    *(c) = '\0';
 80046f6:	2300      	movs	r3, #0
 80046f8:	7033      	strb	r3, [r6, #0]
  }
  return s;
}
 80046fa:	b005      	add	sp, #20
 80046fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      int i, j;
      *(c++) = 'e';
      if (m1 > 0) {
	*(c++) = '+';
      } else {
	*(c++) = '-';
 8004700:	232d      	movs	r3, #45	; 0x2d
	m1 = -m1;
 8004702:	4264      	negs	r4, r4
      int i, j;
      *(c++) = 'e';
      if (m1 > 0) {
	*(c++) = '+';
      } else {
	*(c++) = '-';
 8004704:	f88a 3001 	strb.w	r3, [sl, #1]
 8004708:	f10a 0a02 	add.w	sl, sl, #2
	m1 = -m1;
      }
      m = 0;
      while (m1 > 0) {
 800470c:	2c00      	cmp	r4, #0
 800470e:	d1c6      	bne.n	800469e <convFloat+0x1ee>
	*(c++) = '0' + m1 % 10;
	m1 /= 10;
	m++;
      }
      c -= m;
 8004710:	4626      	mov	r6, r4
 8004712:	e7ee      	b.n	80046f2 <convFloat+0x242>
    if (neg)
      *(c++) = '-';
    // set up for scientific notation
    if (useExp) {
      if (m < 0)
	m -= 1.0;
 8004714:	ee07 5a90 	vmov	s15, r5
 8004718:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800471c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8004720:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8004724:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8004728:	ee17 4a90 	vmov	r4, s15
 800472c:	e6fe      	b.n	800452c <convFloat+0x7c>
char * convFloat(char *s, float n) {
  // handle special cases
  if (isnan(n)) {
    strcpy(s, "nan");
  } else if (isinf(n)) {
    strcpy(s, "inf");
 800472e:	4b11      	ldr	r3, [pc, #68]	; (8004774 <convFloat+0x2c4>)
 8004730:	6818      	ldr	r0, [r3, #0]
 8004732:	9b01      	ldr	r3, [sp, #4]
 8004734:	6018      	str	r0, [r3, #0]
 8004736:	e763      	b.n	8004600 <convFloat+0x150>
    int neg = (n < 0);
    if (neg)
      n = -n;
    // calculate magnitude
    m = log10(n);
    int useExp = (m >= 14 || (neg && m >= 9) || m <= -9);
 8004738:	f8dd a004 	ldr.w	sl, [sp, #4]
 800473c:	e790      	b.n	8004660 <convFloat+0x1b0>
      if (weight > 0 && !isinf(weight)) {
	digit = floor(n / weight);
	n -= (digit * weight);
	*(c++) = '0' + digit;
      }
      if (m == 0 && n > 0)
 800473e:	ee07 ba90 	vmov	s15, fp
 8004742:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8004746:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800474a:	f77f af53 	ble.w	80045f4 <convFloat+0x144>
	*(c++) = '.';
 800474e:	232e      	movs	r3, #46	; 0x2e
 8004750:	f88a 3000 	strb.w	r3, [sl]
 8004754:	f10a 0a01 	add.w	sl, sl, #1
 8004758:	e74c      	b.n	80045f4 <convFloat+0x144>
 800475a:	bf00      	nop
 800475c:	f3af 8000 	nop.w
 8004760:	00000000 	.word	0x00000000
 8004764:	40240000 	.word	0x40240000
 8004768:	08006d10 	.word	0x08006d10
 800476c:	08006ed4 	.word	0x08006ed4
 8004770:	66666667 	.word	0x66666667
 8004774:	08006d14 	.word	0x08006d14
 8004778:	e0000000 	.word	0xe0000000
 800477c:	3e45798e 	.word	0x3e45798e

08004780 <EvaluateNet>:

float inputs[MAX_INPUTS];
float hiddens[MAX_HIDDEN];
float outputs[MAX_OUTPUTS];

void EvaluateNet(float next_input){
 8004780:	4b38      	ldr	r3, [pc, #224]	; (8004864 <EvaluateNet+0xe4>)
 8004782:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004784:	f1a3 057c 	sub.w	r5, r3, #124	; 0x7c
 8004788:	4628      	mov	r0, r5
 800478a:	1d1a      	adds	r2, r3, #4

  int i = 0;
  int j = 0;

  for (i=(MAX_INPUTS-1); i>0 ;i--) {
    inputs[i] = inputs[i-1];
 800478c:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 8004790:	f842 1d04 	str.w	r1, [r2, #-4]!
void EvaluateNet(float next_input){

  int i = 0;
  int j = 0;

  for (i=(MAX_INPUTS-1); i>0 ;i--) {
 8004794:	4283      	cmp	r3, r0
 8004796:	d1f9      	bne.n	800478c <EvaluateNet+0xc>
    inputs[i] = inputs[i-1];
  }
  inputs[i] = next_input;

  for (i = 0; i < MAX_HIDDEN; i++){
    hiddens[i] = 0;
 8004798:	ed9f 7a33 	vldr	s14, [pc, #204]	; 8004868 <EvaluateNet+0xe8>
 800479c:	4e33      	ldr	r6, [pc, #204]	; (800486c <EvaluateNet+0xec>)
 800479e:	4c34      	ldr	r4, [pc, #208]	; (8004870 <EvaluateNet+0xf0>)
  }
  for (i = 0; i < MAX_OUTPUTS; i++){
    outputs[i] = 0;
 80047a0:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 8004880 <EvaluateNet+0x100>
 80047a4:	4833      	ldr	r0, [pc, #204]	; (8004874 <EvaluateNet+0xf4>)
  int j = 0;

  for (i=(MAX_INPUTS-1); i>0 ;i--) {
    inputs[i] = inputs[i-1];
  }
  inputs[i] = next_input;
 80047a6:	ed85 0a00 	vstr	s0, [r5]

  for (i = 0; i < MAX_HIDDEN; i++){
    hiddens[i] = 0;
 80047aa:	4631      	mov	r1, r6
 80047ac:	ee17 3a10 	vmov	r3, s14
 80047b0:	f841 3f0c 	str.w	r3, [r1, #12]!
  }
  for (i = 0; i < MAX_OUTPUTS; i++){
    outputs[i] = 0;
 80047b4:	eef0 7a47 	vmov.f32	s15, s14
    inputs[i] = inputs[i-1];
  }
  inputs[i] = next_input;

  for (i = 0; i < MAX_HIDDEN; i++){
    hiddens[i] = 0;
 80047b8:	ed86 7a00 	vstr	s14, [r6]
 80047bc:	ed86 7a01 	vstr	s14, [r6, #4]
 80047c0:	ed86 7a02 	vstr	s14, [r6, #8]
    for (j = 0; j < MAX_HIDDEN; j++){
      hiddens[j] += inputs[i] * weights_ih[i][j];			
      if (hiddens[j] > 1) {
      	hiddens[j] = 1;
      }
      else if (hiddens[j] < 0) {
 80047c4:	eeb0 6a47 	vmov.f32	s12, s14
 80047c8:	f104 077c 	add.w	r7, r4, #124	; 0x7c
  }

  for (i = 0; i < MAX_INPUTS; i++){
    for (j = 0; j < MAX_HIDDEN; j++){
      hiddens[j] += inputs[i] * weights_ih[i][j];			
      if (hiddens[j] > 1) {
 80047cc:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 80047d0:	4d26      	ldr	r5, [pc, #152]	; (800486c <EvaluateNet+0xec>)

float inputs[MAX_INPUTS];
float hiddens[MAX_HIDDEN];
float outputs[MAX_OUTPUTS];

void EvaluateNet(float next_input){
 80047d2:	4602      	mov	r2, r0
 80047d4:	462b      	mov	r3, r5
    outputs[i] = 0;
  }

  for (i = 0; i < MAX_INPUTS; i++){
    for (j = 0; j < MAX_HIDDEN; j++){
      hiddens[j] += inputs[i] * weights_ih[i][j];			
 80047d6:	ecb2 7a01 	vldmia	r2!, {s14}
 80047da:	eee7 7a00 	vfma.f32	s15, s14, s0
      if (hiddens[j] > 1) {
 80047de:	eef4 7ae6 	vcmpe.f32	s15, s13
 80047e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80047e6:	dd07      	ble.n	80047f8 <EvaluateNet+0x78>
  for (i = 0; i < MAX_OUTPUTS; i++){
    outputs[i] = 0;
  }

  for (i = 0; i < MAX_INPUTS; i++){
    for (j = 0; j < MAX_HIDDEN; j++){
 80047e8:	428b      	cmp	r3, r1
      hiddens[j] += inputs[i] * weights_ih[i][j];			
      if (hiddens[j] > 1) {
      	hiddens[j] = 1;
 80047ea:	edc3 6a00 	vstr	s13, [r3]
  for (i = 0; i < MAX_OUTPUTS; i++){
    outputs[i] = 0;
  }

  for (i = 0; i < MAX_INPUTS; i++){
    for (j = 0; j < MAX_HIDDEN; j++){
 80047ee:	d00e      	beq.n	800480e <EvaluateNet+0x8e>
 80047f0:	3304      	adds	r3, #4
 80047f2:	edd3 7a00 	vldr	s15, [r3]
 80047f6:	e7ee      	b.n	80047d6 <EvaluateNet+0x56>
      hiddens[j] += inputs[i] * weights_ih[i][j];			
      if (hiddens[j] > 1) {
      	hiddens[j] = 1;
      }
      else if (hiddens[j] < 0) {
 80047f8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80047fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    outputs[i] = 0;
  }

  for (i = 0; i < MAX_INPUTS; i++){
    for (j = 0; j < MAX_HIDDEN; j++){
      hiddens[j] += inputs[i] * weights_ih[i][j];			
 8004800:	bf54      	ite	pl
 8004802:	edc3 7a00 	vstrpl	s15, [r3]
      if (hiddens[j] > 1) {
      	hiddens[j] = 1;
      }
      else if (hiddens[j] < 0) {
      	hiddens[j] = 0;
 8004806:	ed83 6a00 	vstrmi	s12, [r3]
  for (i = 0; i < MAX_OUTPUTS; i++){
    outputs[i] = 0;
  }

  for (i = 0; i < MAX_INPUTS; i++){
    for (j = 0; j < MAX_HIDDEN; j++){
 800480a:	428b      	cmp	r3, r1
 800480c:	d1f0      	bne.n	80047f0 <EvaluateNet+0x70>
  }
  for (i = 0; i < MAX_OUTPUTS; i++){
    outputs[i] = 0;
  }

  for (i = 0; i < MAX_INPUTS; i++){
 800480e:	42bc      	cmp	r4, r7
 8004810:	f100 0010 	add.w	r0, r0, #16
 8004814:	d004      	beq.n	8004820 <EvaluateNet+0xa0>
 8004816:	ecb4 0a01 	vldmia	r4!, {s0}
 800481a:	edd6 7a00 	vldr	s15, [r6]
 800481e:	e7d7      	b.n	80047d0 <EvaluateNet+0x50>
 8004820:	eddf 7a11 	vldr	s15, [pc, #68]	; 8004868 <EvaluateNet+0xe8>
 8004824:	4b14      	ldr	r3, [pc, #80]	; (8004878 <EvaluateNet+0xf8>)
 8004826:	4a15      	ldr	r2, [pc, #84]	; (800487c <EvaluateNet+0xfc>)
      outputs[j] += hiddens[i] * weights_ho[i][j];
      if (outputs[j] > 1) {
      	outputs[j] = 1;
      }
      else if (outputs[j] < 0) {
      	outputs[j] = 0;
 8004828:	eef0 5a67 	vmov.f32	s11, s15
  }

  for (i = 0; i < MAX_HIDDEN; i++){
    for (j = 0; j < MAX_OUTPUTS; j++){
      outputs[j] += hiddens[i] * weights_ho[i][j];
      if (outputs[j] > 1) {
 800482c:	eeb7 6a00 	vmov.f32	s12, #112	; 0x70
    }
  }

  for (i = 0; i < MAX_HIDDEN; i++){
    for (j = 0; j < MAX_OUTPUTS; j++){
      outputs[j] += hiddens[i] * weights_ho[i][j];
 8004830:	ecf5 6a01 	vldmia	r5!, {s13}
 8004834:	ecb3 7a01 	vldmia	r3!, {s14}
 8004838:	eee6 7a87 	vfma.f32	s15, s13, s14
      if (outputs[j] > 1) {
 800483c:	eef4 7ac6 	vcmpe.f32	s15, s12
 8004840:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8004844:	dd06      	ble.n	8004854 <EvaluateNet+0xd4>
      	outputs[j] = 1;
 8004846:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
      	hiddens[j] = 0;
      }
    }
  }

  for (i = 0; i < MAX_HIDDEN; i++){
 800484a:	4295      	cmp	r5, r2
 800484c:	d1f0      	bne.n	8004830 <EvaluateNet+0xb0>
 800484e:	edce 7a00 	vstr	s15, [lr]
 8004852:	bdf0      	pop	{r4, r5, r6, r7, pc}
      outputs[j] += hiddens[i] * weights_ho[i][j];
      if (outputs[j] > 1) {
      	outputs[j] = 1;
      }
      else if (outputs[j] < 0) {
      	outputs[j] = 0;
 8004854:	eef5 7a40 	vcmp.f32	s15, #0.0
 8004858:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800485c:	bf48      	it	mi
 800485e:	eef0 7a65 	vmovmi.f32	s15, s11
 8004862:	e7f2      	b.n	800484a <EvaluateNet+0xca>
 8004864:	200013c8 	.word	0x200013c8
 8004868:	00000000 	.word	0x00000000
 800486c:	2000133c 	.word	0x2000133c
 8004870:	20001350 	.word	0x20001350
 8004874:	20000818 	.word	0x20000818
 8004878:	20000a18 	.word	0x20000a18
 800487c:	2000134c 	.word	0x2000134c
 8004880:	200013cc 	.word	0x200013cc
 8004884:	f3af 8000 	nop.w
 8004888:	f3af 8000 	nop.w
 800488c:	f3af 8000 	nop.w

08004890 <counterThread>:
static THD_WORKING_AREA(waShell,2048);
static thread_t *shelltp1;

/* Thread that blinks North LED as an "alive" indicator */
static THD_WORKING_AREA(waCounterThread,128);
static THD_FUNCTION(counterThread,arg) {
 8004890:	b508      	push	{r3, lr}
  UNUSED(arg);
  while (TRUE) {
    palSetPad(GPIOE, GPIOE_LED3_RED);
 8004892:	f44f 7500 	mov.w	r5, #512	; 0x200
 8004896:	4c06      	ldr	r4, [pc, #24]	; (80048b0 <counterThread+0x20>)
 8004898:	462e      	mov	r6, r5
 800489a:	8326      	strh	r6, [r4, #24]
    chThdSleepMilliseconds(500);
 800489c:	f241 3088 	movw	r0, #5000	; 0x1388
 80048a0:	f7fc fea6 	bl	80015f0 <chThdSleep>
    palClearPad(GPIOE, GPIOE_LED3_RED);
 80048a4:	8365      	strh	r5, [r4, #26]
    chThdSleepMilliseconds(500);
 80048a6:	f241 3088 	movw	r0, #5000	; 0x1388
 80048aa:	f7fc fea1 	bl	80015f0 <chThdSleep>
  }
 80048ae:	e7f4      	b.n	800489a <counterThread+0xa>
 80048b0:	48001000 	.word	0x48001000
 80048b4:	f3af 8000 	nop.w
 80048b8:	f3af 8000 	nop.w
 80048bc:	f3af 8000 	nop.w

080048c0 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80048c0:	b40e      	push	{r1, r2, r3}
 80048c2:	b500      	push	{lr}
 80048c4:	b082      	sub	sp, #8
 80048c6:	aa03      	add	r2, sp, #12
 80048c8:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80048cc:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80048ce:	f7ff fc37 	bl	8004140 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 80048d2:	b002      	add	sp, #8
 80048d4:	f85d eb04 	ldr.w	lr, [sp], #4
 80048d8:	b003      	add	sp, #12
 80048da:	4770      	bx	lr
 80048dc:	f3af 8000 	nop.w

080048e0 <termination_handler>:
static const ShellConfig shell_cfg1 = {
  (BaseSequentialStream *)&SD1,
  commands
};

static void termination_handler(eventid_t id) {
 80048e0:	b510      	push	{r4, lr}

  (void)id;
  chprintf((BaseSequentialStream*)&SD1, "Shell Died\n\r");

  if (shelltp1 && chThdTerminatedX(shelltp1)) {
 80048e2:	4c0e      	ldr	r4, [pc, #56]	; (800491c <termination_handler+0x3c>)
};

static void termination_handler(eventid_t id) {

  (void)id;
  chprintf((BaseSequentialStream*)&SD1, "Shell Died\n\r");
 80048e4:	480e      	ldr	r0, [pc, #56]	; (8004920 <termination_handler+0x40>)
 80048e6:	490f      	ldr	r1, [pc, #60]	; (8004924 <termination_handler+0x44>)
 80048e8:	f7ff ffea 	bl	80048c0 <chprintf>

  if (shelltp1 && chThdTerminatedX(shelltp1)) {
 80048ec:	6820      	ldr	r0, [r4, #0]
 80048ee:	b110      	cbz	r0, 80048f6 <termination_handler+0x16>
 80048f0:	7f03      	ldrb	r3, [r0, #28]
 80048f2:	2b0f      	cmp	r3, #15
 80048f4:	d000      	beq.n	80048f8 <termination_handler+0x18>
 80048f6:	bd10      	pop	{r4, pc}
    chThdWait(shelltp1);
 80048f8:	f7fc feb2 	bl	8001660 <chThdWait>
    chprintf((BaseSequentialStream*)&SD1, "Restarting from termination handler\n\r");
 80048fc:	490a      	ldr	r1, [pc, #40]	; (8004928 <termination_handler+0x48>)
 80048fe:	4808      	ldr	r0, [pc, #32]	; (8004920 <termination_handler+0x40>)
 8004900:	f7ff ffde 	bl	80048c0 <chprintf>
    chThdSleepMilliseconds(100);
 8004904:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004908:	f7fc fe72 	bl	80015f0 <chThdSleep>
    shelltp1 = shellCreate(&shell_cfg1, sizeof(waShell), NORMALPRIO);
 800490c:	4807      	ldr	r0, [pc, #28]	; (800492c <termination_handler+0x4c>)
 800490e:	f44f 6115 	mov.w	r1, #2384	; 0x950
 8004912:	2240      	movs	r2, #64	; 0x40
 8004914:	f7ff fabc 	bl	8003e90 <shellCreate>
 8004918:	6020      	str	r0, [r4, #0]
 800491a:	bd10      	pop	{r4, pc}
 800491c:	2000162c 	.word	0x2000162c
 8004920:	2000119c 	.word	0x2000119c
 8004924:	08006d60 	.word	0x08006d60
 8004928:	08006d70 	.word	0x08006d70
 800492c:	08006ec0 	.word	0x08006ec0

08004930 <cmd_myecho>:
static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
  int32_t i;

  (void)argv;

  for (i=0;i<argc;i++) {
 8004930:	2900      	cmp	r1, #0
 8004932:	dd0e      	ble.n	8004952 <cmd_myecho+0x22>
    chThdSleepMilliseconds(500);
  }
  return 0;
}

static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004934:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004936:	460f      	mov	r7, r1
 8004938:	4606      	mov	r6, r0
 800493a:	1f15      	subs	r5, r2, #4
  int32_t i;

  (void)argv;

  for (i=0;i<argc;i++) {
 800493c:	2400      	movs	r4, #0
 800493e:	3401      	adds	r4, #1
    chprintf(chp, "%s\n\r", argv[i]);
 8004940:	4630      	mov	r0, r6
 8004942:	4904      	ldr	r1, [pc, #16]	; (8004954 <cmd_myecho+0x24>)
 8004944:	f855 2f04 	ldr.w	r2, [r5, #4]!
 8004948:	f7ff ffba 	bl	80048c0 <chprintf>
static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
  int32_t i;

  (void)argv;

  for (i=0;i<argc;i++) {
 800494c:	42bc      	cmp	r4, r7
 800494e:	d1f6      	bne.n	800493e <cmd_myecho+0xe>
 8004950:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004952:	4770      	bx	lr
 8004954:	08006d98 	.word	0x08006d98
 8004958:	f3af 8000 	nop.w
 800495c:	f3af 8000 	nop.w

08004960 <cmd_collect>:
    chprintf((BaseSequentialStream*)&SD1, "%s\n\r", convFloat(float_array, outputs[0]));
  }
}


static void cmd_collect (BaseSequentialStream *chp, int argc, char *argv[]) {
 8004960:	b530      	push	{r4, r5, lr}
 8004962:	ed2d 8b04 	vpush	{d8-d9}
  char float_array[32];
  /* float scaled_input; */
  int i;
  (void)argv;

  start_collection = 1;
 8004966:	4c1b      	ldr	r4, [pc, #108]	; (80049d4 <cmd_collect+0x74>)
 8004968:	2301      	movs	r3, #1
    chprintf((BaseSequentialStream*)&SD1, "%s\n\r", convFloat(float_array, outputs[0]));
  }
}


static void cmd_collect (BaseSequentialStream *chp, int argc, char *argv[]) {
 800496a:	b089      	sub	sp, #36	; 0x24
  char float_array[32];
  /* float scaled_input; */
  int i;
  (void)argv;

  start_collection = 1;
 800496c:	6023      	str	r3, [r4, #0]
  while (start_collection) {
    chThdSleepMilliseconds(1);
 800496e:	200a      	movs	r0, #10
 8004970:	f7fc fe3e 	bl	80015f0 <chThdSleep>
  /* float scaled_input; */
  int i;
  (void)argv;

  start_collection = 1;
  while (start_collection) {
 8004974:	6823      	ldr	r3, [r4, #0]
 8004976:	2b00      	cmp	r3, #0
 8004978:	d1f9      	bne.n	800496e <cmd_collect+0xe>
 800497a:	4c17      	ldr	r4, [pc, #92]	; (80049d8 <cmd_collect+0x78>)
   0}
};

float scale_input (unsigned short a2dval) {
  float voltage;
  voltage = ((float) a2dval/4096.0) * 3.0;
 800497c:	ed9f 9a17 	vldr	s18, [pc, #92]	; 80049dc <cmd_collect+0x7c>
  return (voltage * ARB_SCALE_FACTOR + ARB_OFFSET); // scale, offset come from arb.c[h]
 8004980:	eddf 8a17 	vldr	s17, [pc, #92]	; 80049e0 <cmd_collect+0x80>
 8004984:	ed9f 8a17 	vldr	s16, [pc, #92]	; 80049e4 <cmd_collect+0x84>
 8004988:	f104 0580 	add.w	r5, r4, #128	; 0x80
  start_collection = 1;
  while (start_collection) {
    chThdSleepMilliseconds(1);
  }
  for (i=0;i<32;i++) {
    chprintf((BaseSequentialStream*)&SD1, "0x%0x ", collection_buf[i]);
 800498c:	f854 2f04 	ldr.w	r2, [r4, #4]!
 8004990:	4915      	ldr	r1, [pc, #84]	; (80049e8 <cmd_collect+0x88>)
 8004992:	4816      	ldr	r0, [pc, #88]	; (80049ec <cmd_collect+0x8c>)
 8004994:	f7ff ff94 	bl	80048c0 <chprintf>
   0}
};

float scale_input (unsigned short a2dval) {
  float voltage;
  voltage = ((float) a2dval/4096.0) * 3.0;
 8004998:	8823      	ldrh	r3, [r4, #0]
 800499a:	ee07 3a90 	vmov	s15, r3
 800499e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80049a2:	eeb0 7a08 	vmov.f32	s14, #8
 80049a6:	ee67 7a89 	vmul.f32	s15, s15, s18
  while (start_collection) {
    chThdSleepMilliseconds(1);
  }
  for (i=0;i<32;i++) {
    chprintf((BaseSequentialStream*)&SD1, "0x%0x ", collection_buf[i]);
    chprintf((BaseSequentialStream*)&SD1, "%s\n\r ", convFloat(float_array, scale_input(collection_buf[i])));
 80049aa:	eeb0 0a48 	vmov.f32	s0, s16
   0}
};

float scale_input (unsigned short a2dval) {
  float voltage;
  voltage = ((float) a2dval/4096.0) * 3.0;
 80049ae:	ee67 7a87 	vmul.f32	s15, s15, s14
  while (start_collection) {
    chThdSleepMilliseconds(1);
  }
  for (i=0;i<32;i++) {
    chprintf((BaseSequentialStream*)&SD1, "0x%0x ", collection_buf[i]);
    chprintf((BaseSequentialStream*)&SD1, "%s\n\r ", convFloat(float_array, scale_input(collection_buf[i])));
 80049b2:	4668      	mov	r0, sp
 80049b4:	eea7 0aa8 	vfma.f32	s0, s15, s17
 80049b8:	f7ff fd7a 	bl	80044b0 <convFloat>
 80049bc:	490c      	ldr	r1, [pc, #48]	; (80049f0 <cmd_collect+0x90>)
 80049be:	4602      	mov	r2, r0
 80049c0:	480a      	ldr	r0, [pc, #40]	; (80049ec <cmd_collect+0x8c>)
 80049c2:	f7ff ff7d 	bl	80048c0 <chprintf>

  start_collection = 1;
  while (start_collection) {
    chThdSleepMilliseconds(1);
  }
  for (i=0;i<32;i++) {
 80049c6:	42ac      	cmp	r4, r5
 80049c8:	d1e0      	bne.n	800498c <cmd_collect+0x2c>
    chprintf((BaseSequentialStream*)&SD1, "0x%0x ", collection_buf[i]);
    chprintf((BaseSequentialStream*)&SD1, "%s\n\r ", convFloat(float_array, scale_input(collection_buf[i])));
  }
}
 80049ca:	b009      	add	sp, #36	; 0x24
 80049cc:	ecbd 8b04 	vpop	{d8-d9}
 80049d0:	bd30      	pop	{r4, r5, pc}
 80049d2:	bf00      	nop
 80049d4:	200015a0 	.word	0x200015a0
 80049d8:	200015a4 	.word	0x200015a4
 80049dc:	39800000 	.word	0x39800000
 80049e0:	3fd71548 	.word	0x3fd71548
 80049e4:	bf882614 	.word	0xbf882614
 80049e8:	08006da0 	.word	0x08006da0
 80049ec:	2000119c 	.word	0x2000119c
 80049f0:	08006da8 	.word	0x08006da8
 80049f4:	f3af 8000 	nop.w
 80049f8:	f3af 8000 	nop.w
 80049fc:	f3af 8000 	nop.w

08004a00 <cmd_sample>:
    chprintf(chp, "atoh error: cannot convert %s\n\r", argv[0]);    
  }
}


static void cmd_sample(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004a00:	b530      	push	{r4, r5, lr}
  UNUSED(chp);
  UNUSED(argc);
  char float_array[32];
  (void)argv;
  chprintf((BaseSequentialStream*)&SD1, "0x%04x ", samples_buf[0]);
 8004a02:	4c10      	ldr	r4, [pc, #64]	; (8004a44 <cmd_sample+0x44>)
 8004a04:	4d10      	ldr	r5, [pc, #64]	; (8004a48 <cmd_sample+0x48>)
 8004a06:	4911      	ldr	r1, [pc, #68]	; (8004a4c <cmd_sample+0x4c>)
 8004a08:	882a      	ldrh	r2, [r5, #0]
    chprintf(chp, "atoh error: cannot convert %s\n\r", argv[0]);    
  }
}


static void cmd_sample(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004a0a:	b089      	sub	sp, #36	; 0x24
  UNUSED(chp);
  UNUSED(argc);
  char float_array[32];
  (void)argv;
  chprintf((BaseSequentialStream*)&SD1, "0x%04x ", samples_buf[0]);
 8004a0c:	4620      	mov	r0, r4
 8004a0e:	f7ff ff57 	bl	80048c0 <chprintf>
   0}
};

float scale_input (unsigned short a2dval) {
  float voltage;
  voltage = ((float) a2dval/4096.0) * 3.0;
 8004a12:	882b      	ldrh	r3, [r5, #0]
  return (voltage * ARB_SCALE_FACTOR + ARB_OFFSET); // scale, offset come from arb.c[h]
 8004a14:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 8004a50 <cmd_sample+0x50>
 8004a18:	ed9f 0a0e 	vldr	s0, [pc, #56]	; 8004a54 <cmd_sample+0x54>
   0}
};

float scale_input (unsigned short a2dval) {
  float voltage;
  voltage = ((float) a2dval/4096.0) * 3.0;
 8004a1c:	ee07 3a90 	vmov	s15, r3
 8004a20:	eefb 7aca 	vcvt.f32.u32	s15, s15, #12
 8004a24:	eef0 6a08 	vmov.f32	s13, #8
 8004a28:	ee67 7aa6 	vmul.f32	s15, s15, s13
  UNUSED(chp);
  UNUSED(argc);
  char float_array[32];
  (void)argv;
  chprintf((BaseSequentialStream*)&SD1, "0x%04x ", samples_buf[0]);
  chprintf((BaseSequentialStream*)&SD1, "%s\n\r", convFloat(float_array, scale_input(samples_buf[0])));
 8004a2c:	4668      	mov	r0, sp
 8004a2e:	eea7 0a87 	vfma.f32	s0, s15, s14
 8004a32:	f7ff fd3d 	bl	80044b0 <convFloat>
 8004a36:	4908      	ldr	r1, [pc, #32]	; (8004a58 <cmd_sample+0x58>)
 8004a38:	4602      	mov	r2, r0
 8004a3a:	4620      	mov	r0, r4
 8004a3c:	f7ff ff40 	bl	80048c0 <chprintf>
}
 8004a40:	b009      	add	sp, #36	; 0x24
 8004a42:	bd30      	pop	{r4, r5, pc}
 8004a44:	2000119c 	.word	0x2000119c
 8004a48:	20001628 	.word	0x20001628
 8004a4c:	08006db0 	.word	0x08006db0
 8004a50:	3fd71548 	.word	0x3fd71548
 8004a54:	bf882614 	.word	0xbf882614
 8004a58:	08006d98 	.word	0x08006d98
 8004a5c:	f3af 8000 	nop.w

08004a60 <cmd_testweights>:

static void cmd_testweights(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004a60:	b570      	push	{r4, r5, r6, lr}
 8004a62:	ed2d 8b04 	vpush	{d8-d9}
 8004a66:	4d19      	ldr	r5, [pc, #100]	; (8004acc <cmd_testweights+0x6c>)
 8004a68:	4e19      	ldr	r6, [pc, #100]	; (8004ad0 <cmd_testweights+0x70>)
  char float_array[32];
  float scaled_input;
  int i;
  (void)argv;
  for (i=0;i<32;i++) {
    scaled_input = nntest_data_sampled[i] * ARB_SCALE_FACTOR + ARB_OFFSET;
 8004a6a:	ed9f 9a1a 	vldr	s18, [pc, #104]	; 8004ad4 <cmd_testweights+0x74>
 8004a6e:	eddf 8a1a 	vldr	s17, [pc, #104]	; 8004ad8 <cmd_testweights+0x78>
  (void)argv;
  chprintf((BaseSequentialStream*)&SD1, "0x%04x ", samples_buf[0]);
  chprintf((BaseSequentialStream*)&SD1, "%s\n\r", convFloat(float_array, scale_input(samples_buf[0])));
}

static void cmd_testweights(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004a72:	b088      	sub	sp, #32
  UNUSED(argc);
  char float_array[32];
  float scaled_input;
  int i;
  (void)argv;
  for (i=0;i<32;i++) {
 8004a74:	2400      	movs	r4, #0
    scaled_input = nntest_data_sampled[i] * ARB_SCALE_FACTOR + ARB_OFFSET;
 8004a76:	ecf5 7a01 	vldmia	r5!, {s15}
 8004a7a:	eeb0 8a68 	vmov.f32	s16, s17
 8004a7e:	eea7 8a89 	vfma.f32	s16, s15, s18
    EvaluateNet(scaled_input);
 8004a82:	eeb0 0a48 	vmov.f32	s0, s16
 8004a86:	f7ff fe7b 	bl	8004780 <EvaluateNet>
    chprintf((BaseSequentialStream*)&SD1, "%d,", i);
 8004a8a:	4622      	mov	r2, r4
 8004a8c:	4913      	ldr	r1, [pc, #76]	; (8004adc <cmd_testweights+0x7c>)
 8004a8e:	4814      	ldr	r0, [pc, #80]	; (8004ae0 <cmd_testweights+0x80>)
 8004a90:	f7ff ff16 	bl	80048c0 <chprintf>
    chprintf((BaseSequentialStream*)&SD1, "%s ", convFloat(float_array, scaled_input));
 8004a94:	eeb0 0a48 	vmov.f32	s0, s16
 8004a98:	4668      	mov	r0, sp
 8004a9a:	f7ff fd09 	bl	80044b0 <convFloat>
 8004a9e:	4911      	ldr	r1, [pc, #68]	; (8004ae4 <cmd_testweights+0x84>)
 8004aa0:	4602      	mov	r2, r0
 8004aa2:	480f      	ldr	r0, [pc, #60]	; (8004ae0 <cmd_testweights+0x80>)
 8004aa4:	f7ff ff0c 	bl	80048c0 <chprintf>
    chprintf((BaseSequentialStream*)&SD1, "%s\n\r", convFloat(float_array, outputs[0]));
 8004aa8:	ed96 0a00 	vldr	s0, [r6]
 8004aac:	4668      	mov	r0, sp
 8004aae:	f7ff fcff 	bl	80044b0 <convFloat>
  UNUSED(argc);
  char float_array[32];
  float scaled_input;
  int i;
  (void)argv;
  for (i=0;i<32;i++) {
 8004ab2:	3401      	adds	r4, #1
    scaled_input = nntest_data_sampled[i] * ARB_SCALE_FACTOR + ARB_OFFSET;
    EvaluateNet(scaled_input);
    chprintf((BaseSequentialStream*)&SD1, "%d,", i);
    chprintf((BaseSequentialStream*)&SD1, "%s ", convFloat(float_array, scaled_input));
    chprintf((BaseSequentialStream*)&SD1, "%s\n\r", convFloat(float_array, outputs[0]));
 8004ab4:	4602      	mov	r2, r0
 8004ab6:	490c      	ldr	r1, [pc, #48]	; (8004ae8 <cmd_testweights+0x88>)
 8004ab8:	4809      	ldr	r0, [pc, #36]	; (8004ae0 <cmd_testweights+0x80>)
 8004aba:	f7ff ff01 	bl	80048c0 <chprintf>
  UNUSED(argc);
  char float_array[32];
  float scaled_input;
  int i;
  (void)argv;
  for (i=0;i<32;i++) {
 8004abe:	2c20      	cmp	r4, #32
 8004ac0:	d1d9      	bne.n	8004a76 <cmd_testweights+0x16>
    EvaluateNet(scaled_input);
    chprintf((BaseSequentialStream*)&SD1, "%d,", i);
    chprintf((BaseSequentialStream*)&SD1, "%s ", convFloat(float_array, scaled_input));
    chprintf((BaseSequentialStream*)&SD1, "%s\n\r", convFloat(float_array, outputs[0]));
  }
}
 8004ac2:	b008      	add	sp, #32
 8004ac4:	ecbd 8b04 	vpop	{d8-d9}
 8004ac8:	bd70      	pop	{r4, r5, r6, pc}
 8004aca:	bf00      	nop
 8004acc:	20000a28 	.word	0x20000a28
 8004ad0:	200013cc 	.word	0x200013cc
 8004ad4:	3fd71548 	.word	0x3fd71548
 8004ad8:	bf882614 	.word	0xbf882614
 8004adc:	08006db8 	.word	0x08006db8
 8004ae0:	2000119c 	.word	0x2000119c
 8004ae4:	08006ce8 	.word	0x08006ce8
 8004ae8:	08006d98 	.word	0x08006d98
 8004aec:	f3af 8000 	nop.w

08004af0 <gpt_adc_trigger>:
  return ((nnval/3.0) * 4096);
}

#define COLLECTION_THRESHOLD 0x180

static void gpt_adc_trigger(GPTDriver *gpt_ptr)  { 
 8004af0:	b510      	push	{r4, lr}
  UNUSED(*gpt_ptr);
  //  static int collection_count = 0;
  //  typedef enum {DISARMED, ARMED, COLLECTING} collection_t;
  //  static collection_t cstate = DISARMED;
  EvaluateNet(scale_input(samples_buf[0]));
 8004af2:	4c1b      	ldr	r4, [pc, #108]	; (8004b60 <gpt_adc_trigger+0x70>)
};

float scale_input (unsigned short a2dval) {
  float voltage;
  voltage = ((float) a2dval/4096.0) * 3.0;
  return (voltage * ARB_SCALE_FACTOR + ARB_OFFSET); // scale, offset come from arb.c[h]
 8004af4:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 8004b64 <gpt_adc_trigger+0x74>
   0}
};

float scale_input (unsigned short a2dval) {
  float voltage;
  voltage = ((float) a2dval/4096.0) * 3.0;
 8004af8:	8823      	ldrh	r3, [r4, #0]
  return (voltage * ARB_SCALE_FACTOR + ARB_OFFSET); // scale, offset come from arb.c[h]
 8004afa:	ed9f 0a1b 	vldr	s0, [pc, #108]	; 8004b68 <gpt_adc_trigger+0x78>
   0}
};

float scale_input (unsigned short a2dval) {
  float voltage;
  voltage = ((float) a2dval/4096.0) * 3.0;
 8004afe:	ee07 3a90 	vmov	s15, r3
 8004b02:	eefb 7aca 	vcvt.f32.u32	s15, s15, #12
  return ((nnval/3.0) * 4096);
}

#define COLLECTION_THRESHOLD 0x180

static void gpt_adc_trigger(GPTDriver *gpt_ptr)  { 
 8004b06:	ed2d 8b02 	vpush	{d8}
   0}
};

float scale_input (unsigned short a2dval) {
  float voltage;
  voltage = ((float) a2dval/4096.0) * 3.0;
 8004b0a:	eeb0 8a08 	vmov.f32	s16, #8
 8004b0e:	ee67 7a88 	vmul.f32	s15, s15, s16
  return ((nnval/3.0) * 4096);
}

#define COLLECTION_THRESHOLD 0x180

static void gpt_adc_trigger(GPTDriver *gpt_ptr)  { 
 8004b12:	b082      	sub	sp, #8
  UNUSED(*gpt_ptr);
  //  static int collection_count = 0;
  //  typedef enum {DISARMED, ARMED, COLLECTING} collection_t;
  //  static collection_t cstate = DISARMED;
  EvaluateNet(scale_input(samples_buf[0]));
 8004b14:	eea7 0a87 	vfma.f32	s0, s15, s14
 8004b18:	f7ff fe32 	bl	8004780 <EvaluateNet>
  dacConvertOne(&DACD1,scale_output(outputs[0]));
 8004b1c:	4b13      	ldr	r3, [pc, #76]	; (8004b6c <gpt_adc_trigger+0x7c>)
  voltage = ((float) a2dval/4096.0) * 3.0;
  return (voltage * ARB_SCALE_FACTOR + ARB_OFFSET); // scale, offset come from arb.c[h]
}

unsigned int scale_output (float nnval) {
  return ((nnval/3.0) * 4096);
 8004b1e:	ed9f 7a14 	vldr	s14, [pc, #80]	; 8004b70 <gpt_adc_trigger+0x80>
 8004b22:	edd3 7a00 	vldr	s15, [r3]
  UNUSED(*gpt_ptr);
  //  static int collection_count = 0;
  //  typedef enum {DISARMED, ARMED, COLLECTING} collection_t;
  //  static collection_t cstate = DISARMED;
  EvaluateNet(scale_input(samples_buf[0]));
  dacConvertOne(&DACD1,scale_output(outputs[0]));
 8004b26:	4813      	ldr	r0, [pc, #76]	; (8004b74 <gpt_adc_trigger+0x84>)
  voltage = ((float) a2dval/4096.0) * 3.0;
  return (voltage * ARB_SCALE_FACTOR + ARB_OFFSET); // scale, offset come from arb.c[h]
}

unsigned int scale_output (float nnval) {
  return ((nnval/3.0) * 4096);
 8004b28:	eec7 7a88 	vdiv.f32	s15, s15, s16
 8004b2c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8004b30:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  UNUSED(*gpt_ptr);
  //  static int collection_count = 0;
  //  typedef enum {DISARMED, ARMED, COLLECTING} collection_t;
  //  static collection_t cstate = DISARMED;
  EvaluateNet(scale_input(samples_buf[0]));
  dacConvertOne(&DACD1,scale_output(outputs[0]));
 8004b34:	edcd 7a01 	vstr	s15, [sp, #4]
 8004b38:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 8004b3c:	f7ff f830 	bl	8003ba0 <dacConvertOne>
  adcStartConversion(&ADCD1, &adcgrpcfg, samples_buf, ADC_BUF_DEPTH);
 8004b40:	4622      	mov	r2, r4
 8004b42:	480d      	ldr	r0, [pc, #52]	; (8004b78 <gpt_adc_trigger+0x88>)
 8004b44:	490d      	ldr	r1, [pc, #52]	; (8004b7c <gpt_adc_trigger+0x8c>)
 8004b46:	2301      	movs	r3, #1
 8004b48:	f7fd f9e2 	bl	8001f10 <adcStartConversion>
  palTogglePad(GPIOE, GPIOE_LED4_BLUE);
 8004b4c:	4a0c      	ldr	r2, [pc, #48]	; (8004b80 <gpt_adc_trigger+0x90>)
 8004b4e:	6953      	ldr	r3, [r2, #20]
 8004b50:	f483 7380 	eor.w	r3, r3, #256	; 0x100
 8004b54:	6153      	str	r3, [r2, #20]
}
 8004b56:	b002      	add	sp, #8
 8004b58:	ecbd 8b02 	vpop	{d8}
 8004b5c:	bd10      	pop	{r4, pc}
 8004b5e:	bf00      	nop
 8004b60:	20001628 	.word	0x20001628
 8004b64:	3fd71548 	.word	0x3fd71548
 8004b68:	bf882614 	.word	0xbf882614
 8004b6c:	200013cc 	.word	0x200013cc
 8004b70:	45800000 	.word	0x45800000
 8004b74:	200012b8 	.word	0x200012b8
 8004b78:	20001154 	.word	0x20001154
 8004b7c:	08006e90 	.word	0x08006e90
 8004b80:	48001000 	.word	0x48001000
 8004b84:	f3af 8000 	nop.w
 8004b88:	f3af 8000 	nop.w
 8004b8c:	f3af 8000 	nop.w

08004b90 <cmd_dac>:
  for (i=0;i<argc;i++) {
    chprintf(chp, "%s\n\r", argv[i]);
  }
}

static void cmd_dac(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004b90:	b530      	push	{r4, r5, lr}
  int tmp;

  (void)argv;
  if (argc!=1) {
 8004b92:	2901      	cmp	r1, #1
  for (i=0;i<argc;i++) {
    chprintf(chp, "%s\n\r", argv[i]);
  }
}

static void cmd_dac(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004b94:	b083      	sub	sp, #12
 8004b96:	4614      	mov	r4, r2
 8004b98:	4605      	mov	r5, r0
  int tmp;

  (void)argv;
  if (argc!=1) {
 8004b9a:	d003      	beq.n	8004ba4 <cmd_dac+0x14>
    chprintf(chp, "Error: wrong number of arguments. %d provided\n\rExample: dac 3FF\n\r", argc);
 8004b9c:	460a      	mov	r2, r1
 8004b9e:	4911      	ldr	r1, [pc, #68]	; (8004be4 <cmd_dac+0x54>)
 8004ba0:	f7ff fe8e 	bl	80048c0 <chprintf>
  }
  if (!(atoh(argv[0], &tmp))) {
 8004ba4:	6820      	ldr	r0, [r4, #0]
 8004ba6:	a901      	add	r1, sp, #4
 8004ba8:	f7ff fc52 	bl	8004450 <atoh>
 8004bac:	b998      	cbnz	r0, 8004bd6 <cmd_dac+0x46>
    if (tmp > 0xFFF) {
 8004bae:	9a01      	ldr	r2, [sp, #4]
 8004bb0:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
      chprintf(chp, "Value Error: 0 >= value <= 0xFFF: Value provided 0x%x\n\r", tmp);    
 8004bb4:	4628      	mov	r0, r5
  (void)argv;
  if (argc!=1) {
    chprintf(chp, "Error: wrong number of arguments. %d provided\n\rExample: dac 3FF\n\r", argc);
  }
  if (!(atoh(argv[0], &tmp))) {
    if (tmp > 0xFFF) {
 8004bb6:	da09      	bge.n	8004bcc <cmd_dac+0x3c>
      chprintf(chp, "Value Error: 0 >= value <= 0xFFF: Value provided 0x%x\n\r", tmp);    
    }
    else {
      chprintf(chp, "Wrote 0x%x to dac 1\n\r", tmp);
 8004bb8:	490b      	ldr	r1, [pc, #44]	; (8004be8 <cmd_dac+0x58>)
 8004bba:	f7ff fe81 	bl	80048c0 <chprintf>
      dacConvertOne(&DACD1,tmp);
 8004bbe:	480b      	ldr	r0, [pc, #44]	; (8004bec <cmd_dac+0x5c>)
 8004bc0:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 8004bc4:	f7fe ffec 	bl	8003ba0 <dacConvertOne>
    }
  }
  else {
    chprintf(chp, "atoh error: cannot convert %s\n\r", argv[0]);    
  }
}
 8004bc8:	b003      	add	sp, #12
 8004bca:	bd30      	pop	{r4, r5, pc}
  if (argc!=1) {
    chprintf(chp, "Error: wrong number of arguments. %d provided\n\rExample: dac 3FF\n\r", argc);
  }
  if (!(atoh(argv[0], &tmp))) {
    if (tmp > 0xFFF) {
      chprintf(chp, "Value Error: 0 >= value <= 0xFFF: Value provided 0x%x\n\r", tmp);    
 8004bcc:	4908      	ldr	r1, [pc, #32]	; (8004bf0 <cmd_dac+0x60>)
 8004bce:	f7ff fe77 	bl	80048c0 <chprintf>
    }
  }
  else {
    chprintf(chp, "atoh error: cannot convert %s\n\r", argv[0]);    
  }
}
 8004bd2:	b003      	add	sp, #12
 8004bd4:	bd30      	pop	{r4, r5, pc}
      chprintf(chp, "Wrote 0x%x to dac 1\n\r", tmp);
      dacConvertOne(&DACD1,tmp);
    }
  }
  else {
    chprintf(chp, "atoh error: cannot convert %s\n\r", argv[0]);    
 8004bd6:	4628      	mov	r0, r5
 8004bd8:	6822      	ldr	r2, [r4, #0]
 8004bda:	4906      	ldr	r1, [pc, #24]	; (8004bf4 <cmd_dac+0x64>)
 8004bdc:	f7ff fe70 	bl	80048c0 <chprintf>
  }
}
 8004be0:	b003      	add	sp, #12
 8004be2:	bd30      	pop	{r4, r5, pc}
 8004be4:	08006dbc 	.word	0x08006dbc
 8004be8:	08006e38 	.word	0x08006e38
 8004bec:	200012b8 	.word	0x200012b8
 8004bf0:	08006e00 	.word	0x08006e00
 8004bf4:	08006e50 	.word	0x08006e50
 8004bf8:	f3af 8000 	nop.w
 8004bfc:	f3af 8000 	nop.w

08004c00 <arm_dot_prod_q31>:
 8004c00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004c04:	b08f      	sub	sp, #60	; 0x3c
 8004c06:	4694      	mov	ip, r2
 8004c08:	9308      	str	r3, [sp, #32]
 8004c0a:	0893      	lsrs	r3, r2, #2
 8004c0c:	9309      	str	r3, [sp, #36]	; 0x24
 8004c0e:	f000 8091 	beq.w	8004d34 <arm_dot_prod_q31+0x134>
 8004c12:	f04f 0800 	mov.w	r8, #0
 8004c16:	f04f 0900 	mov.w	r9, #0
 8004c1a:	e9cd 8904 	strd	r8, r9, [sp, #16]
 8004c1e:	e9cd ab0c 	strd	sl, fp, [sp, #48]	; 0x30
 8004c22:	f100 0710 	add.w	r7, r0, #16
 8004c26:	f101 0610 	add.w	r6, r1, #16
 8004c2a:	469e      	mov	lr, r3
 8004c2c:	900a      	str	r0, [sp, #40]	; 0x28
 8004c2e:	910b      	str	r1, [sp, #44]	; 0x2c
 8004c30:	f857 0c10 	ldr.w	r0, [r7, #-16]
 8004c34:	f856 1c10 	ldr.w	r1, [r6, #-16]
 8004c38:	f856 3c0c 	ldr.w	r3, [r6, #-12]
 8004c3c:	9306      	str	r3, [sp, #24]
 8004c3e:	fb80 0101 	smull	r0, r1, r0, r1
 8004c42:	0b83      	lsrs	r3, r0, #14
 8004c44:	9300      	str	r3, [sp, #0]
 8004c46:	f857 2c0c 	ldr.w	r2, [r7, #-12]
 8004c4a:	9b06      	ldr	r3, [sp, #24]
 8004c4c:	f857 0c08 	ldr.w	r0, [r7, #-8]
 8004c50:	fb82 2303 	smull	r2, r3, r2, r3
 8004c54:	4699      	mov	r9, r3
 8004c56:	9b00      	ldr	r3, [sp, #0]
 8004c58:	4690      	mov	r8, r2
 8004c5a:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 8004c5e:	9300      	str	r3, [sp, #0]
 8004c60:	4643      	mov	r3, r8
 8004c62:	0b9b      	lsrs	r3, r3, #14
 8004c64:	9302      	str	r3, [sp, #8]
 8004c66:	138b      	asrs	r3, r1, #14
 8004c68:	9301      	str	r3, [sp, #4]
 8004c6a:	9b02      	ldr	r3, [sp, #8]
 8004c6c:	f856 2c08 	ldr.w	r2, [r6, #-8]
 8004c70:	ea43 4389 	orr.w	r3, r3, r9, lsl #18
 8004c74:	fb80 0102 	smull	r0, r1, r0, r2
 8004c78:	e9cd 8906 	strd	r8, r9, [sp, #24]
 8004c7c:	9302      	str	r3, [sp, #8]
 8004c7e:	e9dd 8900 	ldrd	r8, r9, [sp]
 8004c82:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8004c86:	eb12 0208 	adds.w	r2, r2, r8
 8004c8a:	eb43 0309 	adc.w	r3, r3, r9
 8004c8e:	4699      	mov	r9, r3
 8004c90:	9b07      	ldr	r3, [sp, #28]
 8004c92:	139b      	asrs	r3, r3, #14
 8004c94:	4690      	mov	r8, r2
 8004c96:	9303      	str	r3, [sp, #12]
 8004c98:	f856 2c04 	ldr.w	r2, [r6, #-4]
 8004c9c:	f857 3c04 	ldr.w	r3, [r7, #-4]
 8004ca0:	fb83 2302 	smull	r2, r3, r3, r2
 8004ca4:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8004ca8:	0b94      	lsrs	r4, r2, #14
 8004caa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8004cae:	ea4f 3a90 	mov.w	sl, r0, lsr #14
 8004cb2:	ea4a 4a81 	orr.w	sl, sl, r1, lsl #18
 8004cb6:	ea4f 3ba1 	mov.w	fp, r1, asr #14
 8004cba:	9905      	ldr	r1, [sp, #20]
 8004cbc:	eb12 0208 	adds.w	r2, r2, r8
 8004cc0:	eb43 0309 	adc.w	r3, r3, r9
 8004cc4:	ea44 4481 	orr.w	r4, r4, r1, lsl #18
 8004cc8:	eb12 080a 	adds.w	r8, r2, sl
 8004ccc:	eb43 090b 	adc.w	r9, r3, fp
 8004cd0:	138d      	asrs	r5, r1, #14
 8004cd2:	eb18 0204 	adds.w	r2, r8, r4
 8004cd6:	eb49 0305 	adc.w	r3, r9, r5
 8004cda:	f1be 0e01 	subs.w	lr, lr, #1
 8004cde:	f107 0710 	add.w	r7, r7, #16
 8004ce2:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8004ce6:	f106 0610 	add.w	r6, r6, #16
 8004cea:	d1a1      	bne.n	8004c30 <arm_dot_prod_q31+0x30>
 8004cec:	4699      	mov	r9, r3
 8004cee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004cf0:	980a      	ldr	r0, [sp, #40]	; 0x28
 8004cf2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8004cf4:	011b      	lsls	r3, r3, #4
 8004cf6:	4690      	mov	r8, r2
 8004cf8:	4418      	add	r0, r3
 8004cfa:	4419      	add	r1, r3
 8004cfc:	f01c 0c03 	ands.w	ip, ip, #3
 8004d00:	d012      	beq.n	8004d28 <arm_dot_prod_q31+0x128>
 8004d02:	f850 3b04 	ldr.w	r3, [r0], #4
 8004d06:	f851 2b04 	ldr.w	r2, [r1], #4
 8004d0a:	fb83 2302 	smull	r2, r3, r3, r2
 8004d0e:	ea4f 3a92 	mov.w	sl, r2, lsr #14
 8004d12:	ea4a 4a83 	orr.w	sl, sl, r3, lsl #18
 8004d16:	eb18 080a 	adds.w	r8, r8, sl
 8004d1a:	ea4f 3ba3 	mov.w	fp, r3, asr #14
 8004d1e:	eb49 090b 	adc.w	r9, r9, fp
 8004d22:	f1bc 0c01 	subs.w	ip, ip, #1
 8004d26:	d1ec      	bne.n	8004d02 <arm_dot_prod_q31+0x102>
 8004d28:	9b08      	ldr	r3, [sp, #32]
 8004d2a:	e9c3 8900 	strd	r8, r9, [r3]
 8004d2e:	b00f      	add	sp, #60	; 0x3c
 8004d30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004d34:	f04f 0800 	mov.w	r8, #0
 8004d38:	f04f 0900 	mov.w	r9, #0
 8004d3c:	e7de      	b.n	8004cfc <arm_dot_prod_q31+0xfc>
 8004d3e:	bf00      	nop

08004d40 <floor>:
 8004d40:	ec51 0b10 	vmov	r0, r1, d0
 8004d44:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004d48:	f3c1 570a 	ubfx	r7, r1, #20, #11
 8004d4c:	f2a7 35ff 	subw	r5, r7, #1023	; 0x3ff
 8004d50:	2d13      	cmp	r5, #19
 8004d52:	460c      	mov	r4, r1
 8004d54:	ee10 3a10 	vmov	r3, s0
 8004d58:	4688      	mov	r8, r1
 8004d5a:	4606      	mov	r6, r0
 8004d5c:	dc1c      	bgt.n	8004d98 <floor+0x58>
 8004d5e:	2d00      	cmp	r5, #0
 8004d60:	db42      	blt.n	8004de8 <floor+0xa8>
 8004d62:	4f3d      	ldr	r7, [pc, #244]	; (8004e58 <floor+0x118>)
 8004d64:	412f      	asrs	r7, r5
 8004d66:	ea07 0201 	and.w	r2, r7, r1
 8004d6a:	4313      	orrs	r3, r2
 8004d6c:	d019      	beq.n	8004da2 <floor+0x62>
 8004d6e:	a338      	add	r3, pc, #224	; (adr r3, 8004e50 <floor+0x110>)
 8004d70:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004d74:	f7fb fb42 	bl	80003fc <__adddf3>
 8004d78:	2200      	movs	r2, #0
 8004d7a:	2300      	movs	r3, #0
 8004d7c:	f7fb ff86 	bl	8000c8c <__aeabi_dcmpgt>
 8004d80:	b120      	cbz	r0, 8004d8c <floor+0x4c>
 8004d82:	2c00      	cmp	r4, #0
 8004d84:	db49      	blt.n	8004e1a <floor+0xda>
 8004d86:	ea28 0407 	bic.w	r4, r8, r7
 8004d8a:	2600      	movs	r6, #0
 8004d8c:	4623      	mov	r3, r4
 8004d8e:	4632      	mov	r2, r6
 8004d90:	ec43 2b10 	vmov	d0, r2, r3
 8004d94:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004d98:	2d33      	cmp	r5, #51	; 0x33
 8004d9a:	dd06      	ble.n	8004daa <floor+0x6a>
 8004d9c:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 8004da0:	d032      	beq.n	8004e08 <floor+0xc8>
 8004da2:	ec41 0b10 	vmov	d0, r0, r1
 8004da6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004daa:	f2a7 4313 	subw	r3, r7, #1043	; 0x413
 8004dae:	f04f 39ff 	mov.w	r9, #4294967295
 8004db2:	fa29 f903 	lsr.w	r9, r9, r3
 8004db6:	ea19 0f00 	tst.w	r9, r0
 8004dba:	d0f2      	beq.n	8004da2 <floor+0x62>
 8004dbc:	a324      	add	r3, pc, #144	; (adr r3, 8004e50 <floor+0x110>)
 8004dbe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004dc2:	f7fb fb1b 	bl	80003fc <__adddf3>
 8004dc6:	2200      	movs	r2, #0
 8004dc8:	2300      	movs	r3, #0
 8004dca:	f7fb ff5f 	bl	8000c8c <__aeabi_dcmpgt>
 8004dce:	2800      	cmp	r0, #0
 8004dd0:	d0dc      	beq.n	8004d8c <floor+0x4c>
 8004dd2:	2c00      	cmp	r4, #0
 8004dd4:	db26      	blt.n	8004e24 <floor+0xe4>
 8004dd6:	4644      	mov	r4, r8
 8004dd8:	ea26 0609 	bic.w	r6, r6, r9
 8004ddc:	4623      	mov	r3, r4
 8004dde:	4632      	mov	r2, r6
 8004de0:	ec43 2b10 	vmov	d0, r2, r3
 8004de4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004de8:	a319      	add	r3, pc, #100	; (adr r3, 8004e50 <floor+0x110>)
 8004dea:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004dee:	f7fb fb05 	bl	80003fc <__adddf3>
 8004df2:	2200      	movs	r2, #0
 8004df4:	2300      	movs	r3, #0
 8004df6:	f7fb ff49 	bl	8000c8c <__aeabi_dcmpgt>
 8004dfa:	2800      	cmp	r0, #0
 8004dfc:	d0c6      	beq.n	8004d8c <floor+0x4c>
 8004dfe:	2c00      	cmp	r4, #0
 8004e00:	db1c      	blt.n	8004e3c <floor+0xfc>
 8004e02:	2600      	movs	r6, #0
 8004e04:	4634      	mov	r4, r6
 8004e06:	e7c1      	b.n	8004d8c <floor+0x4c>
 8004e08:	ee10 2a10 	vmov	r2, s0
 8004e0c:	460b      	mov	r3, r1
 8004e0e:	f7fb faf5 	bl	80003fc <__adddf3>
 8004e12:	ec41 0b10 	vmov	d0, r0, r1
 8004e16:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004e1a:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8004e1e:	412b      	asrs	r3, r5
 8004e20:	4498      	add	r8, r3
 8004e22:	e7b0      	b.n	8004d86 <floor+0x46>
 8004e24:	2d14      	cmp	r5, #20
 8004e26:	d006      	beq.n	8004e36 <floor+0xf6>
 8004e28:	f5c7 6786 	rsb	r7, r7, #1072	; 0x430
 8004e2c:	3703      	adds	r7, #3
 8004e2e:	2301      	movs	r3, #1
 8004e30:	40bb      	lsls	r3, r7
 8004e32:	199e      	adds	r6, r3, r6
 8004e34:	d3cf      	bcc.n	8004dd6 <floor+0x96>
 8004e36:	f108 0801 	add.w	r8, r8, #1
 8004e3a:	e7cc      	b.n	8004dd6 <floor+0x96>
 8004e3c:	f024 4200 	bic.w	r2, r4, #2147483648	; 0x80000000
 8004e40:	4b06      	ldr	r3, [pc, #24]	; (8004e5c <floor+0x11c>)
 8004e42:	4332      	orrs	r2, r6
 8004e44:	bf18      	it	ne
 8004e46:	461c      	movne	r4, r3
 8004e48:	2600      	movs	r6, #0
 8004e4a:	e79f      	b.n	8004d8c <floor+0x4c>
 8004e4c:	f3af 8000 	nop.w
 8004e50:	8800759c 	.word	0x8800759c
 8004e54:	7e37e43c 	.word	0x7e37e43c
 8004e58:	000fffff 	.word	0x000fffff
 8004e5c:	bff00000 	.word	0xbff00000

08004e60 <__fpclassifyd>:
 8004e60:	ec53 2b10 	vmov	r2, r3, d0
 8004e64:	b410      	push	{r4}
 8004e66:	f033 4400 	bics.w	r4, r3, #2147483648	; 0x80000000
 8004e6a:	d008      	beq.n	8004e7e <__fpclassifyd+0x1e>
 8004e6c:	4911      	ldr	r1, [pc, #68]	; (8004eb4 <__fpclassifyd+0x54>)
 8004e6e:	f5a3 1080 	sub.w	r0, r3, #1048576	; 0x100000
 8004e72:	4288      	cmp	r0, r1
 8004e74:	d808      	bhi.n	8004e88 <__fpclassifyd+0x28>
 8004e76:	2004      	movs	r0, #4
 8004e78:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004e7c:	4770      	bx	lr
 8004e7e:	b91a      	cbnz	r2, 8004e88 <__fpclassifyd+0x28>
 8004e80:	2002      	movs	r0, #2
 8004e82:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004e86:	4770      	bx	lr
 8004e88:	f103 43ff 	add.w	r3, r3, #2139095040	; 0x7f800000
 8004e8c:	4909      	ldr	r1, [pc, #36]	; (8004eb4 <__fpclassifyd+0x54>)
 8004e8e:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
 8004e92:	428b      	cmp	r3, r1
 8004e94:	d9ef      	bls.n	8004e76 <__fpclassifyd+0x16>
 8004e96:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
 8004e9a:	d201      	bcs.n	8004ea0 <__fpclassifyd+0x40>
 8004e9c:	2003      	movs	r0, #3
 8004e9e:	e7eb      	b.n	8004e78 <__fpclassifyd+0x18>
 8004ea0:	4b05      	ldr	r3, [pc, #20]	; (8004eb8 <__fpclassifyd+0x58>)
 8004ea2:	429c      	cmp	r4, r3
 8004ea4:	d001      	beq.n	8004eaa <__fpclassifyd+0x4a>
 8004ea6:	2000      	movs	r0, #0
 8004ea8:	e7e6      	b.n	8004e78 <__fpclassifyd+0x18>
 8004eaa:	fab2 f082 	clz	r0, r2
 8004eae:	0940      	lsrs	r0, r0, #5
 8004eb0:	e7e2      	b.n	8004e78 <__fpclassifyd+0x18>
 8004eb2:	bf00      	nop
 8004eb4:	7fdfffff 	.word	0x7fdfffff
 8004eb8:	7ff00000 	.word	0x7ff00000
 8004ebc:	00000000 	.word	0x00000000

08004ec0 <__fpclassifyf>:
 8004ec0:	ee10 3a10 	vmov	r3, s0
 8004ec4:	f033 4000 	bics.w	r0, r3, #2147483648	; 0x80000000
 8004ec8:	d101      	bne.n	8004ece <__fpclassifyf+0xe>
 8004eca:	2002      	movs	r0, #2
 8004ecc:	4770      	bx	lr
 8004ece:	f5a0 0300 	sub.w	r3, r0, #8388608	; 0x800000
 8004ed2:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 8004ed6:	d201      	bcs.n	8004edc <__fpclassifyf+0x1c>
 8004ed8:	2004      	movs	r0, #4
 8004eda:	4770      	bx	lr
 8004edc:	4b05      	ldr	r3, [pc, #20]	; (8004ef4 <__fpclassifyf+0x34>)
 8004ede:	1e42      	subs	r2, r0, #1
 8004ee0:	429a      	cmp	r2, r3
 8004ee2:	d801      	bhi.n	8004ee8 <__fpclassifyf+0x28>
 8004ee4:	2003      	movs	r0, #3
 8004ee6:	4770      	bx	lr
 8004ee8:	f1a0 40ff 	sub.w	r0, r0, #2139095040	; 0x7f800000
 8004eec:	fab0 f080 	clz	r0, r0
 8004ef0:	0940      	lsrs	r0, r0, #5
 8004ef2:	4770      	bx	lr
 8004ef4:	007ffffe 	.word	0x007ffffe
	...

08004f00 <log10>:
 8004f00:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004f02:	ed2d 8b04 	vpush	{d8-d9}
 8004f06:	eeb0 9a40 	vmov.f32	s18, s0
 8004f0a:	eef0 9a60 	vmov.f32	s19, s1
 8004f0e:	4c3b      	ldr	r4, [pc, #236]	; (8004ffc <log10+0xfc>)
 8004f10:	b08b      	sub	sp, #44	; 0x2c
 8004f12:	f000 fa1d 	bl	8005350 <__ieee754_log10>
 8004f16:	f994 3000 	ldrsb.w	r3, [r4]
 8004f1a:	eeb0 8a40 	vmov.f32	s16, s0
 8004f1e:	eef0 8a60 	vmov.f32	s17, s1
 8004f22:	3301      	adds	r3, #1
 8004f24:	d00d      	beq.n	8004f42 <log10+0x42>
 8004f26:	eeb0 0a49 	vmov.f32	s0, s18
 8004f2a:	eef0 0a69 	vmov.f32	s1, s19
 8004f2e:	f7ff ff97 	bl	8004e60 <__fpclassifyd>
 8004f32:	b130      	cbz	r0, 8004f42 <log10+0x42>
 8004f34:	ec51 0b19 	vmov	r0, r1, d9
 8004f38:	2200      	movs	r2, #0
 8004f3a:	2300      	movs	r3, #0
 8004f3c:	f7fb fe92 	bl	8000c64 <__aeabi_dcmple>
 8004f40:	b938      	cbnz	r0, 8004f52 <log10+0x52>
 8004f42:	eeb0 0a48 	vmov.f32	s0, s16
 8004f46:	eef0 0a68 	vmov.f32	s1, s17
 8004f4a:	b00b      	add	sp, #44	; 0x2c
 8004f4c:	ecbd 8b04 	vpop	{d8-d9}
 8004f50:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004f52:	4b2b      	ldr	r3, [pc, #172]	; (8005000 <log10+0x100>)
 8004f54:	7824      	ldrb	r4, [r4, #0]
 8004f56:	9301      	str	r3, [sp, #4]
 8004f58:	2300      	movs	r3, #0
 8004f5a:	ed8d 9b02 	vstr	d9, [sp, #8]
 8004f5e:	ed8d 9b04 	vstr	d9, [sp, #16]
 8004f62:	9308      	str	r3, [sp, #32]
 8004f64:	b99c      	cbnz	r4, 8004f8e <log10+0x8e>
 8004f66:	4d27      	ldr	r5, [pc, #156]	; (8005004 <log10+0x104>)
 8004f68:	f04f 4460 	mov.w	r4, #3758096384	; 0xe0000000
 8004f6c:	ec51 0b19 	vmov	r0, r1, d9
 8004f70:	2200      	movs	r2, #0
 8004f72:	2300      	movs	r3, #0
 8004f74:	e9cd 4506 	strd	r4, r5, [sp, #24]
 8004f78:	f7fb fe60 	bl	8000c3c <__aeabi_dcmpeq>
 8004f7c:	2800      	cmp	r0, #0
 8004f7e:	d134      	bne.n	8004fea <log10+0xea>
 8004f80:	2301      	movs	r3, #1
 8004f82:	9300      	str	r3, [sp, #0]
 8004f84:	4668      	mov	r0, sp
 8004f86:	f001 f8db 	bl	8006140 <matherr>
 8004f8a:	b998      	cbnz	r0, 8004fb4 <log10+0xb4>
 8004f8c:	e00e      	b.n	8004fac <log10+0xac>
 8004f8e:	4f1e      	ldr	r7, [pc, #120]	; (8005008 <log10+0x108>)
 8004f90:	2600      	movs	r6, #0
 8004f92:	ec51 0b19 	vmov	r0, r1, d9
 8004f96:	2200      	movs	r2, #0
 8004f98:	2300      	movs	r3, #0
 8004f9a:	e9cd 6706 	strd	r6, r7, [sp, #24]
 8004f9e:	f7fb fe4d 	bl	8000c3c <__aeabi_dcmpeq>
 8004fa2:	b9a0      	cbnz	r0, 8004fce <log10+0xce>
 8004fa4:	2301      	movs	r3, #1
 8004fa6:	2c02      	cmp	r4, #2
 8004fa8:	9300      	str	r3, [sp, #0]
 8004faa:	d1eb      	bne.n	8004f84 <log10+0x84>
 8004fac:	f001 fc08 	bl	80067c0 <__errno>
 8004fb0:	2321      	movs	r3, #33	; 0x21
 8004fb2:	6003      	str	r3, [r0, #0]
 8004fb4:	4815      	ldr	r0, [pc, #84]	; (800500c <log10+0x10c>)
 8004fb6:	f001 f8cb 	bl	8006150 <nan>
 8004fba:	ed8d 0b06 	vstr	d0, [sp, #24]
 8004fbe:	9b08      	ldr	r3, [sp, #32]
 8004fc0:	b9b3      	cbnz	r3, 8004ff0 <log10+0xf0>
 8004fc2:	ed9d 0b06 	vldr	d0, [sp, #24]
 8004fc6:	b00b      	add	sp, #44	; 0x2c
 8004fc8:	ecbd 8b04 	vpop	{d8-d9}
 8004fcc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004fce:	2302      	movs	r3, #2
 8004fd0:	429c      	cmp	r4, r3
 8004fd2:	9300      	str	r3, [sp, #0]
 8004fd4:	d004      	beq.n	8004fe0 <log10+0xe0>
 8004fd6:	4668      	mov	r0, sp
 8004fd8:	f001 f8b2 	bl	8006140 <matherr>
 8004fdc:	2800      	cmp	r0, #0
 8004fde:	d1ee      	bne.n	8004fbe <log10+0xbe>
 8004fe0:	f001 fbee 	bl	80067c0 <__errno>
 8004fe4:	2322      	movs	r3, #34	; 0x22
 8004fe6:	6003      	str	r3, [r0, #0]
 8004fe8:	e7e9      	b.n	8004fbe <log10+0xbe>
 8004fea:	2302      	movs	r3, #2
 8004fec:	9300      	str	r3, [sp, #0]
 8004fee:	e7f2      	b.n	8004fd6 <log10+0xd6>
 8004ff0:	f001 fbe6 	bl	80067c0 <__errno>
 8004ff4:	9b08      	ldr	r3, [sp, #32]
 8004ff6:	6003      	str	r3, [r0, #0]
 8004ff8:	e7e3      	b.n	8004fc2 <log10+0xc2>
 8004ffa:	bf00      	nop
 8004ffc:	20000abc 	.word	0x20000abc
 8005000:	08006ed0 	.word	0x08006ed0
 8005004:	c7efffff 	.word	0xc7efffff
 8005008:	fff00000 	.word	0xfff00000
 800500c:	08006cf4 	.word	0x08006cf4

08005010 <pow>:
 8005010:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8005014:	ed2d 8b06 	vpush	{d8-d10}
 8005018:	eeb0 aa40 	vmov.f32	s20, s0
 800501c:	eef0 aa60 	vmov.f32	s21, s1
 8005020:	eeb0 9a41 	vmov.f32	s18, s2
 8005024:	eef0 9a61 	vmov.f32	s19, s3
 8005028:	4cb3      	ldr	r4, [pc, #716]	; (80052f8 <pow+0x2e8>)
 800502a:	b08b      	sub	sp, #44	; 0x2c
 800502c:	f000 fa30 	bl	8005490 <__ieee754_pow>
 8005030:	f994 3000 	ldrsb.w	r3, [r4]
 8005034:	eeb0 8a40 	vmov.f32	s16, s0
 8005038:	eef0 8a60 	vmov.f32	s17, s1
 800503c:	3301      	adds	r3, #1
 800503e:	d006      	beq.n	800504e <pow+0x3e>
 8005040:	eeb0 0a49 	vmov.f32	s0, s18
 8005044:	eef0 0a69 	vmov.f32	s1, s19
 8005048:	f7ff ff0a 	bl	8004e60 <__fpclassifyd>
 800504c:	b940      	cbnz	r0, 8005060 <pow+0x50>
 800504e:	eeb0 0a48 	vmov.f32	s0, s16
 8005052:	eef0 0a68 	vmov.f32	s1, s17
 8005056:	b00b      	add	sp, #44	; 0x2c
 8005058:	ecbd 8b06 	vpop	{d8-d10}
 800505c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8005060:	eeb0 0a4a 	vmov.f32	s0, s20
 8005064:	eef0 0a6a 	vmov.f32	s1, s21
 8005068:	f7ff fefa 	bl	8004e60 <__fpclassifyd>
 800506c:	4605      	mov	r5, r0
 800506e:	bb68      	cbnz	r0, 80050cc <pow+0xbc>
 8005070:	ec51 0b19 	vmov	r0, r1, d9
 8005074:	2200      	movs	r2, #0
 8005076:	2300      	movs	r3, #0
 8005078:	f7fb fde0 	bl	8000c3c <__aeabi_dcmpeq>
 800507c:	2800      	cmp	r0, #0
 800507e:	d0e6      	beq.n	800504e <pow+0x3e>
 8005080:	4a9e      	ldr	r2, [pc, #632]	; (80052fc <pow+0x2ec>)
 8005082:	f994 3000 	ldrsb.w	r3, [r4]
 8005086:	4f9e      	ldr	r7, [pc, #632]	; (8005300 <pow+0x2f0>)
 8005088:	9508      	str	r5, [sp, #32]
 800508a:	2101      	movs	r1, #1
 800508c:	2600      	movs	r6, #0
 800508e:	e88d 0006 	stmia.w	sp, {r1, r2}
 8005092:	1c5a      	adds	r2, r3, #1
 8005094:	ed8d ab02 	vstr	d10, [sp, #8]
 8005098:	ed8d 9b04 	vstr	d9, [sp, #16]
 800509c:	e9cd 6706 	strd	r6, r7, [sp, #24]
 80050a0:	d00d      	beq.n	80050be <pow+0xae>
 80050a2:	2b02      	cmp	r3, #2
 80050a4:	d00b      	beq.n	80050be <pow+0xae>
 80050a6:	4668      	mov	r0, sp
 80050a8:	f001 f84a 	bl	8006140 <matherr>
 80050ac:	2800      	cmp	r0, #0
 80050ae:	f000 809d 	beq.w	80051ec <pow+0x1dc>
 80050b2:	9b08      	ldr	r3, [sp, #32]
 80050b4:	b11b      	cbz	r3, 80050be <pow+0xae>
 80050b6:	f001 fb83 	bl	80067c0 <__errno>
 80050ba:	9b08      	ldr	r3, [sp, #32]
 80050bc:	6003      	str	r3, [r0, #0]
 80050be:	ed9d 0b06 	vldr	d0, [sp, #24]
 80050c2:	b00b      	add	sp, #44	; 0x2c
 80050c4:	ecbd 8b06 	vpop	{d8-d10}
 80050c8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80050cc:	2600      	movs	r6, #0
 80050ce:	2700      	movs	r7, #0
 80050d0:	ec51 0b1a 	vmov	r0, r1, d10
 80050d4:	4632      	mov	r2, r6
 80050d6:	463b      	mov	r3, r7
 80050d8:	f7fb fdb0 	bl	8000c3c <__aeabi_dcmpeq>
 80050dc:	b1e8      	cbz	r0, 800511a <pow+0x10a>
 80050de:	ec51 0b19 	vmov	r0, r1, d9
 80050e2:	4632      	mov	r2, r6
 80050e4:	463b      	mov	r3, r7
 80050e6:	f7fb fda9 	bl	8000c3c <__aeabi_dcmpeq>
 80050ea:	4605      	mov	r5, r0
 80050ec:	2800      	cmp	r0, #0
 80050ee:	d054      	beq.n	800519a <pow+0x18a>
 80050f0:	4a82      	ldr	r2, [pc, #520]	; (80052fc <pow+0x2ec>)
 80050f2:	f994 3000 	ldrsb.w	r3, [r4]
 80050f6:	9201      	str	r2, [sp, #4]
 80050f8:	2101      	movs	r1, #1
 80050fa:	2200      	movs	r2, #0
 80050fc:	ed8d ab02 	vstr	d10, [sp, #8]
 8005100:	ed8d 9b04 	vstr	d9, [sp, #16]
 8005104:	e9cd 6706 	strd	r6, r7, [sp, #24]
 8005108:	9100      	str	r1, [sp, #0]
 800510a:	9208      	str	r2, [sp, #32]
 800510c:	2b00      	cmp	r3, #0
 800510e:	d0ca      	beq.n	80050a6 <pow+0x96>
 8005110:	4b7b      	ldr	r3, [pc, #492]	; (8005300 <pow+0x2f0>)
 8005112:	2200      	movs	r2, #0
 8005114:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8005118:	e7d1      	b.n	80050be <pow+0xae>
 800511a:	eeb0 0a48 	vmov.f32	s0, s16
 800511e:	eef0 0a68 	vmov.f32	s1, s17
 8005122:	f001 f805 	bl	8006130 <finite>
 8005126:	4605      	mov	r5, r0
 8005128:	2800      	cmp	r0, #0
 800512a:	d064      	beq.n	80051f6 <pow+0x1e6>
 800512c:	2600      	movs	r6, #0
 800512e:	2700      	movs	r7, #0
 8005130:	ec51 0b18 	vmov	r0, r1, d8
 8005134:	4632      	mov	r2, r6
 8005136:	463b      	mov	r3, r7
 8005138:	f7fb fd80 	bl	8000c3c <__aeabi_dcmpeq>
 800513c:	2800      	cmp	r0, #0
 800513e:	d086      	beq.n	800504e <pow+0x3e>
 8005140:	eeb0 0a4a 	vmov.f32	s0, s20
 8005144:	eef0 0a6a 	vmov.f32	s1, s21
 8005148:	f000 fff2 	bl	8006130 <finite>
 800514c:	2800      	cmp	r0, #0
 800514e:	f43f af7e 	beq.w	800504e <pow+0x3e>
 8005152:	eeb0 0a49 	vmov.f32	s0, s18
 8005156:	eef0 0a69 	vmov.f32	s1, s19
 800515a:	f000 ffe9 	bl	8006130 <finite>
 800515e:	2800      	cmp	r0, #0
 8005160:	f43f af75 	beq.w	800504e <pow+0x3e>
 8005164:	f994 3000 	ldrsb.w	r3, [r4]
 8005168:	4a64      	ldr	r2, [pc, #400]	; (80052fc <pow+0x2ec>)
 800516a:	9201      	str	r2, [sp, #4]
 800516c:	2104      	movs	r1, #4
 800516e:	2200      	movs	r2, #0
 8005170:	2b02      	cmp	r3, #2
 8005172:	ed8d ab02 	vstr	d10, [sp, #8]
 8005176:	ed8d 9b04 	vstr	d9, [sp, #16]
 800517a:	e9cd 6706 	strd	r6, r7, [sp, #24]
 800517e:	9100      	str	r1, [sp, #0]
 8005180:	9208      	str	r2, [sp, #32]
 8005182:	f000 808c 	beq.w	800529e <pow+0x28e>
 8005186:	4668      	mov	r0, sp
 8005188:	f000 ffda 	bl	8006140 <matherr>
 800518c:	2800      	cmp	r0, #0
 800518e:	f000 8086 	beq.w	800529e <pow+0x28e>
 8005192:	9b08      	ldr	r3, [sp, #32]
 8005194:	2b00      	cmp	r3, #0
 8005196:	d092      	beq.n	80050be <pow+0xae>
 8005198:	e78d      	b.n	80050b6 <pow+0xa6>
 800519a:	eeb0 0a49 	vmov.f32	s0, s18
 800519e:	eef0 0a69 	vmov.f32	s1, s19
 80051a2:	f000 ffc5 	bl	8006130 <finite>
 80051a6:	2800      	cmp	r0, #0
 80051a8:	f43f af51 	beq.w	800504e <pow+0x3e>
 80051ac:	ec51 0b19 	vmov	r0, r1, d9
 80051b0:	4632      	mov	r2, r6
 80051b2:	463b      	mov	r3, r7
 80051b4:	f7fb fd4c 	bl	8000c50 <__aeabi_dcmplt>
 80051b8:	2800      	cmp	r0, #0
 80051ba:	f43f af48 	beq.w	800504e <pow+0x3e>
 80051be:	4a4f      	ldr	r2, [pc, #316]	; (80052fc <pow+0x2ec>)
 80051c0:	7823      	ldrb	r3, [r4, #0]
 80051c2:	9508      	str	r5, [sp, #32]
 80051c4:	2101      	movs	r1, #1
 80051c6:	ed8d ab02 	vstr	d10, [sp, #8]
 80051ca:	ed8d 9b04 	vstr	d9, [sp, #16]
 80051ce:	e88d 0006 	stmia.w	sp, {r1, r2}
 80051d2:	2b00      	cmp	r3, #0
 80051d4:	d041      	beq.n	800525a <pow+0x24a>
 80051d6:	494b      	ldr	r1, [pc, #300]	; (8005304 <pow+0x2f4>)
 80051d8:	2000      	movs	r0, #0
 80051da:	2b02      	cmp	r3, #2
 80051dc:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80051e0:	d135      	bne.n	800524e <pow+0x23e>
 80051e2:	f001 faed 	bl	80067c0 <__errno>
 80051e6:	2321      	movs	r3, #33	; 0x21
 80051e8:	6003      	str	r3, [r0, #0]
 80051ea:	e7d2      	b.n	8005192 <pow+0x182>
 80051ec:	f001 fae8 	bl	80067c0 <__errno>
 80051f0:	2321      	movs	r3, #33	; 0x21
 80051f2:	6003      	str	r3, [r0, #0]
 80051f4:	e75d      	b.n	80050b2 <pow+0xa2>
 80051f6:	eeb0 0a4a 	vmov.f32	s0, s20
 80051fa:	eef0 0a6a 	vmov.f32	s1, s21
 80051fe:	f000 ff97 	bl	8006130 <finite>
 8005202:	2800      	cmp	r0, #0
 8005204:	d092      	beq.n	800512c <pow+0x11c>
 8005206:	eeb0 0a49 	vmov.f32	s0, s18
 800520a:	eef0 0a69 	vmov.f32	s1, s19
 800520e:	f000 ff8f 	bl	8006130 <finite>
 8005212:	2800      	cmp	r0, #0
 8005214:	d08a      	beq.n	800512c <pow+0x11c>
 8005216:	eeb0 0a48 	vmov.f32	s0, s16
 800521a:	eef0 0a68 	vmov.f32	s1, s17
 800521e:	f7ff fe1f 	bl	8004e60 <__fpclassifyd>
 8005222:	b9e8      	cbnz	r0, 8005260 <pow+0x250>
 8005224:	4b35      	ldr	r3, [pc, #212]	; (80052fc <pow+0x2ec>)
 8005226:	7824      	ldrb	r4, [r4, #0]
 8005228:	9008      	str	r0, [sp, #32]
 800522a:	2201      	movs	r2, #1
 800522c:	ed8d ab02 	vstr	d10, [sp, #8]
 8005230:	ed8d 9b04 	vstr	d9, [sp, #16]
 8005234:	e88d 000c 	stmia.w	sp, {r2, r3}
 8005238:	b17c      	cbz	r4, 800525a <pow+0x24a>
 800523a:	4630      	mov	r0, r6
 800523c:	4639      	mov	r1, r7
 800523e:	4632      	mov	r2, r6
 8005240:	463b      	mov	r3, r7
 8005242:	f7fb fbb7 	bl	80009b4 <__aeabi_ddiv>
 8005246:	2c02      	cmp	r4, #2
 8005248:	e9cd 0106 	strd	r0, r1, [sp, #24]
 800524c:	d0c9      	beq.n	80051e2 <pow+0x1d2>
 800524e:	4668      	mov	r0, sp
 8005250:	f000 ff76 	bl	8006140 <matherr>
 8005254:	2800      	cmp	r0, #0
 8005256:	d19c      	bne.n	8005192 <pow+0x182>
 8005258:	e7c3      	b.n	80051e2 <pow+0x1d2>
 800525a:	e9cd 6706 	strd	r6, r7, [sp, #24]
 800525e:	e7f6      	b.n	800524e <pow+0x23e>
 8005260:	4a26      	ldr	r2, [pc, #152]	; (80052fc <pow+0x2ec>)
 8005262:	f994 3000 	ldrsb.w	r3, [r4]
 8005266:	9508      	str	r5, [sp, #32]
 8005268:	2103      	movs	r1, #3
 800526a:	ed8d ab02 	vstr	d10, [sp, #8]
 800526e:	ed8d 9b04 	vstr	d9, [sp, #16]
 8005272:	e88d 0006 	stmia.w	sp, {r1, r2}
 8005276:	b9bb      	cbnz	r3, 80052a8 <pow+0x298>
 8005278:	f8df 9090 	ldr.w	r9, [pc, #144]	; 800530c <pow+0x2fc>
 800527c:	f04f 4860 	mov.w	r8, #3758096384	; 0xe0000000
 8005280:	4632      	mov	r2, r6
 8005282:	463b      	mov	r3, r7
 8005284:	ec51 0b1a 	vmov	r0, r1, d10
 8005288:	e9cd 8906 	strd	r8, r9, [sp, #24]
 800528c:	f7fb fce0 	bl	8000c50 <__aeabi_dcmplt>
 8005290:	2800      	cmp	r0, #0
 8005292:	d13f      	bne.n	8005314 <pow+0x304>
 8005294:	f994 3000 	ldrsb.w	r3, [r4]
 8005298:	2b02      	cmp	r3, #2
 800529a:	f47f af74 	bne.w	8005186 <pow+0x176>
 800529e:	f001 fa8f 	bl	80067c0 <__errno>
 80052a2:	2322      	movs	r3, #34	; 0x22
 80052a4:	6003      	str	r3, [r0, #0]
 80052a6:	e774      	b.n	8005192 <pow+0x182>
 80052a8:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8005310 <pow+0x300>
 80052ac:	f04f 0800 	mov.w	r8, #0
 80052b0:	4632      	mov	r2, r6
 80052b2:	463b      	mov	r3, r7
 80052b4:	ec51 0b1a 	vmov	r0, r1, d10
 80052b8:	e9cd 8906 	strd	r8, r9, [sp, #24]
 80052bc:	f7fb fcc8 	bl	8000c50 <__aeabi_dcmplt>
 80052c0:	2800      	cmp	r0, #0
 80052c2:	d0e7      	beq.n	8005294 <pow+0x284>
 80052c4:	2200      	movs	r2, #0
 80052c6:	4b10      	ldr	r3, [pc, #64]	; (8005308 <pow+0x2f8>)
 80052c8:	ec51 0b19 	vmov	r0, r1, d9
 80052cc:	f7fb fa48 	bl	8000760 <__aeabi_dmul>
 80052d0:	4606      	mov	r6, r0
 80052d2:	460f      	mov	r7, r1
 80052d4:	ec47 6b10 	vmov	d0, r6, r7
 80052d8:	f000 ff42 	bl	8006160 <rint>
 80052dc:	4632      	mov	r2, r6
 80052de:	ec51 0b10 	vmov	r0, r1, d0
 80052e2:	463b      	mov	r3, r7
 80052e4:	f7fb fcaa 	bl	8000c3c <__aeabi_dcmpeq>
 80052e8:	2800      	cmp	r0, #0
 80052ea:	d1d3      	bne.n	8005294 <pow+0x284>
 80052ec:	4b05      	ldr	r3, [pc, #20]	; (8005304 <pow+0x2f4>)
 80052ee:	2200      	movs	r2, #0
 80052f0:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80052f4:	e7ce      	b.n	8005294 <pow+0x284>
 80052f6:	bf00      	nop
 80052f8:	20000abc 	.word	0x20000abc
 80052fc:	08006ee0 	.word	0x08006ee0
 8005300:	3ff00000 	.word	0x3ff00000
 8005304:	fff00000 	.word	0xfff00000
 8005308:	3fe00000 	.word	0x3fe00000
 800530c:	47efffff 	.word	0x47efffff
 8005310:	7ff00000 	.word	0x7ff00000
 8005314:	2200      	movs	r2, #0
 8005316:	4b0c      	ldr	r3, [pc, #48]	; (8005348 <pow+0x338>)
 8005318:	ec51 0b19 	vmov	r0, r1, d9
 800531c:	f7fb fa20 	bl	8000760 <__aeabi_dmul>
 8005320:	4606      	mov	r6, r0
 8005322:	460f      	mov	r7, r1
 8005324:	ec47 6b10 	vmov	d0, r6, r7
 8005328:	f000 ff1a 	bl	8006160 <rint>
 800532c:	4632      	mov	r2, r6
 800532e:	ec51 0b10 	vmov	r0, r1, d0
 8005332:	463b      	mov	r3, r7
 8005334:	f7fb fc82 	bl	8000c3c <__aeabi_dcmpeq>
 8005338:	2800      	cmp	r0, #0
 800533a:	d1ab      	bne.n	8005294 <pow+0x284>
 800533c:	4b03      	ldr	r3, [pc, #12]	; (800534c <pow+0x33c>)
 800533e:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 8005342:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8005346:	e7a5      	b.n	8005294 <pow+0x284>
 8005348:	3fe00000 	.word	0x3fe00000
 800534c:	c7efffff 	.word	0xc7efffff

08005350 <__ieee754_log10>:
 8005350:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005354:	ec55 4b10 	vmov	r4, r5, d0
 8005358:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
 800535c:	462b      	mov	r3, r5
 800535e:	da20      	bge.n	80053a2 <__ieee754_log10+0x52>
 8005360:	ee10 2a10 	vmov	r2, s0
 8005364:	f025 4100 	bic.w	r1, r5, #2147483648	; 0x80000000
 8005368:	430a      	orrs	r2, r1
 800536a:	d060      	beq.n	800542e <__ieee754_log10+0xde>
 800536c:	2d00      	cmp	r5, #0
 800536e:	ee10 0a10 	vmov	r0, s0
 8005372:	4629      	mov	r1, r5
 8005374:	db65      	blt.n	8005442 <__ieee754_log10+0xf2>
 8005376:	2200      	movs	r2, #0
 8005378:	4b3f      	ldr	r3, [pc, #252]	; (8005478 <__ieee754_log10+0x128>)
 800537a:	f7fb f9f1 	bl	8000760 <__aeabi_dmul>
 800537e:	460b      	mov	r3, r1
 8005380:	460d      	mov	r5, r1
 8005382:	493e      	ldr	r1, [pc, #248]	; (800547c <__ieee754_log10+0x12c>)
 8005384:	428b      	cmp	r3, r1
 8005386:	4604      	mov	r4, r0
 8005388:	f06f 0235 	mvn.w	r2, #53	; 0x35
 800538c:	dd0e      	ble.n	80053ac <__ieee754_log10+0x5c>
 800538e:	4620      	mov	r0, r4
 8005390:	4629      	mov	r1, r5
 8005392:	4622      	mov	r2, r4
 8005394:	462b      	mov	r3, r5
 8005396:	f7fb f831 	bl	80003fc <__adddf3>
 800539a:	ec41 0b10 	vmov	d0, r0, r1
 800539e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80053a2:	4936      	ldr	r1, [pc, #216]	; (800547c <__ieee754_log10+0x12c>)
 80053a4:	428b      	cmp	r3, r1
 80053a6:	f04f 0200 	mov.w	r2, #0
 80053aa:	dcf0      	bgt.n	800538e <__ieee754_log10+0x3e>
 80053ac:	1518      	asrs	r0, r3, #20
 80053ae:	f2a0 30ff 	subw	r0, r0, #1023	; 0x3ff
 80053b2:	4410      	add	r0, r2
 80053b4:	ea4f 79d0 	mov.w	r9, r0, lsr #31
 80053b8:	4448      	add	r0, r9
 80053ba:	f3c3 0813 	ubfx	r8, r3, #0, #20
 80053be:	f7fb f969 	bl	8000694 <__aeabi_i2d>
 80053c2:	f5c9 737f 	rsb	r3, r9, #1020	; 0x3fc
 80053c6:	3303      	adds	r3, #3
 80053c8:	ea48 5503 	orr.w	r5, r8, r3, lsl #20
 80053cc:	ec45 4b10 	vmov	d0, r4, r5
 80053d0:	4606      	mov	r6, r0
 80053d2:	460f      	mov	r7, r1
 80053d4:	f000 ffe4 	bl	80063a0 <__ieee754_log>
 80053d8:	4630      	mov	r0, r6
 80053da:	4639      	mov	r1, r7
 80053dc:	a320      	add	r3, pc, #128	; (adr r3, 8005460 <__ieee754_log10+0x110>)
 80053de:	e9d3 2300 	ldrd	r2, r3, [r3]
 80053e2:	ec59 8b10 	vmov	r8, r9, d0
 80053e6:	f7fb f9bb 	bl	8000760 <__aeabi_dmul>
 80053ea:	a31f      	add	r3, pc, #124	; (adr r3, 8005468 <__ieee754_log10+0x118>)
 80053ec:	e9d3 2300 	ldrd	r2, r3, [r3]
 80053f0:	4604      	mov	r4, r0
 80053f2:	460d      	mov	r5, r1
 80053f4:	4630      	mov	r0, r6
 80053f6:	4639      	mov	r1, r7
 80053f8:	f7fb f9b2 	bl	8000760 <__aeabi_dmul>
 80053fc:	a31c      	add	r3, pc, #112	; (adr r3, 8005470 <__ieee754_log10+0x120>)
 80053fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005402:	4606      	mov	r6, r0
 8005404:	460f      	mov	r7, r1
 8005406:	4640      	mov	r0, r8
 8005408:	4649      	mov	r1, r9
 800540a:	f7fb f9a9 	bl	8000760 <__aeabi_dmul>
 800540e:	4602      	mov	r2, r0
 8005410:	460b      	mov	r3, r1
 8005412:	4630      	mov	r0, r6
 8005414:	4639      	mov	r1, r7
 8005416:	f7fa fff1 	bl	80003fc <__adddf3>
 800541a:	4602      	mov	r2, r0
 800541c:	460b      	mov	r3, r1
 800541e:	4620      	mov	r0, r4
 8005420:	4629      	mov	r1, r5
 8005422:	f7fa ffeb 	bl	80003fc <__adddf3>
 8005426:	ec41 0b10 	vmov	d0, r0, r1
 800542a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800542e:	2200      	movs	r2, #0
 8005430:	2300      	movs	r3, #0
 8005432:	2000      	movs	r0, #0
 8005434:	4912      	ldr	r1, [pc, #72]	; (8005480 <__ieee754_log10+0x130>)
 8005436:	f7fb fabd 	bl	80009b4 <__aeabi_ddiv>
 800543a:	ec41 0b10 	vmov	d0, r0, r1
 800543e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005442:	4622      	mov	r2, r4
 8005444:	462b      	mov	r3, r5
 8005446:	f7fa ffd7 	bl	80003f8 <__aeabi_dsub>
 800544a:	2200      	movs	r2, #0
 800544c:	2300      	movs	r3, #0
 800544e:	f7fb fab1 	bl	80009b4 <__aeabi_ddiv>
 8005452:	ec41 0b10 	vmov	d0, r0, r1
 8005456:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800545a:	bf00      	nop
 800545c:	f3af 8000 	nop.w
 8005460:	509f6000 	.word	0x509f6000
 8005464:	3fd34413 	.word	0x3fd34413
 8005468:	11f12b36 	.word	0x11f12b36
 800546c:	3d59fef3 	.word	0x3d59fef3
 8005470:	1526e50e 	.word	0x1526e50e
 8005474:	3fdbcb7b 	.word	0x3fdbcb7b
 8005478:	43500000 	.word	0x43500000
 800547c:	7fefffff 	.word	0x7fefffff
 8005480:	c3500000 	.word	0xc3500000
 8005484:	f3af 8000 	nop.w
	...

08005490 <__ieee754_pow>:
 8005490:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005494:	ec55 4b11 	vmov	r4, r5, d1
 8005498:	f025 4700 	bic.w	r7, r5, #2147483648	; 0x80000000
 800549c:	ea57 0104 	orrs.w	r1, r7, r4
 80054a0:	b091      	sub	sp, #68	; 0x44
 80054a2:	462a      	mov	r2, r5
 80054a4:	ee11 3a10 	vmov	r3, s2
 80054a8:	d037      	beq.n	800551a <__ieee754_pow+0x8a>
 80054aa:	ec5b ab10 	vmov	sl, fp, d0
 80054ae:	496a      	ldr	r1, [pc, #424]	; (8005658 <__ieee754_pow+0x1c8>)
 80054b0:	f02b 4600 	bic.w	r6, fp, #2147483648	; 0x80000000
 80054b4:	428e      	cmp	r6, r1
 80054b6:	ee10 ca10 	vmov	ip, s0
 80054ba:	46d9      	mov	r9, fp
 80054bc:	dc26      	bgt.n	800550c <__ieee754_pow+0x7c>
 80054be:	d022      	beq.n	8005506 <__ieee754_pow+0x76>
 80054c0:	428f      	cmp	r7, r1
 80054c2:	dc23      	bgt.n	800550c <__ieee754_pow+0x7c>
 80054c4:	4964      	ldr	r1, [pc, #400]	; (8005658 <__ieee754_pow+0x1c8>)
 80054c6:	428f      	cmp	r7, r1
 80054c8:	d07c      	beq.n	80055c4 <__ieee754_pow+0x134>
 80054ca:	f1b9 0f00 	cmp.w	r9, #0
 80054ce:	db7c      	blt.n	80055ca <__ieee754_pow+0x13a>
 80054d0:	f04f 0800 	mov.w	r8, #0
 80054d4:	bb83      	cbnz	r3, 8005538 <__ieee754_pow+0xa8>
 80054d6:	4b60      	ldr	r3, [pc, #384]	; (8005658 <__ieee754_pow+0x1c8>)
 80054d8:	429f      	cmp	r7, r3
 80054da:	f000 8093 	beq.w	8005604 <__ieee754_pow+0x174>
 80054de:	4b5f      	ldr	r3, [pc, #380]	; (800565c <__ieee754_pow+0x1cc>)
 80054e0:	429f      	cmp	r7, r3
 80054e2:	d069      	beq.n	80055b8 <__ieee754_pow+0x128>
 80054e4:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 80054e8:	f000 83f0 	beq.w	8005ccc <__ieee754_pow+0x83c>
 80054ec:	4b5c      	ldr	r3, [pc, #368]	; (8005660 <__ieee754_pow+0x1d0>)
 80054ee:	429a      	cmp	r2, r3
 80054f0:	d122      	bne.n	8005538 <__ieee754_pow+0xa8>
 80054f2:	f1b9 0f00 	cmp.w	r9, #0
 80054f6:	db1f      	blt.n	8005538 <__ieee754_pow+0xa8>
 80054f8:	ec4b ab10 	vmov	d0, sl, fp
 80054fc:	b011      	add	sp, #68	; 0x44
 80054fe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005502:	f000 bd35 	b.w	8005f70 <__ieee754_sqrt>
 8005506:	f1ba 0f00 	cmp.w	sl, #0
 800550a:	d00b      	beq.n	8005524 <__ieee754_pow+0x94>
 800550c:	f106 4640 	add.w	r6, r6, #3221225472	; 0xc0000000
 8005510:	f506 1680 	add.w	r6, r6, #1048576	; 0x100000
 8005514:	ea56 030c 	orrs.w	r3, r6, ip
 8005518:	d106      	bne.n	8005528 <__ieee754_pow+0x98>
 800551a:	ed9f 0b4b 	vldr	d0, [pc, #300]	; 8005648 <__ieee754_pow+0x1b8>
 800551e:	b011      	add	sp, #68	; 0x44
 8005520:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005524:	42b7      	cmp	r7, r6
 8005526:	ddcd      	ble.n	80054c4 <__ieee754_pow+0x34>
 8005528:	484e      	ldr	r0, [pc, #312]	; (8005664 <__ieee754_pow+0x1d4>)
 800552a:	b011      	add	sp, #68	; 0x44
 800552c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005530:	f000 be0e 	b.w	8006150 <nan>
 8005534:	f04f 0800 	mov.w	r8, #0
 8005538:	ec4b ab10 	vmov	d0, sl, fp
 800553c:	f8cd c008 	str.w	ip, [sp, #8]
 8005540:	9200      	str	r2, [sp, #0]
 8005542:	f000 fded 	bl	8006120 <fabs>
 8005546:	f8dd c008 	ldr.w	ip, [sp, #8]
 800554a:	9a00      	ldr	r2, [sp, #0]
 800554c:	ec51 0b10 	vmov	r0, r1, d0
 8005550:	f1bc 0f00 	cmp.w	ip, #0
 8005554:	d020      	beq.n	8005598 <__ieee754_pow+0x108>
 8005556:	ea4f 79d9 	mov.w	r9, r9, lsr #31
 800555a:	f109 39ff 	add.w	r9, r9, #4294967295
 800555e:	ea58 0309 	orrs.w	r3, r8, r9
 8005562:	d063      	beq.n	800562c <__ieee754_pow+0x19c>
 8005564:	4b40      	ldr	r3, [pc, #256]	; (8005668 <__ieee754_pow+0x1d8>)
 8005566:	429f      	cmp	r7, r3
 8005568:	f340 8084 	ble.w	8005674 <__ieee754_pow+0x1e4>
 800556c:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
 8005570:	429f      	cmp	r7, r3
 8005572:	f340 842f 	ble.w	8005dd4 <__ieee754_pow+0x944>
 8005576:	4b3d      	ldr	r3, [pc, #244]	; (800566c <__ieee754_pow+0x1dc>)
 8005578:	429e      	cmp	r6, r3
 800557a:	f340 838f 	ble.w	8005c9c <__ieee754_pow+0x80c>
 800557e:	2a00      	cmp	r2, #0
 8005580:	f340 838f 	ble.w	8005ca2 <__ieee754_pow+0x812>
 8005584:	a132      	add	r1, pc, #200	; (adr r1, 8005650 <__ieee754_pow+0x1c0>)
 8005586:	e9d1 0100 	ldrd	r0, r1, [r1]
 800558a:	4602      	mov	r2, r0
 800558c:	460b      	mov	r3, r1
 800558e:	f7fb f8e7 	bl	8000760 <__aeabi_dmul>
 8005592:	ec41 0b10 	vmov	d0, r0, r1
 8005596:	e7c2      	b.n	800551e <__ieee754_pow+0x8e>
 8005598:	b126      	cbz	r6, 80055a4 <__ieee754_pow+0x114>
 800559a:	4b30      	ldr	r3, [pc, #192]	; (800565c <__ieee754_pow+0x1cc>)
 800559c:	f029 4e40 	bic.w	lr, r9, #3221225472	; 0xc0000000
 80055a0:	459e      	cmp	lr, r3
 80055a2:	d1d8      	bne.n	8005556 <__ieee754_pow+0xc6>
 80055a4:	2a00      	cmp	r2, #0
 80055a6:	f2c0 83d0 	blt.w	8005d4a <__ieee754_pow+0x8ba>
 80055aa:	f1b9 0f00 	cmp.w	r9, #0
 80055ae:	f2c0 837b 	blt.w	8005ca8 <__ieee754_pow+0x818>
 80055b2:	ec41 0b10 	vmov	d0, r0, r1
 80055b6:	e7b2      	b.n	800551e <__ieee754_pow+0x8e>
 80055b8:	2a00      	cmp	r2, #0
 80055ba:	f2c0 8477 	blt.w	8005eac <__ieee754_pow+0xa1c>
 80055be:	ec4b ab10 	vmov	d0, sl, fp
 80055c2:	e7ac      	b.n	800551e <__ieee754_pow+0x8e>
 80055c4:	2b00      	cmp	r3, #0
 80055c6:	d080      	beq.n	80054ca <__ieee754_pow+0x3a>
 80055c8:	e7a0      	b.n	800550c <__ieee754_pow+0x7c>
 80055ca:	4929      	ldr	r1, [pc, #164]	; (8005670 <__ieee754_pow+0x1e0>)
 80055cc:	428f      	cmp	r7, r1
 80055ce:	dc2a      	bgt.n	8005626 <__ieee754_pow+0x196>
 80055d0:	f1a1 7154 	sub.w	r1, r1, #55574528	; 0x3500000
 80055d4:	428f      	cmp	r7, r1
 80055d6:	f77f af7b 	ble.w	80054d0 <__ieee754_pow+0x40>
 80055da:	1539      	asrs	r1, r7, #20
 80055dc:	f240 4013 	movw	r0, #1043	; 0x413
 80055e0:	4281      	cmp	r1, r0
 80055e2:	f340 847d 	ble.w	8005ee0 <__ieee754_pow+0xa50>
 80055e6:	f5c1 6186 	rsb	r1, r1, #1072	; 0x430
 80055ea:	3103      	adds	r1, #3
 80055ec:	fa23 f001 	lsr.w	r0, r3, r1
 80055f0:	fa00 f101 	lsl.w	r1, r0, r1
 80055f4:	4299      	cmp	r1, r3
 80055f6:	f47f af6b 	bne.w	80054d0 <__ieee754_pow+0x40>
 80055fa:	f000 0001 	and.w	r0, r0, #1
 80055fe:	f1c0 0802 	rsb	r8, r0, #2
 8005602:	e767      	b.n	80054d4 <__ieee754_pow+0x44>
 8005604:	f106 4340 	add.w	r3, r6, #3221225472	; 0xc0000000
 8005608:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
 800560c:	ea53 030c 	orrs.w	r3, r3, ip
 8005610:	d083      	beq.n	800551a <__ieee754_pow+0x8a>
 8005612:	4b16      	ldr	r3, [pc, #88]	; (800566c <__ieee754_pow+0x1dc>)
 8005614:	429e      	cmp	r6, r3
 8005616:	f340 838e 	ble.w	8005d36 <__ieee754_pow+0x8a6>
 800561a:	2a00      	cmp	r2, #0
 800561c:	f2c0 8341 	blt.w	8005ca2 <__ieee754_pow+0x812>
 8005620:	ec45 4b10 	vmov	d0, r4, r5
 8005624:	e77b      	b.n	800551e <__ieee754_pow+0x8e>
 8005626:	f04f 0802 	mov.w	r8, #2
 800562a:	e753      	b.n	80054d4 <__ieee754_pow+0x44>
 800562c:	4650      	mov	r0, sl
 800562e:	4659      	mov	r1, fp
 8005630:	4602      	mov	r2, r0
 8005632:	460b      	mov	r3, r1
 8005634:	f7fa fee0 	bl	80003f8 <__aeabi_dsub>
 8005638:	4602      	mov	r2, r0
 800563a:	460b      	mov	r3, r1
 800563c:	f7fb f9ba 	bl	80009b4 <__aeabi_ddiv>
 8005640:	e7b7      	b.n	80055b2 <__ieee754_pow+0x122>
 8005642:	bf00      	nop
 8005644:	f3af 8000 	nop.w
 8005648:	00000000 	.word	0x00000000
 800564c:	3ff00000 	.word	0x3ff00000
 8005650:	8800759c 	.word	0x8800759c
 8005654:	7e37e43c 	.word	0x7e37e43c
 8005658:	7ff00000 	.word	0x7ff00000
 800565c:	3ff00000 	.word	0x3ff00000
 8005660:	3fe00000 	.word	0x3fe00000
 8005664:	08006cf4 	.word	0x08006cf4
 8005668:	41e00000 	.word	0x41e00000
 800566c:	3fefffff 	.word	0x3fefffff
 8005670:	433fffff 	.word	0x433fffff
 8005674:	f5b6 1f80 	cmp.w	r6, #1048576	; 0x100000
 8005678:	f280 8415 	bge.w	8005ea6 <__ieee754_pow+0xa16>
 800567c:	2200      	movs	r2, #0
 800567e:	4bce      	ldr	r3, [pc, #824]	; (80059b8 <__ieee754_pow+0x528>)
 8005680:	f7fb f86e 	bl	8000760 <__aeabi_dmul>
 8005684:	f06f 0734 	mvn.w	r7, #52	; 0x34
 8005688:	460e      	mov	r6, r1
 800568a:	1533      	asrs	r3, r6, #20
 800568c:	f8df e344 	ldr.w	lr, [pc, #836]	; 80059d4 <__ieee754_pow+0x544>
 8005690:	f3c6 0213 	ubfx	r2, r6, #0, #20
 8005694:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
 8005698:	f042 567f 	orr.w	r6, r2, #1069547520	; 0x3fc00000
 800569c:	443b      	add	r3, r7
 800569e:	4572      	cmp	r2, lr
 80056a0:	930e      	str	r3, [sp, #56]	; 0x38
 80056a2:	f446 1640 	orr.w	r6, r6, #3145728	; 0x300000
 80056a6:	f340 83fb 	ble.w	8005ea0 <__ieee754_pow+0xa10>
 80056aa:	4bc4      	ldr	r3, [pc, #784]	; (80059bc <__ieee754_pow+0x52c>)
 80056ac:	429a      	cmp	r2, r3
 80056ae:	f340 842f 	ble.w	8005f10 <__ieee754_pow+0xa80>
 80056b2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80056b4:	2700      	movs	r7, #0
 80056b6:	3301      	adds	r3, #1
 80056b8:	930e      	str	r3, [sp, #56]	; 0x38
 80056ba:	f5a6 1680 	sub.w	r6, r6, #1048576	; 0x100000
 80056be:	46bc      	mov	ip, r7
 80056c0:	4bbf      	ldr	r3, [pc, #764]	; (80059c0 <__ieee754_pow+0x530>)
 80056c2:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 80056c6:	4463      	add	r3, ip
 80056c8:	ed93 7b00 	vldr	d7, [r3]
 80056cc:	4631      	mov	r1, r6
 80056ce:	ec53 2b17 	vmov	r2, r3, d7
 80056d2:	f8cd c03c 	str.w	ip, [sp, #60]	; 0x3c
 80056d6:	ed8d 7b06 	vstr	d7, [sp, #24]
 80056da:	4682      	mov	sl, r0
 80056dc:	f7fa fe8c 	bl	80003f8 <__aeabi_dsub>
 80056e0:	46b3      	mov	fp, r6
 80056e2:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80056e6:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80056ea:	4650      	mov	r0, sl
 80056ec:	4631      	mov	r1, r6
 80056ee:	e9cd ab0a 	strd	sl, fp, [sp, #40]	; 0x28
 80056f2:	f7fa fe83 	bl	80003fc <__adddf3>
 80056f6:	4602      	mov	r2, r0
 80056f8:	460b      	mov	r3, r1
 80056fa:	2000      	movs	r0, #0
 80056fc:	49b1      	ldr	r1, [pc, #708]	; (80059c4 <__ieee754_pow+0x534>)
 80056fe:	f7fb f959 	bl	80009b4 <__aeabi_ddiv>
 8005702:	4602      	mov	r2, r0
 8005704:	460b      	mov	r3, r1
 8005706:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 800570a:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 800570e:	f7fb f827 	bl	8000760 <__aeabi_dmul>
 8005712:	1073      	asrs	r3, r6, #1
 8005714:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8005718:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
 800571c:	4682      	mov	sl, r0
 800571e:	468b      	mov	fp, r1
 8005720:	19d9      	adds	r1, r3, r7
 8005722:	2300      	movs	r3, #0
 8005724:	e9cd ab02 	strd	sl, fp, [sp, #8]
 8005728:	9302      	str	r3, [sp, #8]
 800572a:	ed9d 7b02 	vldr	d7, [sp, #8]
 800572e:	2000      	movs	r0, #0
 8005730:	4606      	mov	r6, r0
 8005732:	460f      	mov	r7, r1
 8005734:	4602      	mov	r2, r0
 8005736:	460b      	mov	r3, r1
 8005738:	ec51 0b17 	vmov	r0, r1, d7
 800573c:	ed8d 7b00 	vstr	d7, [sp]
 8005740:	e9cd ab04 	strd	sl, fp, [sp, #16]
 8005744:	f7fb f80c 	bl	8000760 <__aeabi_dmul>
 8005748:	4602      	mov	r2, r0
 800574a:	460b      	mov	r3, r1
 800574c:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8005750:	f7fa fe52 	bl	80003f8 <__aeabi_dsub>
 8005754:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8005758:	4682      	mov	sl, r0
 800575a:	468b      	mov	fp, r1
 800575c:	4630      	mov	r0, r6
 800575e:	4639      	mov	r1, r7
 8005760:	f7fa fe4a 	bl	80003f8 <__aeabi_dsub>
 8005764:	4602      	mov	r2, r0
 8005766:	460b      	mov	r3, r1
 8005768:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 800576c:	f7fa fe44 	bl	80003f8 <__aeabi_dsub>
 8005770:	4602      	mov	r2, r0
 8005772:	460b      	mov	r3, r1
 8005774:	e9dd 0100 	ldrd	r0, r1, [sp]
 8005778:	f7fa fff2 	bl	8000760 <__aeabi_dmul>
 800577c:	4602      	mov	r2, r0
 800577e:	460b      	mov	r3, r1
 8005780:	4650      	mov	r0, sl
 8005782:	4659      	mov	r1, fp
 8005784:	f7fa fe38 	bl	80003f8 <__aeabi_dsub>
 8005788:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 800578c:	f7fa ffe8 	bl	8000760 <__aeabi_dmul>
 8005790:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8005794:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8005798:	4610      	mov	r0, r2
 800579a:	4619      	mov	r1, r3
 800579c:	f7fa ffe0 	bl	8000760 <__aeabi_dmul>
 80057a0:	4602      	mov	r2, r0
 80057a2:	460b      	mov	r3, r1
 80057a4:	4606      	mov	r6, r0
 80057a6:	460f      	mov	r7, r1
 80057a8:	f7fa ffda 	bl	8000760 <__aeabi_dmul>
 80057ac:	a370      	add	r3, pc, #448	; (adr r3, 8005970 <__ieee754_pow+0x4e0>)
 80057ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 80057b2:	4682      	mov	sl, r0
 80057b4:	468b      	mov	fp, r1
 80057b6:	4630      	mov	r0, r6
 80057b8:	4639      	mov	r1, r7
 80057ba:	f7fa ffd1 	bl	8000760 <__aeabi_dmul>
 80057be:	a36e      	add	r3, pc, #440	; (adr r3, 8005978 <__ieee754_pow+0x4e8>)
 80057c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80057c4:	f7fa fe1a 	bl	80003fc <__adddf3>
 80057c8:	4632      	mov	r2, r6
 80057ca:	463b      	mov	r3, r7
 80057cc:	f7fa ffc8 	bl	8000760 <__aeabi_dmul>
 80057d0:	a36b      	add	r3, pc, #428	; (adr r3, 8005980 <__ieee754_pow+0x4f0>)
 80057d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80057d6:	f7fa fe11 	bl	80003fc <__adddf3>
 80057da:	4632      	mov	r2, r6
 80057dc:	463b      	mov	r3, r7
 80057de:	f7fa ffbf 	bl	8000760 <__aeabi_dmul>
 80057e2:	a369      	add	r3, pc, #420	; (adr r3, 8005988 <__ieee754_pow+0x4f8>)
 80057e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80057e8:	f7fa fe08 	bl	80003fc <__adddf3>
 80057ec:	4632      	mov	r2, r6
 80057ee:	463b      	mov	r3, r7
 80057f0:	f7fa ffb6 	bl	8000760 <__aeabi_dmul>
 80057f4:	a366      	add	r3, pc, #408	; (adr r3, 8005990 <__ieee754_pow+0x500>)
 80057f6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80057fa:	f7fa fdff 	bl	80003fc <__adddf3>
 80057fe:	4632      	mov	r2, r6
 8005800:	463b      	mov	r3, r7
 8005802:	f7fa ffad 	bl	8000760 <__aeabi_dmul>
 8005806:	a364      	add	r3, pc, #400	; (adr r3, 8005998 <__ieee754_pow+0x508>)
 8005808:	e9d3 2300 	ldrd	r2, r3, [r3]
 800580c:	f7fa fdf6 	bl	80003fc <__adddf3>
 8005810:	4602      	mov	r2, r0
 8005812:	460b      	mov	r3, r1
 8005814:	4650      	mov	r0, sl
 8005816:	4659      	mov	r1, fp
 8005818:	f7fa ffa2 	bl	8000760 <__aeabi_dmul>
 800581c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8005820:	4606      	mov	r6, r0
 8005822:	460f      	mov	r7, r1
 8005824:	e9dd 0100 	ldrd	r0, r1, [sp]
 8005828:	f7fa fde8 	bl	80003fc <__adddf3>
 800582c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8005830:	f7fa ff96 	bl	8000760 <__aeabi_dmul>
 8005834:	4632      	mov	r2, r6
 8005836:	463b      	mov	r3, r7
 8005838:	f7fa fde0 	bl	80003fc <__adddf3>
 800583c:	e9dd 6700 	ldrd	r6, r7, [sp]
 8005840:	4682      	mov	sl, r0
 8005842:	468b      	mov	fp, r1
 8005844:	4632      	mov	r2, r6
 8005846:	463b      	mov	r3, r7
 8005848:	4630      	mov	r0, r6
 800584a:	4639      	mov	r1, r7
 800584c:	f7fa ff88 	bl	8000760 <__aeabi_dmul>
 8005850:	2200      	movs	r2, #0
 8005852:	4b5d      	ldr	r3, [pc, #372]	; (80059c8 <__ieee754_pow+0x538>)
 8005854:	e9cd 0108 	strd	r0, r1, [sp, #32]
 8005858:	f7fa fdd0 	bl	80003fc <__adddf3>
 800585c:	4652      	mov	r2, sl
 800585e:	465b      	mov	r3, fp
 8005860:	f7fa fdcc 	bl	80003fc <__adddf3>
 8005864:	9802      	ldr	r0, [sp, #8]
 8005866:	460f      	mov	r7, r1
 8005868:	4606      	mov	r6, r0
 800586a:	4632      	mov	r2, r6
 800586c:	e9dd 0100 	ldrd	r0, r1, [sp]
 8005870:	463b      	mov	r3, r7
 8005872:	f7fa ff75 	bl	8000760 <__aeabi_dmul>
 8005876:	4632      	mov	r2, r6
 8005878:	463b      	mov	r3, r7
 800587a:	e9cd 0100 	strd	r0, r1, [sp]
 800587e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8005882:	f7fa ff6d 	bl	8000760 <__aeabi_dmul>
 8005886:	2200      	movs	r2, #0
 8005888:	e9cd 0106 	strd	r0, r1, [sp, #24]
 800588c:	4b4e      	ldr	r3, [pc, #312]	; (80059c8 <__ieee754_pow+0x538>)
 800588e:	4630      	mov	r0, r6
 8005890:	4639      	mov	r1, r7
 8005892:	f7fa fdb1 	bl	80003f8 <__aeabi_dsub>
 8005896:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 800589a:	f7fa fdad 	bl	80003f8 <__aeabi_dsub>
 800589e:	4602      	mov	r2, r0
 80058a0:	460b      	mov	r3, r1
 80058a2:	4650      	mov	r0, sl
 80058a4:	4659      	mov	r1, fp
 80058a6:	f7fa fda7 	bl	80003f8 <__aeabi_dsub>
 80058aa:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80058ae:	f7fa ff57 	bl	8000760 <__aeabi_dmul>
 80058b2:	4602      	mov	r2, r0
 80058b4:	460b      	mov	r3, r1
 80058b6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80058ba:	f7fa fd9f 	bl	80003fc <__adddf3>
 80058be:	4682      	mov	sl, r0
 80058c0:	468b      	mov	fp, r1
 80058c2:	4652      	mov	r2, sl
 80058c4:	465b      	mov	r3, fp
 80058c6:	e9dd 0100 	ldrd	r0, r1, [sp]
 80058ca:	f7fa fd97 	bl	80003fc <__adddf3>
 80058ce:	9802      	ldr	r0, [sp, #8]
 80058d0:	a333      	add	r3, pc, #204	; (adr r3, 80059a0 <__ieee754_pow+0x510>)
 80058d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80058d6:	4606      	mov	r6, r0
 80058d8:	460f      	mov	r7, r1
 80058da:	f7fa ff41 	bl	8000760 <__aeabi_dmul>
 80058de:	a332      	add	r3, pc, #200	; (adr r3, 80059a8 <__ieee754_pow+0x518>)
 80058e0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80058e4:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80058e8:	4630      	mov	r0, r6
 80058ea:	4639      	mov	r1, r7
 80058ec:	f7fa ff38 	bl	8000760 <__aeabi_dmul>
 80058f0:	e9dd 2300 	ldrd	r2, r3, [sp]
 80058f4:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80058f8:	4630      	mov	r0, r6
 80058fa:	4639      	mov	r1, r7
 80058fc:	f7fa fd7c 	bl	80003f8 <__aeabi_dsub>
 8005900:	4602      	mov	r2, r0
 8005902:	460b      	mov	r3, r1
 8005904:	4650      	mov	r0, sl
 8005906:	4659      	mov	r1, fp
 8005908:	f7fa fd76 	bl	80003f8 <__aeabi_dsub>
 800590c:	a328      	add	r3, pc, #160	; (adr r3, 80059b0 <__ieee754_pow+0x520>)
 800590e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005912:	f7fa ff25 	bl	8000760 <__aeabi_dmul>
 8005916:	4602      	mov	r2, r0
 8005918:	460b      	mov	r3, r1
 800591a:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800591e:	f7fa fd6d 	bl	80003fc <__adddf3>
 8005922:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
 8005926:	4b29      	ldr	r3, [pc, #164]	; (80059cc <__ieee754_pow+0x53c>)
 8005928:	f8cd c000 	str.w	ip, [sp]
 800592c:	4463      	add	r3, ip
 800592e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005932:	f7fa fd63 	bl	80003fc <__adddf3>
 8005936:	4682      	mov	sl, r0
 8005938:	980e      	ldr	r0, [sp, #56]	; 0x38
 800593a:	468b      	mov	fp, r1
 800593c:	f7fa feaa 	bl	8000694 <__aeabi_i2d>
 8005940:	4b23      	ldr	r3, [pc, #140]	; (80059d0 <__ieee754_pow+0x540>)
 8005942:	f8dd c000 	ldr.w	ip, [sp]
 8005946:	449c      	add	ip, r3
 8005948:	ed9c 7b00 	vldr	d7, [ip]
 800594c:	4606      	mov	r6, r0
 800594e:	460f      	mov	r7, r1
 8005950:	4652      	mov	r2, sl
 8005952:	465b      	mov	r3, fp
 8005954:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8005958:	ed8d 7b00 	vstr	d7, [sp]
 800595c:	e9cd ab06 	strd	sl, fp, [sp, #24]
 8005960:	f7fa fd4c 	bl	80003fc <__adddf3>
 8005964:	e9dd 2300 	ldrd	r2, r3, [sp]
 8005968:	f7fa fd48 	bl	80003fc <__adddf3>
 800596c:	4632      	mov	r2, r6
 800596e:	e033      	b.n	80059d8 <__ieee754_pow+0x548>
 8005970:	4a454eef 	.word	0x4a454eef
 8005974:	3fca7e28 	.word	0x3fca7e28
 8005978:	93c9db65 	.word	0x93c9db65
 800597c:	3fcd864a 	.word	0x3fcd864a
 8005980:	a91d4101 	.word	0xa91d4101
 8005984:	3fd17460 	.word	0x3fd17460
 8005988:	518f264d 	.word	0x518f264d
 800598c:	3fd55555 	.word	0x3fd55555
 8005990:	db6fabff 	.word	0xdb6fabff
 8005994:	3fdb6db6 	.word	0x3fdb6db6
 8005998:	33333303 	.word	0x33333303
 800599c:	3fe33333 	.word	0x3fe33333
 80059a0:	e0000000 	.word	0xe0000000
 80059a4:	3feec709 	.word	0x3feec709
 80059a8:	145b01f5 	.word	0x145b01f5
 80059ac:	be3e2fe0 	.word	0xbe3e2fe0
 80059b0:	dc3a03fd 	.word	0xdc3a03fd
 80059b4:	3feec709 	.word	0x3feec709
 80059b8:	43400000 	.word	0x43400000
 80059bc:	000bb679 	.word	0x000bb679
 80059c0:	08006f10 	.word	0x08006f10
 80059c4:	3ff00000 	.word	0x3ff00000
 80059c8:	40080000 	.word	0x40080000
 80059cc:	08006f00 	.word	0x08006f00
 80059d0:	08006ef0 	.word	0x08006ef0
 80059d4:	0003988e 	.word	0x0003988e
 80059d8:	463b      	mov	r3, r7
 80059da:	f7fa fd0f 	bl	80003fc <__adddf3>
 80059de:	9802      	ldr	r0, [sp, #8]
 80059e0:	4632      	mov	r2, r6
 80059e2:	463b      	mov	r3, r7
 80059e4:	4682      	mov	sl, r0
 80059e6:	468b      	mov	fp, r1
 80059e8:	f7fa fd06 	bl	80003f8 <__aeabi_dsub>
 80059ec:	e9dd 2300 	ldrd	r2, r3, [sp]
 80059f0:	f7fa fd02 	bl	80003f8 <__aeabi_dsub>
 80059f4:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80059f8:	f7fa fcfe 	bl	80003f8 <__aeabi_dsub>
 80059fc:	4602      	mov	r2, r0
 80059fe:	460b      	mov	r3, r1
 8005a00:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8005a04:	f7fa fcf8 	bl	80003f8 <__aeabi_dsub>
 8005a08:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005a0c:	f108 38ff 	add.w	r8, r8, #4294967295
 8005a10:	ea58 0309 	orrs.w	r3, r8, r9
 8005a14:	f040 818a 	bne.w	8005d2c <__ieee754_pow+0x89c>
 8005a18:	ed9f 7bcf 	vldr	d7, [pc, #828]	; 8005d58 <__ieee754_pow+0x8c8>
 8005a1c:	ed8d 7b04 	vstr	d7, [sp, #16]
 8005a20:	2300      	movs	r3, #0
 8005a22:	e9cd 4500 	strd	r4, r5, [sp]
 8005a26:	9300      	str	r3, [sp, #0]
 8005a28:	e9dd 6700 	ldrd	r6, r7, [sp]
 8005a2c:	4620      	mov	r0, r4
 8005a2e:	4632      	mov	r2, r6
 8005a30:	463b      	mov	r3, r7
 8005a32:	4629      	mov	r1, r5
 8005a34:	f7fa fce0 	bl	80003f8 <__aeabi_dsub>
 8005a38:	4652      	mov	r2, sl
 8005a3a:	465b      	mov	r3, fp
 8005a3c:	f7fa fe90 	bl	8000760 <__aeabi_dmul>
 8005a40:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8005a44:	4680      	mov	r8, r0
 8005a46:	4689      	mov	r9, r1
 8005a48:	4620      	mov	r0, r4
 8005a4a:	4629      	mov	r1, r5
 8005a4c:	f7fa fe88 	bl	8000760 <__aeabi_dmul>
 8005a50:	4602      	mov	r2, r0
 8005a52:	460b      	mov	r3, r1
 8005a54:	4640      	mov	r0, r8
 8005a56:	4649      	mov	r1, r9
 8005a58:	f7fa fcd0 	bl	80003fc <__adddf3>
 8005a5c:	4652      	mov	r2, sl
 8005a5e:	4604      	mov	r4, r0
 8005a60:	460d      	mov	r5, r1
 8005a62:	4630      	mov	r0, r6
 8005a64:	4639      	mov	r1, r7
 8005a66:	465b      	mov	r3, fp
 8005a68:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8005a6c:	f7fa fe78 	bl	8000760 <__aeabi_dmul>
 8005a70:	4606      	mov	r6, r0
 8005a72:	460f      	mov	r7, r1
 8005a74:	4620      	mov	r0, r4
 8005a76:	4629      	mov	r1, r5
 8005a78:	463b      	mov	r3, r7
 8005a7a:	4632      	mov	r2, r6
 8005a7c:	f7fa fcbe 	bl	80003fc <__adddf3>
 8005a80:	4bcf      	ldr	r3, [pc, #828]	; (8005dc0 <__ieee754_pow+0x930>)
 8005a82:	4299      	cmp	r1, r3
 8005a84:	4604      	mov	r4, r0
 8005a86:	460d      	mov	r5, r1
 8005a88:	468a      	mov	sl, r1
 8005a8a:	f340 8128 	ble.w	8005cde <__ieee754_pow+0x84e>
 8005a8e:	f101 433f 	add.w	r3, r1, #3204448256	; 0xbf000000
 8005a92:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
 8005a96:	4303      	orrs	r3, r0
 8005a98:	f040 8212 	bne.w	8005ec0 <__ieee754_pow+0xa30>
 8005a9c:	a3b0      	add	r3, pc, #704	; (adr r3, 8005d60 <__ieee754_pow+0x8d0>)
 8005a9e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005aa2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005aa6:	f7fa fca9 	bl	80003fc <__adddf3>
 8005aaa:	4632      	mov	r2, r6
 8005aac:	4680      	mov	r8, r0
 8005aae:	4689      	mov	r9, r1
 8005ab0:	463b      	mov	r3, r7
 8005ab2:	4620      	mov	r0, r4
 8005ab4:	4629      	mov	r1, r5
 8005ab6:	f7fa fc9f 	bl	80003f8 <__aeabi_dsub>
 8005aba:	4602      	mov	r2, r0
 8005abc:	460b      	mov	r3, r1
 8005abe:	4640      	mov	r0, r8
 8005ac0:	4649      	mov	r1, r9
 8005ac2:	f7fb f8e3 	bl	8000c8c <__aeabi_dcmpgt>
 8005ac6:	2800      	cmp	r0, #0
 8005ac8:	f040 81fa 	bne.w	8005ec0 <__ieee754_pow+0xa30>
 8005acc:	46a8      	mov	r8, r5
 8005ace:	ea4f 5228 	mov.w	r2, r8, asr #20
 8005ad2:	f2a2 32fe 	subw	r2, r2, #1022	; 0x3fe
 8005ad6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8005ada:	4113      	asrs	r3, r2
 8005adc:	4453      	add	r3, sl
 8005ade:	f3c3 540a 	ubfx	r4, r3, #20, #11
 8005ae2:	4ab8      	ldr	r2, [pc, #736]	; (8005dc4 <__ieee754_pow+0x934>)
 8005ae4:	f2a4 31ff 	subw	r1, r4, #1023	; 0x3ff
 8005ae8:	410a      	asrs	r2, r1
 8005aea:	ea23 0102 	bic.w	r1, r3, r2
 8005aee:	2000      	movs	r0, #0
 8005af0:	4602      	mov	r2, r0
 8005af2:	f3c3 0b13 	ubfx	fp, r3, #0, #20
 8005af6:	4630      	mov	r0, r6
 8005af8:	460b      	mov	r3, r1
 8005afa:	4639      	mov	r1, r7
 8005afc:	f7fa fc7c 	bl	80003f8 <__aeabi_dsub>
 8005b00:	f5c4 6482 	rsb	r4, r4, #1040	; 0x410
 8005b04:	3403      	adds	r4, #3
 8005b06:	f44b 1b80 	orr.w	fp, fp, #1048576	; 0x100000
 8005b0a:	fa4b fb04 	asr.w	fp, fp, r4
 8005b0e:	ea8b 7bea 	eor.w	fp, fp, sl, asr #31
 8005b12:	4606      	mov	r6, r0
 8005b14:	460f      	mov	r7, r1
 8005b16:	eb0b 7bda 	add.w	fp, fp, sl, lsr #31
 8005b1a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005b1e:	4632      	mov	r2, r6
 8005b20:	463b      	mov	r3, r7
 8005b22:	ea4f 5a0b 	mov.w	sl, fp, lsl #20
 8005b26:	f7fa fc69 	bl	80003fc <__adddf3>
 8005b2a:	2400      	movs	r4, #0
 8005b2c:	a38e      	add	r3, pc, #568	; (adr r3, 8005d68 <__ieee754_pow+0x8d8>)
 8005b2e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005b32:	4620      	mov	r0, r4
 8005b34:	460d      	mov	r5, r1
 8005b36:	f7fa fe13 	bl	8000760 <__aeabi_dmul>
 8005b3a:	4632      	mov	r2, r6
 8005b3c:	4680      	mov	r8, r0
 8005b3e:	4689      	mov	r9, r1
 8005b40:	463b      	mov	r3, r7
 8005b42:	4620      	mov	r0, r4
 8005b44:	4629      	mov	r1, r5
 8005b46:	f7fa fc57 	bl	80003f8 <__aeabi_dsub>
 8005b4a:	4602      	mov	r2, r0
 8005b4c:	460b      	mov	r3, r1
 8005b4e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005b52:	f7fa fc51 	bl	80003f8 <__aeabi_dsub>
 8005b56:	a386      	add	r3, pc, #536	; (adr r3, 8005d70 <__ieee754_pow+0x8e0>)
 8005b58:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005b5c:	f7fa fe00 	bl	8000760 <__aeabi_dmul>
 8005b60:	a385      	add	r3, pc, #532	; (adr r3, 8005d78 <__ieee754_pow+0x8e8>)
 8005b62:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005b66:	4606      	mov	r6, r0
 8005b68:	460f      	mov	r7, r1
 8005b6a:	4620      	mov	r0, r4
 8005b6c:	4629      	mov	r1, r5
 8005b6e:	f7fa fdf7 	bl	8000760 <__aeabi_dmul>
 8005b72:	4602      	mov	r2, r0
 8005b74:	460b      	mov	r3, r1
 8005b76:	4630      	mov	r0, r6
 8005b78:	4639      	mov	r1, r7
 8005b7a:	f7fa fc3f 	bl	80003fc <__adddf3>
 8005b7e:	4606      	mov	r6, r0
 8005b80:	460f      	mov	r7, r1
 8005b82:	4632      	mov	r2, r6
 8005b84:	463b      	mov	r3, r7
 8005b86:	4640      	mov	r0, r8
 8005b88:	4649      	mov	r1, r9
 8005b8a:	f7fa fc37 	bl	80003fc <__adddf3>
 8005b8e:	4642      	mov	r2, r8
 8005b90:	464b      	mov	r3, r9
 8005b92:	4604      	mov	r4, r0
 8005b94:	460d      	mov	r5, r1
 8005b96:	f7fa fc2f 	bl	80003f8 <__aeabi_dsub>
 8005b9a:	4602      	mov	r2, r0
 8005b9c:	460b      	mov	r3, r1
 8005b9e:	4630      	mov	r0, r6
 8005ba0:	4639      	mov	r1, r7
 8005ba2:	f7fa fc29 	bl	80003f8 <__aeabi_dsub>
 8005ba6:	4622      	mov	r2, r4
 8005ba8:	4680      	mov	r8, r0
 8005baa:	4689      	mov	r9, r1
 8005bac:	462b      	mov	r3, r5
 8005bae:	4620      	mov	r0, r4
 8005bb0:	4629      	mov	r1, r5
 8005bb2:	f7fa fdd5 	bl	8000760 <__aeabi_dmul>
 8005bb6:	a372      	add	r3, pc, #456	; (adr r3, 8005d80 <__ieee754_pow+0x8f0>)
 8005bb8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005bbc:	4606      	mov	r6, r0
 8005bbe:	460f      	mov	r7, r1
 8005bc0:	f7fa fdce 	bl	8000760 <__aeabi_dmul>
 8005bc4:	a370      	add	r3, pc, #448	; (adr r3, 8005d88 <__ieee754_pow+0x8f8>)
 8005bc6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005bca:	f7fa fc15 	bl	80003f8 <__aeabi_dsub>
 8005bce:	4632      	mov	r2, r6
 8005bd0:	463b      	mov	r3, r7
 8005bd2:	f7fa fdc5 	bl	8000760 <__aeabi_dmul>
 8005bd6:	a36e      	add	r3, pc, #440	; (adr r3, 8005d90 <__ieee754_pow+0x900>)
 8005bd8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005bdc:	f7fa fc0e 	bl	80003fc <__adddf3>
 8005be0:	4632      	mov	r2, r6
 8005be2:	463b      	mov	r3, r7
 8005be4:	f7fa fdbc 	bl	8000760 <__aeabi_dmul>
 8005be8:	a36b      	add	r3, pc, #428	; (adr r3, 8005d98 <__ieee754_pow+0x908>)
 8005bea:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005bee:	f7fa fc03 	bl	80003f8 <__aeabi_dsub>
 8005bf2:	4632      	mov	r2, r6
 8005bf4:	463b      	mov	r3, r7
 8005bf6:	f7fa fdb3 	bl	8000760 <__aeabi_dmul>
 8005bfa:	a369      	add	r3, pc, #420	; (adr r3, 8005da0 <__ieee754_pow+0x910>)
 8005bfc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005c00:	f7fa fbfc 	bl	80003fc <__adddf3>
 8005c04:	4632      	mov	r2, r6
 8005c06:	463b      	mov	r3, r7
 8005c08:	f7fa fdaa 	bl	8000760 <__aeabi_dmul>
 8005c0c:	4602      	mov	r2, r0
 8005c0e:	460b      	mov	r3, r1
 8005c10:	4620      	mov	r0, r4
 8005c12:	4629      	mov	r1, r5
 8005c14:	f7fa fbf0 	bl	80003f8 <__aeabi_dsub>
 8005c18:	4606      	mov	r6, r0
 8005c1a:	460f      	mov	r7, r1
 8005c1c:	4632      	mov	r2, r6
 8005c1e:	463b      	mov	r3, r7
 8005c20:	4620      	mov	r0, r4
 8005c22:	4629      	mov	r1, r5
 8005c24:	f7fa fd9c 	bl	8000760 <__aeabi_dmul>
 8005c28:	2200      	movs	r2, #0
 8005c2a:	e9cd 0100 	strd	r0, r1, [sp]
 8005c2e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005c32:	4630      	mov	r0, r6
 8005c34:	4639      	mov	r1, r7
 8005c36:	f7fa fbdf 	bl	80003f8 <__aeabi_dsub>
 8005c3a:	4602      	mov	r2, r0
 8005c3c:	460b      	mov	r3, r1
 8005c3e:	e9dd 0100 	ldrd	r0, r1, [sp]
 8005c42:	f7fa feb7 	bl	80009b4 <__aeabi_ddiv>
 8005c46:	4642      	mov	r2, r8
 8005c48:	4606      	mov	r6, r0
 8005c4a:	460f      	mov	r7, r1
 8005c4c:	464b      	mov	r3, r9
 8005c4e:	4620      	mov	r0, r4
 8005c50:	4629      	mov	r1, r5
 8005c52:	f7fa fd85 	bl	8000760 <__aeabi_dmul>
 8005c56:	4642      	mov	r2, r8
 8005c58:	464b      	mov	r3, r9
 8005c5a:	f7fa fbcf 	bl	80003fc <__adddf3>
 8005c5e:	4602      	mov	r2, r0
 8005c60:	460b      	mov	r3, r1
 8005c62:	4630      	mov	r0, r6
 8005c64:	4639      	mov	r1, r7
 8005c66:	f7fa fbc7 	bl	80003f8 <__aeabi_dsub>
 8005c6a:	4622      	mov	r2, r4
 8005c6c:	462b      	mov	r3, r5
 8005c6e:	f7fa fbc3 	bl	80003f8 <__aeabi_dsub>
 8005c72:	4602      	mov	r2, r0
 8005c74:	460b      	mov	r3, r1
 8005c76:	2000      	movs	r0, #0
 8005c78:	4953      	ldr	r1, [pc, #332]	; (8005dc8 <__ieee754_pow+0x938>)
 8005c7a:	f7fa fbbd 	bl	80003f8 <__aeabi_dsub>
 8005c7e:	448a      	add	sl, r1
 8005c80:	f5ba 1f80 	cmp.w	sl, #1048576	; 0x100000
 8005c84:	4602      	mov	r2, r0
 8005c86:	460b      	mov	r3, r1
 8005c88:	f2c0 8148 	blt.w	8005f1c <__ieee754_pow+0xa8c>
 8005c8c:	4653      	mov	r3, sl
 8005c8e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8005c92:	f7fa fd65 	bl	8000760 <__aeabi_dmul>
 8005c96:	ec41 0b10 	vmov	d0, r0, r1
 8005c9a:	e440      	b.n	800551e <__ieee754_pow+0x8e>
 8005c9c:	2a00      	cmp	r2, #0
 8005c9e:	f6ff ac71 	blt.w	8005584 <__ieee754_pow+0xf4>
 8005ca2:	ed9f 0b41 	vldr	d0, [pc, #260]	; 8005da8 <__ieee754_pow+0x918>
 8005ca6:	e43a      	b.n	800551e <__ieee754_pow+0x8e>
 8005ca8:	f106 4640 	add.w	r6, r6, #3221225472	; 0xc0000000
 8005cac:	f506 1680 	add.w	r6, r6, #1048576	; 0x100000
 8005cb0:	ea58 0306 	orrs.w	r3, r8, r6
 8005cb4:	f43f acbc 	beq.w	8005630 <__ieee754_pow+0x1a0>
 8005cb8:	f1b8 0f01 	cmp.w	r8, #1
 8005cbc:	f47f ac79 	bne.w	80055b2 <__ieee754_pow+0x122>
 8005cc0:	4602      	mov	r2, r0
 8005cc2:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8005cc6:	ec43 2b10 	vmov	d0, r2, r3
 8005cca:	e428      	b.n	800551e <__ieee754_pow+0x8e>
 8005ccc:	4650      	mov	r0, sl
 8005cce:	4659      	mov	r1, fp
 8005cd0:	4652      	mov	r2, sl
 8005cd2:	465b      	mov	r3, fp
 8005cd4:	f7fa fd44 	bl	8000760 <__aeabi_dmul>
 8005cd8:	ec41 0b10 	vmov	d0, r0, r1
 8005cdc:	e41f      	b.n	800551e <__ieee754_pow+0x8e>
 8005cde:	4b3b      	ldr	r3, [pc, #236]	; (8005dcc <__ieee754_pow+0x93c>)
 8005ce0:	f021 4800 	bic.w	r8, r1, #2147483648	; 0x80000000
 8005ce4:	4598      	cmp	r8, r3
 8005ce6:	f340 810a 	ble.w	8005efe <__ieee754_pow+0xa6e>
 8005cea:	4b39      	ldr	r3, [pc, #228]	; (8005dd0 <__ieee754_pow+0x940>)
 8005cec:	440b      	add	r3, r1
 8005cee:	4303      	orrs	r3, r0
 8005cf0:	d10c      	bne.n	8005d0c <__ieee754_pow+0x87c>
 8005cf2:	4632      	mov	r2, r6
 8005cf4:	463b      	mov	r3, r7
 8005cf6:	f7fa fb7f 	bl	80003f8 <__aeabi_dsub>
 8005cfa:	4602      	mov	r2, r0
 8005cfc:	460b      	mov	r3, r1
 8005cfe:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005d02:	f7fa ffaf 	bl	8000c64 <__aeabi_dcmple>
 8005d06:	2800      	cmp	r0, #0
 8005d08:	f43f aee1 	beq.w	8005ace <__ieee754_pow+0x63e>
 8005d0c:	a328      	add	r3, pc, #160	; (adr r3, 8005db0 <__ieee754_pow+0x920>)
 8005d0e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005d12:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8005d16:	f7fa fd23 	bl	8000760 <__aeabi_dmul>
 8005d1a:	a325      	add	r3, pc, #148	; (adr r3, 8005db0 <__ieee754_pow+0x920>)
 8005d1c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005d20:	f7fa fd1e 	bl	8000760 <__aeabi_dmul>
 8005d24:	ec41 0b10 	vmov	d0, r0, r1
 8005d28:	f7ff bbf9 	b.w	800551e <__ieee754_pow+0x8e>
 8005d2c:	ed9f 7b22 	vldr	d7, [pc, #136]	; 8005db8 <__ieee754_pow+0x928>
 8005d30:	ed8d 7b04 	vstr	d7, [sp, #16]
 8005d34:	e674      	b.n	8005a20 <__ieee754_pow+0x590>
 8005d36:	2a00      	cmp	r2, #0
 8005d38:	dab3      	bge.n	8005ca2 <__ieee754_pow+0x812>
 8005d3a:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
 8005d3e:	ee00 4a10 	vmov	s0, r4
 8005d42:	ee00 3a90 	vmov	s1, r3
 8005d46:	f7ff bbea 	b.w	800551e <__ieee754_pow+0x8e>
 8005d4a:	4602      	mov	r2, r0
 8005d4c:	460b      	mov	r3, r1
 8005d4e:	2000      	movs	r0, #0
 8005d50:	491d      	ldr	r1, [pc, #116]	; (8005dc8 <__ieee754_pow+0x938>)
 8005d52:	f7fa fe2f 	bl	80009b4 <__aeabi_ddiv>
 8005d56:	e428      	b.n	80055aa <__ieee754_pow+0x11a>
 8005d58:	00000000 	.word	0x00000000
 8005d5c:	bff00000 	.word	0xbff00000
 8005d60:	652b82fe 	.word	0x652b82fe
 8005d64:	3c971547 	.word	0x3c971547
 8005d68:	00000000 	.word	0x00000000
 8005d6c:	3fe62e43 	.word	0x3fe62e43
 8005d70:	fefa39ef 	.word	0xfefa39ef
 8005d74:	3fe62e42 	.word	0x3fe62e42
 8005d78:	0ca86c39 	.word	0x0ca86c39
 8005d7c:	be205c61 	.word	0xbe205c61
 8005d80:	72bea4d0 	.word	0x72bea4d0
 8005d84:	3e663769 	.word	0x3e663769
 8005d88:	c5d26bf1 	.word	0xc5d26bf1
 8005d8c:	3ebbbd41 	.word	0x3ebbbd41
 8005d90:	af25de2c 	.word	0xaf25de2c
 8005d94:	3f11566a 	.word	0x3f11566a
 8005d98:	16bebd93 	.word	0x16bebd93
 8005d9c:	3f66c16c 	.word	0x3f66c16c
 8005da0:	5555553e 	.word	0x5555553e
 8005da4:	3fc55555 	.word	0x3fc55555
	...
 8005db0:	c2f8f359 	.word	0xc2f8f359
 8005db4:	01a56e1f 	.word	0x01a56e1f
 8005db8:	00000000 	.word	0x00000000
 8005dbc:	3ff00000 	.word	0x3ff00000
 8005dc0:	408fffff 	.word	0x408fffff
 8005dc4:	000fffff 	.word	0x000fffff
 8005dc8:	3ff00000 	.word	0x3ff00000
 8005dcc:	4090cbff 	.word	0x4090cbff
 8005dd0:	3f6f3400 	.word	0x3f6f3400
 8005dd4:	4b62      	ldr	r3, [pc, #392]	; (8005f60 <__ieee754_pow+0xad0>)
 8005dd6:	429e      	cmp	r6, r3
 8005dd8:	f77f af60 	ble.w	8005c9c <__ieee754_pow+0x80c>
 8005ddc:	4b61      	ldr	r3, [pc, #388]	; (8005f64 <__ieee754_pow+0xad4>)
 8005dde:	429e      	cmp	r6, r3
 8005de0:	f73f abcd 	bgt.w	800557e <__ieee754_pow+0xee>
 8005de4:	2200      	movs	r2, #0
 8005de6:	4b5f      	ldr	r3, [pc, #380]	; (8005f64 <__ieee754_pow+0xad4>)
 8005de8:	f7fa fb06 	bl	80003f8 <__aeabi_dsub>
 8005dec:	a352      	add	r3, pc, #328	; (adr r3, 8005f38 <__ieee754_pow+0xaa8>)
 8005dee:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005df2:	4606      	mov	r6, r0
 8005df4:	460f      	mov	r7, r1
 8005df6:	f7fa fcb3 	bl	8000760 <__aeabi_dmul>
 8005dfa:	a351      	add	r3, pc, #324	; (adr r3, 8005f40 <__ieee754_pow+0xab0>)
 8005dfc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005e00:	e9cd 0100 	strd	r0, r1, [sp]
 8005e04:	4630      	mov	r0, r6
 8005e06:	4639      	mov	r1, r7
 8005e08:	f7fa fcaa 	bl	8000760 <__aeabi_dmul>
 8005e0c:	4632      	mov	r2, r6
 8005e0e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005e12:	463b      	mov	r3, r7
 8005e14:	4630      	mov	r0, r6
 8005e16:	4639      	mov	r1, r7
 8005e18:	f7fa fca2 	bl	8000760 <__aeabi_dmul>
 8005e1c:	2200      	movs	r2, #0
 8005e1e:	4682      	mov	sl, r0
 8005e20:	468b      	mov	fp, r1
 8005e22:	4630      	mov	r0, r6
 8005e24:	4639      	mov	r1, r7
 8005e26:	4b50      	ldr	r3, [pc, #320]	; (8005f68 <__ieee754_pow+0xad8>)
 8005e28:	f7fa fc9a 	bl	8000760 <__aeabi_dmul>
 8005e2c:	4602      	mov	r2, r0
 8005e2e:	460b      	mov	r3, r1
 8005e30:	a145      	add	r1, pc, #276	; (adr r1, 8005f48 <__ieee754_pow+0xab8>)
 8005e32:	e9d1 0100 	ldrd	r0, r1, [r1]
 8005e36:	f7fa fadf 	bl	80003f8 <__aeabi_dsub>
 8005e3a:	4632      	mov	r2, r6
 8005e3c:	463b      	mov	r3, r7
 8005e3e:	f7fa fc8f 	bl	8000760 <__aeabi_dmul>
 8005e42:	4602      	mov	r2, r0
 8005e44:	460b      	mov	r3, r1
 8005e46:	2000      	movs	r0, #0
 8005e48:	4948      	ldr	r1, [pc, #288]	; (8005f6c <__ieee754_pow+0xadc>)
 8005e4a:	f7fa fad5 	bl	80003f8 <__aeabi_dsub>
 8005e4e:	4602      	mov	r2, r0
 8005e50:	460b      	mov	r3, r1
 8005e52:	4650      	mov	r0, sl
 8005e54:	4659      	mov	r1, fp
 8005e56:	f7fa fc83 	bl	8000760 <__aeabi_dmul>
 8005e5a:	a33d      	add	r3, pc, #244	; (adr r3, 8005f50 <__ieee754_pow+0xac0>)
 8005e5c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005e60:	f7fa fc7e 	bl	8000760 <__aeabi_dmul>
 8005e64:	4602      	mov	r2, r0
 8005e66:	460b      	mov	r3, r1
 8005e68:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005e6c:	f7fa fac4 	bl	80003f8 <__aeabi_dsub>
 8005e70:	4606      	mov	r6, r0
 8005e72:	460f      	mov	r7, r1
 8005e74:	4632      	mov	r2, r6
 8005e76:	463b      	mov	r3, r7
 8005e78:	e9dd 0100 	ldrd	r0, r1, [sp]
 8005e7c:	f7fa fabe 	bl	80003fc <__adddf3>
 8005e80:	e9dd 2300 	ldrd	r2, r3, [sp]
 8005e84:	2000      	movs	r0, #0
 8005e86:	4682      	mov	sl, r0
 8005e88:	468b      	mov	fp, r1
 8005e8a:	f7fa fab5 	bl	80003f8 <__aeabi_dsub>
 8005e8e:	4602      	mov	r2, r0
 8005e90:	460b      	mov	r3, r1
 8005e92:	4630      	mov	r0, r6
 8005e94:	4639      	mov	r1, r7
 8005e96:	f7fa faaf 	bl	80003f8 <__aeabi_dsub>
 8005e9a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005e9e:	e5b5      	b.n	8005a0c <__ieee754_pow+0x57c>
 8005ea0:	2700      	movs	r7, #0
 8005ea2:	46bc      	mov	ip, r7
 8005ea4:	e40c      	b.n	80056c0 <__ieee754_pow+0x230>
 8005ea6:	2700      	movs	r7, #0
 8005ea8:	f7ff bbef 	b.w	800568a <__ieee754_pow+0x1fa>
 8005eac:	4652      	mov	r2, sl
 8005eae:	465b      	mov	r3, fp
 8005eb0:	2000      	movs	r0, #0
 8005eb2:	492c      	ldr	r1, [pc, #176]	; (8005f64 <__ieee754_pow+0xad4>)
 8005eb4:	f7fa fd7e 	bl	80009b4 <__aeabi_ddiv>
 8005eb8:	ec41 0b10 	vmov	d0, r0, r1
 8005ebc:	f7ff bb2f 	b.w	800551e <__ieee754_pow+0x8e>
 8005ec0:	a325      	add	r3, pc, #148	; (adr r3, 8005f58 <__ieee754_pow+0xac8>)
 8005ec2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005ec6:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8005eca:	f7fa fc49 	bl	8000760 <__aeabi_dmul>
 8005ece:	a322      	add	r3, pc, #136	; (adr r3, 8005f58 <__ieee754_pow+0xac8>)
 8005ed0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005ed4:	f7fa fc44 	bl	8000760 <__aeabi_dmul>
 8005ed8:	ec41 0b10 	vmov	d0, r0, r1
 8005edc:	f7ff bb1f 	b.w	800551e <__ieee754_pow+0x8e>
 8005ee0:	2b00      	cmp	r3, #0
 8005ee2:	f47f ab27 	bne.w	8005534 <__ieee754_pow+0xa4>
 8005ee6:	f5c1 6182 	rsb	r1, r1, #1040	; 0x410
 8005eea:	3103      	adds	r1, #3
 8005eec:	fa47 f001 	asr.w	r0, r7, r1
 8005ef0:	fa00 f101 	lsl.w	r1, r0, r1
 8005ef4:	42b9      	cmp	r1, r7
 8005ef6:	d019      	beq.n	8005f2c <__ieee754_pow+0xa9c>
 8005ef8:	4698      	mov	r8, r3
 8005efa:	f7ff baf0 	b.w	80054de <__ieee754_pow+0x4e>
 8005efe:	4b1b      	ldr	r3, [pc, #108]	; (8005f6c <__ieee754_pow+0xadc>)
 8005f00:	4598      	cmp	r8, r3
 8005f02:	f73f ade4 	bgt.w	8005ace <__ieee754_pow+0x63e>
 8005f06:	e9dd 2300 	ldrd	r2, r3, [sp]
 8005f0a:	4692      	mov	sl, r2
 8005f0c:	4693      	mov	fp, r2
 8005f0e:	e60c      	b.n	8005b2a <__ieee754_pow+0x69a>
 8005f10:	f44f 2780 	mov.w	r7, #262144	; 0x40000
 8005f14:	f04f 0c01 	mov.w	ip, #1
 8005f18:	f7ff bbd2 	b.w	80056c0 <__ieee754_pow+0x230>
 8005f1c:	ec43 2b10 	vmov	d0, r2, r3
 8005f20:	4658      	mov	r0, fp
 8005f22:	f000 f9b5 	bl	8006290 <scalbn>
 8005f26:	ec53 2b10 	vmov	r2, r3, d0
 8005f2a:	e6b0      	b.n	8005c8e <__ieee754_pow+0x7fe>
 8005f2c:	f000 0001 	and.w	r0, r0, #1
 8005f30:	f1c0 0802 	rsb	r8, r0, #2
 8005f34:	f7ff bad3 	b.w	80054de <__ieee754_pow+0x4e>
 8005f38:	60000000 	.word	0x60000000
 8005f3c:	3ff71547 	.word	0x3ff71547
 8005f40:	f85ddf44 	.word	0xf85ddf44
 8005f44:	3e54ae0b 	.word	0x3e54ae0b
 8005f48:	55555555 	.word	0x55555555
 8005f4c:	3fd55555 	.word	0x3fd55555
 8005f50:	652b82fe 	.word	0x652b82fe
 8005f54:	3ff71547 	.word	0x3ff71547
 8005f58:	8800759c 	.word	0x8800759c
 8005f5c:	7e37e43c 	.word	0x7e37e43c
 8005f60:	3feffffe 	.word	0x3feffffe
 8005f64:	3ff00000 	.word	0x3ff00000
 8005f68:	3fd00000 	.word	0x3fd00000
 8005f6c:	3fe00000 	.word	0x3fe00000

08005f70 <__ieee754_sqrt>:
 8005f70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005f74:	4967      	ldr	r1, [pc, #412]	; (8006114 <__ieee754_sqrt+0x1a4>)
 8005f76:	ec55 4b10 	vmov	r4, r5, d0
 8005f7a:	460e      	mov	r6, r1
 8005f7c:	4029      	ands	r1, r5
 8005f7e:	42b1      	cmp	r1, r6
 8005f80:	462b      	mov	r3, r5
 8005f82:	ee10 0a10 	vmov	r0, s0
 8005f86:	f000 8098 	beq.w	80060ba <__ieee754_sqrt+0x14a>
 8005f8a:	2d00      	cmp	r5, #0
 8005f8c:	4622      	mov	r2, r4
 8005f8e:	dd77      	ble.n	8006080 <__ieee754_sqrt+0x110>
 8005f90:	152f      	asrs	r7, r5, #20
 8005f92:	f000 8082 	beq.w	800609a <__ieee754_sqrt+0x12a>
 8005f96:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
 8005f9a:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8005f9e:	07f9      	lsls	r1, r7, #31
 8005fa0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8005fa4:	d467      	bmi.n	8006076 <__ieee754_sqrt+0x106>
 8005fa6:	0fd1      	lsrs	r1, r2, #31
 8005fa8:	2600      	movs	r6, #0
 8005faa:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 8005fae:	107f      	asrs	r7, r7, #1
 8005fb0:	0052      	lsls	r2, r2, #1
 8005fb2:	46b6      	mov	lr, r6
 8005fb4:	2016      	movs	r0, #22
 8005fb6:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8005fba:	eb0e 0401 	add.w	r4, lr, r1
 8005fbe:	429c      	cmp	r4, r3
 8005fc0:	ea4f 75d2 	mov.w	r5, r2, lsr #31
 8005fc4:	ea4f 0242 	mov.w	r2, r2, lsl #1
 8005fc8:	dc03      	bgt.n	8005fd2 <__ieee754_sqrt+0x62>
 8005fca:	1b1b      	subs	r3, r3, r4
 8005fcc:	eb04 0e01 	add.w	lr, r4, r1
 8005fd0:	440e      	add	r6, r1
 8005fd2:	3801      	subs	r0, #1
 8005fd4:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 8005fd8:	ea4f 0151 	mov.w	r1, r1, lsr #1
 8005fdc:	d1ed      	bne.n	8005fba <__ieee754_sqrt+0x4a>
 8005fde:	4684      	mov	ip, r0
 8005fe0:	2520      	movs	r5, #32
 8005fe2:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8005fe6:	e00a      	b.n	8005ffe <__ieee754_sqrt+0x8e>
 8005fe8:	4573      	cmp	r3, lr
 8005fea:	d021      	beq.n	8006030 <__ieee754_sqrt+0xc0>
 8005fec:	0fd4      	lsrs	r4, r2, #31
 8005fee:	3d01      	subs	r5, #1
 8005ff0:	ea4f 0151 	mov.w	r1, r1, lsr #1
 8005ff4:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 8005ff8:	ea4f 0242 	mov.w	r2, r2, lsl #1
 8005ffc:	d021      	beq.n	8006042 <__ieee754_sqrt+0xd2>
 8005ffe:	459e      	cmp	lr, r3
 8006000:	eb0c 0401 	add.w	r4, ip, r1
 8006004:	daf0      	bge.n	8005fe8 <__ieee754_sqrt+0x78>
 8006006:	2c00      	cmp	r4, #0
 8006008:	eb04 0c01 	add.w	ip, r4, r1
 800600c:	db0a      	blt.n	8006024 <__ieee754_sqrt+0xb4>
 800600e:	46f0      	mov	r8, lr
 8006010:	ebce 0303 	rsb	r3, lr, r3
 8006014:	4294      	cmp	r4, r2
 8006016:	bf88      	it	hi
 8006018:	f103 33ff 	addhi.w	r3, r3, #4294967295
 800601c:	1b12      	subs	r2, r2, r4
 800601e:	4408      	add	r0, r1
 8006020:	46c6      	mov	lr, r8
 8006022:	e7e3      	b.n	8005fec <__ieee754_sqrt+0x7c>
 8006024:	f1bc 0f00 	cmp.w	ip, #0
 8006028:	dbf1      	blt.n	800600e <__ieee754_sqrt+0x9e>
 800602a:	f10e 0801 	add.w	r8, lr, #1
 800602e:	e7ef      	b.n	8006010 <__ieee754_sqrt+0xa0>
 8006030:	4294      	cmp	r4, r2
 8006032:	d81e      	bhi.n	8006072 <__ieee754_sqrt+0x102>
 8006034:	2c00      	cmp	r4, #0
 8006036:	eb04 0c01 	add.w	ip, r4, r1
 800603a:	db4e      	blt.n	80060da <__ieee754_sqrt+0x16a>
 800603c:	4698      	mov	r8, r3
 800603e:	2300      	movs	r3, #0
 8006040:	e7ec      	b.n	800601c <__ieee754_sqrt+0xac>
 8006042:	4313      	orrs	r3, r2
 8006044:	d004      	beq.n	8006050 <__ieee754_sqrt+0xe0>
 8006046:	1c42      	adds	r2, r0, #1
 8006048:	d04d      	beq.n	80060e6 <__ieee754_sqrt+0x176>
 800604a:	f000 0301 	and.w	r3, r0, #1
 800604e:	4418      	add	r0, r3
 8006050:	0840      	lsrs	r0, r0, #1
 8006052:	1071      	asrs	r1, r6, #1
 8006054:	07f3      	lsls	r3, r6, #31
 8006056:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
 800605a:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
 800605e:	bf48      	it	mi
 8006060:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
 8006064:	eb01 5307 	add.w	r3, r1, r7, lsl #20
 8006068:	4602      	mov	r2, r0
 800606a:	ec43 2b10 	vmov	d0, r2, r3
 800606e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006072:	469e      	mov	lr, r3
 8006074:	e7ba      	b.n	8005fec <__ieee754_sqrt+0x7c>
 8006076:	0fd1      	lsrs	r1, r2, #31
 8006078:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 800607c:	0052      	lsls	r2, r2, #1
 800607e:	e792      	b.n	8005fa6 <__ieee754_sqrt+0x36>
 8006080:	f025 4100 	bic.w	r1, r5, #2147483648	; 0x80000000
 8006084:	4321      	orrs	r1, r4
 8006086:	d026      	beq.n	80060d6 <__ieee754_sqrt+0x166>
 8006088:	bba5      	cbnz	r5, 80060f4 <__ieee754_sqrt+0x184>
 800608a:	462f      	mov	r7, r5
 800608c:	0ad3      	lsrs	r3, r2, #11
 800608e:	3f15      	subs	r7, #21
 8006090:	0552      	lsls	r2, r2, #21
 8006092:	2b00      	cmp	r3, #0
 8006094:	d0fa      	beq.n	800608c <__ieee754_sqrt+0x11c>
 8006096:	02dc      	lsls	r4, r3, #11
 8006098:	d428      	bmi.n	80060ec <__ieee754_sqrt+0x17c>
 800609a:	2100      	movs	r1, #0
 800609c:	005b      	lsls	r3, r3, #1
 800609e:	02d8      	lsls	r0, r3, #11
 80060a0:	f101 0101 	add.w	r1, r1, #1
 80060a4:	d5fa      	bpl.n	800609c <__ieee754_sqrt+0x12c>
 80060a6:	f1c1 0001 	rsb	r0, r1, #1
 80060aa:	f1c1 0420 	rsb	r4, r1, #32
 80060ae:	fa22 f404 	lsr.w	r4, r2, r4
 80060b2:	4323      	orrs	r3, r4
 80060b4:	4407      	add	r7, r0
 80060b6:	408a      	lsls	r2, r1
 80060b8:	e76d      	b.n	8005f96 <__ieee754_sqrt+0x26>
 80060ba:	ee10 2a10 	vmov	r2, s0
 80060be:	462b      	mov	r3, r5
 80060c0:	4629      	mov	r1, r5
 80060c2:	f7fa fb4d 	bl	8000760 <__aeabi_dmul>
 80060c6:	4622      	mov	r2, r4
 80060c8:	462b      	mov	r3, r5
 80060ca:	f7fa f997 	bl	80003fc <__adddf3>
 80060ce:	ec41 0b10 	vmov	d0, r0, r1
 80060d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80060d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80060da:	f1bc 0f00 	cmp.w	ip, #0
 80060de:	daa4      	bge.n	800602a <__ieee754_sqrt+0xba>
 80060e0:	46f0      	mov	r8, lr
 80060e2:	2300      	movs	r3, #0
 80060e4:	e79a      	b.n	800601c <__ieee754_sqrt+0xac>
 80060e6:	3601      	adds	r6, #1
 80060e8:	4628      	mov	r0, r5
 80060ea:	e7b2      	b.n	8006052 <__ieee754_sqrt+0xe2>
 80060ec:	2420      	movs	r4, #32
 80060ee:	2001      	movs	r0, #1
 80060f0:	2100      	movs	r1, #0
 80060f2:	e7dc      	b.n	80060ae <__ieee754_sqrt+0x13e>
 80060f4:	ee10 0a10 	vmov	r0, s0
 80060f8:	4622      	mov	r2, r4
 80060fa:	462b      	mov	r3, r5
 80060fc:	4629      	mov	r1, r5
 80060fe:	f7fa f97b 	bl	80003f8 <__aeabi_dsub>
 8006102:	4602      	mov	r2, r0
 8006104:	460b      	mov	r3, r1
 8006106:	f7fa fc55 	bl	80009b4 <__aeabi_ddiv>
 800610a:	ec41 0b10 	vmov	d0, r0, r1
 800610e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006112:	bf00      	nop
 8006114:	7ff00000 	.word	0x7ff00000
	...

08006120 <fabs>:
 8006120:	ec53 2b10 	vmov	r2, r3, d0
 8006124:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8006128:	ec43 2b10 	vmov	d0, r2, r3
 800612c:	4770      	bx	lr
 800612e:	bf00      	nop

08006130 <finite>:
 8006130:	ee10 3a90 	vmov	r3, s1
 8006134:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
 8006138:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
 800613c:	0fc0      	lsrs	r0, r0, #31
 800613e:	4770      	bx	lr

08006140 <matherr>:
 8006140:	2000      	movs	r0, #0
 8006142:	4770      	bx	lr
	...

08006150 <nan>:
 8006150:	ed9f 0b01 	vldr	d0, [pc, #4]	; 8006158 <nan+0x8>
 8006154:	4770      	bx	lr
 8006156:	bf00      	nop
 8006158:	00000000 	.word	0x00000000
 800615c:	7ff80000 	.word	0x7ff80000

08006160 <rint>:
 8006160:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006162:	ec51 0b10 	vmov	r0, r1, d0
 8006166:	f3c1 560a 	ubfx	r6, r1, #20, #11
 800616a:	f2a6 32ff 	subw	r2, r6, #1023	; 0x3ff
 800616e:	2a13      	cmp	r2, #19
 8006170:	b083      	sub	sp, #12
 8006172:	460b      	mov	r3, r1
 8006174:	ee10 7a10 	vmov	r7, s0
 8006178:	ea4f 74d1 	mov.w	r4, r1, lsr #31
 800617c:	4605      	mov	r5, r0
 800617e:	dc2f      	bgt.n	80061e0 <rint+0x80>
 8006180:	2a00      	cmp	r2, #0
 8006182:	db48      	blt.n	8006216 <rint+0xb6>
 8006184:	4e3d      	ldr	r6, [pc, #244]	; (800627c <rint+0x11c>)
 8006186:	4116      	asrs	r6, r2
 8006188:	ea06 0701 	and.w	r7, r6, r1
 800618c:	4307      	orrs	r7, r0
 800618e:	d02c      	beq.n	80061ea <rint+0x8a>
 8006190:	0876      	lsrs	r6, r6, #1
 8006192:	4031      	ands	r1, r6
 8006194:	430d      	orrs	r5, r1
 8006196:	d00c      	beq.n	80061b2 <rint+0x52>
 8006198:	f44f 2180 	mov.w	r1, #262144	; 0x40000
 800619c:	2a13      	cmp	r2, #19
 800619e:	ea23 0606 	bic.w	r6, r3, r6
 80061a2:	fa41 f302 	asr.w	r3, r1, r2
 80061a6:	ea43 0306 	orr.w	r3, r3, r6
 80061aa:	bf0c      	ite	eq
 80061ac:	f04f 4500 	moveq.w	r5, #2147483648	; 0x80000000
 80061b0:	2500      	movne	r5, #0
 80061b2:	4a33      	ldr	r2, [pc, #204]	; (8006280 <rint+0x120>)
 80061b4:	eb02 04c4 	add.w	r4, r2, r4, lsl #3
 80061b8:	4628      	mov	r0, r5
 80061ba:	e9d4 4500 	ldrd	r4, r5, [r4]
 80061be:	4602      	mov	r2, r0
 80061c0:	4629      	mov	r1, r5
 80061c2:	4620      	mov	r0, r4
 80061c4:	f7fa f91a 	bl	80003fc <__adddf3>
 80061c8:	e9cd 0100 	strd	r0, r1, [sp]
 80061cc:	4622      	mov	r2, r4
 80061ce:	462b      	mov	r3, r5
 80061d0:	e9dd 0100 	ldrd	r0, r1, [sp]
 80061d4:	f7fa f910 	bl	80003f8 <__aeabi_dsub>
 80061d8:	ec41 0b10 	vmov	d0, r0, r1
 80061dc:	b003      	add	sp, #12
 80061de:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80061e0:	2a33      	cmp	r2, #51	; 0x33
 80061e2:	dd06      	ble.n	80061f2 <rint+0x92>
 80061e4:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 80061e8:	d03f      	beq.n	800626a <rint+0x10a>
 80061ea:	ec41 0b10 	vmov	d0, r0, r1
 80061ee:	b003      	add	sp, #12
 80061f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80061f2:	f2a6 4613 	subw	r6, r6, #1043	; 0x413
 80061f6:	f04f 32ff 	mov.w	r2, #4294967295
 80061fa:	40f2      	lsrs	r2, r6
 80061fc:	4202      	tst	r2, r0
 80061fe:	d0f4      	beq.n	80061ea <rint+0x8a>
 8006200:	0852      	lsrs	r2, r2, #1
 8006202:	4202      	tst	r2, r0
 8006204:	d0d5      	beq.n	80061b2 <rint+0x52>
 8006206:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 800620a:	ea27 0202 	bic.w	r2, r7, r2
 800620e:	fa41 f506 	asr.w	r5, r1, r6
 8006212:	4315      	orrs	r5, r2
 8006214:	e7cd      	b.n	80061b2 <rint+0x52>
 8006216:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
 800621a:	4302      	orrs	r2, r0
 800621c:	d0e5      	beq.n	80061ea <rint+0x8a>
 800621e:	f3c1 0213 	ubfx	r2, r1, #0, #20
 8006222:	4317      	orrs	r7, r2
 8006224:	427a      	negs	r2, r7
 8006226:	4317      	orrs	r7, r2
 8006228:	4a15      	ldr	r2, [pc, #84]	; (8006280 <rint+0x120>)
 800622a:	0c4b      	lsrs	r3, r1, #17
 800622c:	0b3f      	lsrs	r7, r7, #12
 800622e:	045b      	lsls	r3, r3, #17
 8006230:	f407 2700 	and.w	r7, r7, #524288	; 0x80000
 8006234:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 8006238:	ea47 0103 	orr.w	r1, r7, r3
 800623c:	e9d2 6700 	ldrd	r6, r7, [r2]
 8006240:	460b      	mov	r3, r1
 8006242:	4602      	mov	r2, r0
 8006244:	4639      	mov	r1, r7
 8006246:	4630      	mov	r0, r6
 8006248:	f7fa f8d8 	bl	80003fc <__adddf3>
 800624c:	e9cd 0100 	strd	r0, r1, [sp]
 8006250:	463b      	mov	r3, r7
 8006252:	4632      	mov	r2, r6
 8006254:	e9dd 0100 	ldrd	r0, r1, [sp]
 8006258:	f7fa f8ce 	bl	80003f8 <__aeabi_dsub>
 800625c:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8006260:	ea43 71c4 	orr.w	r1, r3, r4, lsl #31
 8006264:	ec41 0b10 	vmov	d0, r0, r1
 8006268:	e7c1      	b.n	80061ee <rint+0x8e>
 800626a:	ee10 2a10 	vmov	r2, s0
 800626e:	460b      	mov	r3, r1
 8006270:	f7fa f8c4 	bl	80003fc <__adddf3>
 8006274:	ec41 0b10 	vmov	d0, r0, r1
 8006278:	e7b9      	b.n	80061ee <rint+0x8e>
 800627a:	bf00      	nop
 800627c:	000fffff 	.word	0x000fffff
 8006280:	08006f20 	.word	0x08006f20
	...

08006290 <scalbn>:
 8006290:	ec53 2b10 	vmov	r2, r3, d0
 8006294:	b570      	push	{r4, r5, r6, lr}
 8006296:	f3c3 540a 	ubfx	r4, r3, #20, #11
 800629a:	4619      	mov	r1, r3
 800629c:	4605      	mov	r5, r0
 800629e:	bb3c      	cbnz	r4, 80062f0 <scalbn+0x60>
 80062a0:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 80062a4:	4311      	orrs	r1, r2
 80062a6:	d037      	beq.n	8006318 <scalbn+0x88>
 80062a8:	4619      	mov	r1, r3
 80062aa:	2200      	movs	r2, #0
 80062ac:	4b36      	ldr	r3, [pc, #216]	; (8006388 <scalbn+0xf8>)
 80062ae:	4e37      	ldr	r6, [pc, #220]	; (800638c <scalbn+0xfc>)
 80062b0:	ee10 0a10 	vmov	r0, s0
 80062b4:	f7fa fa54 	bl	8000760 <__aeabi_dmul>
 80062b8:	42b5      	cmp	r5, r6
 80062ba:	4602      	mov	r2, r0
 80062bc:	460b      	mov	r3, r1
 80062be:	db3b      	blt.n	8006338 <scalbn+0xa8>
 80062c0:	f3c1 540a 	ubfx	r4, r1, #20, #11
 80062c4:	3c36      	subs	r4, #54	; 0x36
 80062c6:	442c      	add	r4, r5
 80062c8:	f240 70fe 	movw	r0, #2046	; 0x7fe
 80062cc:	4284      	cmp	r4, r0
 80062ce:	dd18      	ble.n	8006302 <scalbn+0x72>
 80062d0:	ec43 2b11 	vmov	d1, r2, r3
 80062d4:	ed9f 0b28 	vldr	d0, [pc, #160]	; 8006378 <scalbn+0xe8>
 80062d8:	f000 fa62 	bl	80067a0 <copysign>
 80062dc:	a326      	add	r3, pc, #152	; (adr r3, 8006378 <scalbn+0xe8>)
 80062de:	e9d3 2300 	ldrd	r2, r3, [r3]
 80062e2:	ec51 0b10 	vmov	r0, r1, d0
 80062e6:	f7fa fa3b 	bl	8000760 <__aeabi_dmul>
 80062ea:	ec41 0b10 	vmov	d0, r0, r1
 80062ee:	bd70      	pop	{r4, r5, r6, pc}
 80062f0:	f240 70ff 	movw	r0, #2047	; 0x7ff
 80062f4:	4284      	cmp	r4, r0
 80062f6:	d027      	beq.n	8006348 <scalbn+0xb8>
 80062f8:	442c      	add	r4, r5
 80062fa:	f240 70fe 	movw	r0, #2046	; 0x7fe
 80062fe:	4284      	cmp	r4, r0
 8006300:	dce6      	bgt.n	80062d0 <scalbn+0x40>
 8006302:	2c00      	cmp	r4, #0
 8006304:	dd09      	ble.n	800631a <scalbn+0x8a>
 8006306:	f021 41ff 	bic.w	r1, r1, #2139095040	; 0x7f800000
 800630a:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
 800630e:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
 8006312:	ec43 2b10 	vmov	d0, r2, r3
 8006316:	bd70      	pop	{r4, r5, r6, pc}
 8006318:	bd70      	pop	{r4, r5, r6, pc}
 800631a:	f114 0f35 	cmn.w	r4, #53	; 0x35
 800631e:	da1b      	bge.n	8006358 <scalbn+0xc8>
 8006320:	f24c 3150 	movw	r1, #50000	; 0xc350
 8006324:	428d      	cmp	r5, r1
 8006326:	dcd3      	bgt.n	80062d0 <scalbn+0x40>
 8006328:	ed9f 0b15 	vldr	d0, [pc, #84]	; 8006380 <scalbn+0xf0>
 800632c:	ec43 2b11 	vmov	d1, r2, r3
 8006330:	f000 fa36 	bl	80067a0 <copysign>
 8006334:	ec51 0b10 	vmov	r0, r1, d0
 8006338:	a311      	add	r3, pc, #68	; (adr r3, 8006380 <scalbn+0xf0>)
 800633a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800633e:	f7fa fa0f 	bl	8000760 <__aeabi_dmul>
 8006342:	ec41 0b10 	vmov	d0, r0, r1
 8006346:	bd70      	pop	{r4, r5, r6, pc}
 8006348:	ee10 0a10 	vmov	r0, s0
 800634c:	4619      	mov	r1, r3
 800634e:	f7fa f855 	bl	80003fc <__adddf3>
 8006352:	ec41 0b10 	vmov	d0, r0, r1
 8006356:	bd70      	pop	{r4, r5, r6, pc}
 8006358:	f021 41ff 	bic.w	r1, r1, #2139095040	; 0x7f800000
 800635c:	f421 01e0 	bic.w	r1, r1, #7340032	; 0x700000
 8006360:	3436      	adds	r4, #54	; 0x36
 8006362:	ea41 5304 	orr.w	r3, r1, r4, lsl #20
 8006366:	4610      	mov	r0, r2
 8006368:	4619      	mov	r1, r3
 800636a:	2200      	movs	r2, #0
 800636c:	4b08      	ldr	r3, [pc, #32]	; (8006390 <scalbn+0x100>)
 800636e:	f7fa f9f7 	bl	8000760 <__aeabi_dmul>
 8006372:	ec41 0b10 	vmov	d0, r0, r1
 8006376:	bd70      	pop	{r4, r5, r6, pc}
 8006378:	8800759c 	.word	0x8800759c
 800637c:	7e37e43c 	.word	0x7e37e43c
 8006380:	c2f8f359 	.word	0xc2f8f359
 8006384:	01a56e1f 	.word	0x01a56e1f
 8006388:	43500000 	.word	0x43500000
 800638c:	ffff3cb0 	.word	0xffff3cb0
 8006390:	3c900000 	.word	0x3c900000
 8006394:	f3af 8000 	nop.w
	...

080063a0 <__ieee754_log>:
 80063a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80063a4:	ec51 0b10 	vmov	r0, r1, d0
 80063a8:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80063ac:	b085      	sub	sp, #20
 80063ae:	460b      	mov	r3, r1
 80063b0:	da59      	bge.n	8006466 <__ieee754_log+0xc6>
 80063b2:	ee10 2a10 	vmov	r2, s0
 80063b6:	f021 4400 	bic.w	r4, r1, #2147483648	; 0x80000000
 80063ba:	4322      	orrs	r2, r4
 80063bc:	f000 80f6 	beq.w	80065ac <__ieee754_log+0x20c>
 80063c0:	2900      	cmp	r1, #0
 80063c2:	f2c0 8179 	blt.w	80066b8 <__ieee754_log+0x318>
 80063c6:	2200      	movs	r2, #0
 80063c8:	4bd9      	ldr	r3, [pc, #868]	; (8006730 <__ieee754_log+0x390>)
 80063ca:	4cda      	ldr	r4, [pc, #872]	; (8006734 <__ieee754_log+0x394>)
 80063cc:	f7fa f9c8 	bl	8000760 <__aeabi_dmul>
 80063d0:	460b      	mov	r3, r1
 80063d2:	42a3      	cmp	r3, r4
 80063d4:	f06f 0235 	mvn.w	r2, #53	; 0x35
 80063d8:	dc4a      	bgt.n	8006470 <__ieee754_log+0xd0>
 80063da:	f3c3 0513 	ubfx	r5, r3, #0, #20
 80063de:	f505 2415 	add.w	r4, r5, #610304	; 0x95000
 80063e2:	f604 7464 	addw	r4, r4, #3940	; 0xf64
 80063e6:	f404 1680 	and.w	r6, r4, #1048576	; 0x100000
 80063ea:	f086 547f 	eor.w	r4, r6, #1069547520	; 0x3fc00000
 80063ee:	151b      	asrs	r3, r3, #20
 80063f0:	f484 1440 	eor.w	r4, r4, #3145728	; 0x300000
 80063f4:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
 80063f8:	ea44 0105 	orr.w	r1, r4, r5
 80063fc:	189c      	adds	r4, r3, r2
 80063fe:	2200      	movs	r2, #0
 8006400:	4bcd      	ldr	r3, [pc, #820]	; (8006738 <__ieee754_log+0x398>)
 8006402:	f7f9 fff9 	bl	80003f8 <__aeabi_dsub>
 8006406:	1cab      	adds	r3, r5, #2
 8006408:	f3c3 0313 	ubfx	r3, r3, #0, #20
 800640c:	2b02      	cmp	r3, #2
 800640e:	eb04 5416 	add.w	r4, r4, r6, lsr #20
 8006412:	4682      	mov	sl, r0
 8006414:	468b      	mov	fp, r1
 8006416:	f04f 0200 	mov.w	r2, #0
 800641a:	dc32      	bgt.n	8006482 <__ieee754_log+0xe2>
 800641c:	2300      	movs	r3, #0
 800641e:	f7fa fc0d 	bl	8000c3c <__aeabi_dcmpeq>
 8006422:	2800      	cmp	r0, #0
 8006424:	f000 80cd 	beq.w	80065c2 <__ieee754_log+0x222>
 8006428:	2c00      	cmp	r4, #0
 800642a:	f000 8151 	beq.w	80066d0 <__ieee754_log+0x330>
 800642e:	4620      	mov	r0, r4
 8006430:	f7fa f930 	bl	8000694 <__aeabi_i2d>
 8006434:	a3a8      	add	r3, pc, #672	; (adr r3, 80066d8 <__ieee754_log+0x338>)
 8006436:	e9d3 2300 	ldrd	r2, r3, [r3]
 800643a:	4606      	mov	r6, r0
 800643c:	460f      	mov	r7, r1
 800643e:	f7fa f98f 	bl	8000760 <__aeabi_dmul>
 8006442:	a3a7      	add	r3, pc, #668	; (adr r3, 80066e0 <__ieee754_log+0x340>)
 8006444:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006448:	4604      	mov	r4, r0
 800644a:	460d      	mov	r5, r1
 800644c:	4630      	mov	r0, r6
 800644e:	4639      	mov	r1, r7
 8006450:	f7fa f986 	bl	8000760 <__aeabi_dmul>
 8006454:	4602      	mov	r2, r0
 8006456:	460b      	mov	r3, r1
 8006458:	4620      	mov	r0, r4
 800645a:	4629      	mov	r1, r5
 800645c:	f7f9 ffce 	bl	80003fc <__adddf3>
 8006460:	ec41 0b10 	vmov	d0, r0, r1
 8006464:	e00a      	b.n	800647c <__ieee754_log+0xdc>
 8006466:	4cb3      	ldr	r4, [pc, #716]	; (8006734 <__ieee754_log+0x394>)
 8006468:	42a3      	cmp	r3, r4
 800646a:	f04f 0200 	mov.w	r2, #0
 800646e:	ddb4      	ble.n	80063da <__ieee754_log+0x3a>
 8006470:	4602      	mov	r2, r0
 8006472:	460b      	mov	r3, r1
 8006474:	f7f9 ffc2 	bl	80003fc <__adddf3>
 8006478:	ec41 0b10 	vmov	d0, r0, r1
 800647c:	b005      	add	sp, #20
 800647e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006482:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006486:	f7f9 ffb9 	bl	80003fc <__adddf3>
 800648a:	4602      	mov	r2, r0
 800648c:	460b      	mov	r3, r1
 800648e:	4650      	mov	r0, sl
 8006490:	4659      	mov	r1, fp
 8006492:	f7fa fa8f 	bl	80009b4 <__aeabi_ddiv>
 8006496:	4606      	mov	r6, r0
 8006498:	460f      	mov	r7, r1
 800649a:	4620      	mov	r0, r4
 800649c:	e9cd 6700 	strd	r6, r7, [sp]
 80064a0:	f7fa f8f8 	bl	8000694 <__aeabi_i2d>
 80064a4:	4632      	mov	r2, r6
 80064a6:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80064aa:	463b      	mov	r3, r7
 80064ac:	4630      	mov	r0, r6
 80064ae:	4639      	mov	r1, r7
 80064b0:	f7fa f956 	bl	8000760 <__aeabi_dmul>
 80064b4:	4602      	mov	r2, r0
 80064b6:	460b      	mov	r3, r1
 80064b8:	4680      	mov	r8, r0
 80064ba:	4689      	mov	r9, r1
 80064bc:	f7fa f950 	bl	8000760 <__aeabi_dmul>
 80064c0:	a389      	add	r3, pc, #548	; (adr r3, 80066e8 <__ieee754_log+0x348>)
 80064c2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80064c6:	4606      	mov	r6, r0
 80064c8:	460f      	mov	r7, r1
 80064ca:	f7fa f949 	bl	8000760 <__aeabi_dmul>
 80064ce:	a388      	add	r3, pc, #544	; (adr r3, 80066f0 <__ieee754_log+0x350>)
 80064d0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80064d4:	f7f9 ff92 	bl	80003fc <__adddf3>
 80064d8:	4632      	mov	r2, r6
 80064da:	463b      	mov	r3, r7
 80064dc:	f7fa f940 	bl	8000760 <__aeabi_dmul>
 80064e0:	a385      	add	r3, pc, #532	; (adr r3, 80066f8 <__ieee754_log+0x358>)
 80064e2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80064e6:	f7f9 ff89 	bl	80003fc <__adddf3>
 80064ea:	4632      	mov	r2, r6
 80064ec:	463b      	mov	r3, r7
 80064ee:	f7fa f937 	bl	8000760 <__aeabi_dmul>
 80064f2:	a383      	add	r3, pc, #524	; (adr r3, 8006700 <__ieee754_log+0x360>)
 80064f4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80064f8:	f7f9 ff80 	bl	80003fc <__adddf3>
 80064fc:	4642      	mov	r2, r8
 80064fe:	464b      	mov	r3, r9
 8006500:	f7fa f92e 	bl	8000760 <__aeabi_dmul>
 8006504:	a380      	add	r3, pc, #512	; (adr r3, 8006708 <__ieee754_log+0x368>)
 8006506:	e9d3 2300 	ldrd	r2, r3, [r3]
 800650a:	4680      	mov	r8, r0
 800650c:	4689      	mov	r9, r1
 800650e:	4630      	mov	r0, r6
 8006510:	4639      	mov	r1, r7
 8006512:	f7fa f925 	bl	8000760 <__aeabi_dmul>
 8006516:	a37e      	add	r3, pc, #504	; (adr r3, 8006710 <__ieee754_log+0x370>)
 8006518:	e9d3 2300 	ldrd	r2, r3, [r3]
 800651c:	f7f9 ff6e 	bl	80003fc <__adddf3>
 8006520:	4632      	mov	r2, r6
 8006522:	463b      	mov	r3, r7
 8006524:	f7fa f91c 	bl	8000760 <__aeabi_dmul>
 8006528:	a37b      	add	r3, pc, #492	; (adr r3, 8006718 <__ieee754_log+0x378>)
 800652a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800652e:	f7f9 ff65 	bl	80003fc <__adddf3>
 8006532:	4632      	mov	r2, r6
 8006534:	463b      	mov	r3, r7
 8006536:	f7fa f913 	bl	8000760 <__aeabi_dmul>
 800653a:	460b      	mov	r3, r1
 800653c:	4602      	mov	r2, r0
 800653e:	4649      	mov	r1, r9
 8006540:	4640      	mov	r0, r8
 8006542:	f7f9 ff5b 	bl	80003fc <__adddf3>
 8006546:	f5a5 23c2 	sub.w	r3, r5, #397312	; 0x61000
 800654a:	f5c5 25d7 	rsb	r5, r5, #440320	; 0x6b800
 800654e:	f2a3 437a 	subw	r3, r3, #1146	; 0x47a
 8006552:	3551      	adds	r5, #81	; 0x51
 8006554:	431d      	orrs	r5, r3
 8006556:	2d00      	cmp	r5, #0
 8006558:	4606      	mov	r6, r0
 800655a:	460f      	mov	r7, r1
 800655c:	dd5a      	ble.n	8006614 <__ieee754_log+0x274>
 800655e:	2200      	movs	r2, #0
 8006560:	4b76      	ldr	r3, [pc, #472]	; (800673c <__ieee754_log+0x39c>)
 8006562:	4650      	mov	r0, sl
 8006564:	4659      	mov	r1, fp
 8006566:	f7fa f8fb 	bl	8000760 <__aeabi_dmul>
 800656a:	4652      	mov	r2, sl
 800656c:	465b      	mov	r3, fp
 800656e:	f7fa f8f7 	bl	8000760 <__aeabi_dmul>
 8006572:	4680      	mov	r8, r0
 8006574:	4689      	mov	r9, r1
 8006576:	2c00      	cmp	r4, #0
 8006578:	d167      	bne.n	800664a <__ieee754_log+0x2aa>
 800657a:	4632      	mov	r2, r6
 800657c:	463b      	mov	r3, r7
 800657e:	f7f9 ff3d 	bl	80003fc <__adddf3>
 8006582:	e9dd 2300 	ldrd	r2, r3, [sp]
 8006586:	f7fa f8eb 	bl	8000760 <__aeabi_dmul>
 800658a:	4602      	mov	r2, r0
 800658c:	460b      	mov	r3, r1
 800658e:	4640      	mov	r0, r8
 8006590:	4649      	mov	r1, r9
 8006592:	f7f9 ff31 	bl	80003f8 <__aeabi_dsub>
 8006596:	4602      	mov	r2, r0
 8006598:	460b      	mov	r3, r1
 800659a:	4650      	mov	r0, sl
 800659c:	4659      	mov	r1, fp
 800659e:	f7f9 ff2b 	bl	80003f8 <__aeabi_dsub>
 80065a2:	ec41 0b10 	vmov	d0, r0, r1
 80065a6:	b005      	add	sp, #20
 80065a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80065ac:	2200      	movs	r2, #0
 80065ae:	2300      	movs	r3, #0
 80065b0:	2000      	movs	r0, #0
 80065b2:	4963      	ldr	r1, [pc, #396]	; (8006740 <__ieee754_log+0x3a0>)
 80065b4:	f7fa f9fe 	bl	80009b4 <__aeabi_ddiv>
 80065b8:	ec41 0b10 	vmov	d0, r0, r1
 80065bc:	b005      	add	sp, #20
 80065be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80065c2:	4652      	mov	r2, sl
 80065c4:	465b      	mov	r3, fp
 80065c6:	4650      	mov	r0, sl
 80065c8:	4659      	mov	r1, fp
 80065ca:	f7fa f8c9 	bl	8000760 <__aeabi_dmul>
 80065ce:	a354      	add	r3, pc, #336	; (adr r3, 8006720 <__ieee754_log+0x380>)
 80065d0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80065d4:	4606      	mov	r6, r0
 80065d6:	460f      	mov	r7, r1
 80065d8:	4650      	mov	r0, sl
 80065da:	4659      	mov	r1, fp
 80065dc:	f7fa f8c0 	bl	8000760 <__aeabi_dmul>
 80065e0:	4602      	mov	r2, r0
 80065e2:	460b      	mov	r3, r1
 80065e4:	2000      	movs	r0, #0
 80065e6:	4955      	ldr	r1, [pc, #340]	; (800673c <__ieee754_log+0x39c>)
 80065e8:	f7f9 ff06 	bl	80003f8 <__aeabi_dsub>
 80065ec:	4602      	mov	r2, r0
 80065ee:	460b      	mov	r3, r1
 80065f0:	4630      	mov	r0, r6
 80065f2:	4639      	mov	r1, r7
 80065f4:	f7fa f8b4 	bl	8000760 <__aeabi_dmul>
 80065f8:	4606      	mov	r6, r0
 80065fa:	460f      	mov	r7, r1
 80065fc:	2c00      	cmp	r4, #0
 80065fe:	f040 80a1 	bne.w	8006744 <__ieee754_log+0x3a4>
 8006602:	4650      	mov	r0, sl
 8006604:	4659      	mov	r1, fp
 8006606:	4632      	mov	r2, r6
 8006608:	463b      	mov	r3, r7
 800660a:	f7f9 fef5 	bl	80003f8 <__aeabi_dsub>
 800660e:	ec41 0b10 	vmov	d0, r0, r1
 8006612:	e733      	b.n	800647c <__ieee754_log+0xdc>
 8006614:	2c00      	cmp	r4, #0
 8006616:	f000 80ad 	beq.w	8006774 <__ieee754_log+0x3d4>
 800661a:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 800661e:	a32e      	add	r3, pc, #184	; (adr r3, 80066d8 <__ieee754_log+0x338>)
 8006620:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006624:	4640      	mov	r0, r8
 8006626:	4649      	mov	r1, r9
 8006628:	f7fa f89a 	bl	8000760 <__aeabi_dmul>
 800662c:	4632      	mov	r2, r6
 800662e:	463b      	mov	r3, r7
 8006630:	4604      	mov	r4, r0
 8006632:	460d      	mov	r5, r1
 8006634:	4650      	mov	r0, sl
 8006636:	4659      	mov	r1, fp
 8006638:	f7f9 fede 	bl	80003f8 <__aeabi_dsub>
 800663c:	e9dd 2300 	ldrd	r2, r3, [sp]
 8006640:	f7fa f88e 	bl	8000760 <__aeabi_dmul>
 8006644:	4606      	mov	r6, r0
 8006646:	460f      	mov	r7, r1
 8006648:	e088      	b.n	800675c <__ieee754_log+0x3bc>
 800664a:	a323      	add	r3, pc, #140	; (adr r3, 80066d8 <__ieee754_log+0x338>)
 800664c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006650:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8006654:	f7fa f884 	bl	8000760 <__aeabi_dmul>
 8006658:	4632      	mov	r2, r6
 800665a:	463b      	mov	r3, r7
 800665c:	4604      	mov	r4, r0
 800665e:	460d      	mov	r5, r1
 8006660:	4640      	mov	r0, r8
 8006662:	4649      	mov	r1, r9
 8006664:	f7f9 feca 	bl	80003fc <__adddf3>
 8006668:	e9dd 2300 	ldrd	r2, r3, [sp]
 800666c:	f7fa f878 	bl	8000760 <__aeabi_dmul>
 8006670:	a31b      	add	r3, pc, #108	; (adr r3, 80066e0 <__ieee754_log+0x340>)
 8006672:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006676:	4606      	mov	r6, r0
 8006678:	460f      	mov	r7, r1
 800667a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800667e:	f7fa f86f 	bl	8000760 <__aeabi_dmul>
 8006682:	4602      	mov	r2, r0
 8006684:	460b      	mov	r3, r1
 8006686:	4630      	mov	r0, r6
 8006688:	4639      	mov	r1, r7
 800668a:	f7f9 feb7 	bl	80003fc <__adddf3>
 800668e:	4602      	mov	r2, r0
 8006690:	460b      	mov	r3, r1
 8006692:	4640      	mov	r0, r8
 8006694:	4649      	mov	r1, r9
 8006696:	f7f9 feaf 	bl	80003f8 <__aeabi_dsub>
 800669a:	4652      	mov	r2, sl
 800669c:	465b      	mov	r3, fp
 800669e:	f7f9 feab 	bl	80003f8 <__aeabi_dsub>
 80066a2:	4602      	mov	r2, r0
 80066a4:	460b      	mov	r3, r1
 80066a6:	4620      	mov	r0, r4
 80066a8:	4629      	mov	r1, r5
 80066aa:	f7f9 fea5 	bl	80003f8 <__aeabi_dsub>
 80066ae:	ec41 0b10 	vmov	d0, r0, r1
 80066b2:	b005      	add	sp, #20
 80066b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80066b8:	ee10 2a10 	vmov	r2, s0
 80066bc:	460b      	mov	r3, r1
 80066be:	f7f9 fe9b 	bl	80003f8 <__aeabi_dsub>
 80066c2:	2200      	movs	r2, #0
 80066c4:	2300      	movs	r3, #0
 80066c6:	f7fa f975 	bl	80009b4 <__aeabi_ddiv>
 80066ca:	ec41 0b10 	vmov	d0, r0, r1
 80066ce:	e6d5      	b.n	800647c <__ieee754_log+0xdc>
 80066d0:	ed9f 0b15 	vldr	d0, [pc, #84]	; 8006728 <__ieee754_log+0x388>
 80066d4:	e6d2      	b.n	800647c <__ieee754_log+0xdc>
 80066d6:	bf00      	nop
 80066d8:	fee00000 	.word	0xfee00000
 80066dc:	3fe62e42 	.word	0x3fe62e42
 80066e0:	35793c76 	.word	0x35793c76
 80066e4:	3dea39ef 	.word	0x3dea39ef
 80066e8:	df3e5244 	.word	0xdf3e5244
 80066ec:	3fc2f112 	.word	0x3fc2f112
 80066f0:	96cb03de 	.word	0x96cb03de
 80066f4:	3fc74664 	.word	0x3fc74664
 80066f8:	94229359 	.word	0x94229359
 80066fc:	3fd24924 	.word	0x3fd24924
 8006700:	55555593 	.word	0x55555593
 8006704:	3fe55555 	.word	0x3fe55555
 8006708:	d078c69f 	.word	0xd078c69f
 800670c:	3fc39a09 	.word	0x3fc39a09
 8006710:	1d8e78af 	.word	0x1d8e78af
 8006714:	3fcc71c5 	.word	0x3fcc71c5
 8006718:	9997fa04 	.word	0x9997fa04
 800671c:	3fd99999 	.word	0x3fd99999
 8006720:	55555555 	.word	0x55555555
 8006724:	3fd55555 	.word	0x3fd55555
	...
 8006730:	43500000 	.word	0x43500000
 8006734:	7fefffff 	.word	0x7fefffff
 8006738:	3ff00000 	.word	0x3ff00000
 800673c:	3fe00000 	.word	0x3fe00000
 8006740:	c3500000 	.word	0xc3500000
 8006744:	4620      	mov	r0, r4
 8006746:	f7f9 ffa5 	bl	8000694 <__aeabi_i2d>
 800674a:	a311      	add	r3, pc, #68	; (adr r3, 8006790 <__ieee754_log+0x3f0>)
 800674c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006750:	4680      	mov	r8, r0
 8006752:	4689      	mov	r9, r1
 8006754:	f7fa f804 	bl	8000760 <__aeabi_dmul>
 8006758:	4604      	mov	r4, r0
 800675a:	460d      	mov	r5, r1
 800675c:	a30e      	add	r3, pc, #56	; (adr r3, 8006798 <__ieee754_log+0x3f8>)
 800675e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8006762:	4640      	mov	r0, r8
 8006764:	4649      	mov	r1, r9
 8006766:	f7f9 fffb 	bl	8000760 <__aeabi_dmul>
 800676a:	4602      	mov	r2, r0
 800676c:	460b      	mov	r3, r1
 800676e:	4630      	mov	r0, r6
 8006770:	4639      	mov	r1, r7
 8006772:	e790      	b.n	8006696 <__ieee754_log+0x2f6>
 8006774:	4602      	mov	r2, r0
 8006776:	460b      	mov	r3, r1
 8006778:	4650      	mov	r0, sl
 800677a:	4659      	mov	r1, fp
 800677c:	f7f9 fe3c 	bl	80003f8 <__aeabi_dsub>
 8006780:	e9dd 2300 	ldrd	r2, r3, [sp]
 8006784:	f7f9 ffec 	bl	8000760 <__aeabi_dmul>
 8006788:	e705      	b.n	8006596 <__ieee754_log+0x1f6>
 800678a:	bf00      	nop
 800678c:	f3af 8000 	nop.w
 8006790:	fee00000 	.word	0xfee00000
 8006794:	3fe62e42 	.word	0x3fe62e42
 8006798:	35793c76 	.word	0x35793c76
 800679c:	3dea39ef 	.word	0x3dea39ef

080067a0 <copysign>:
 80067a0:	ec53 2b10 	vmov	r2, r3, d0
 80067a4:	ee11 0a90 	vmov	r0, s3
 80067a8:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 80067ac:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80067b0:	ea40 0301 	orr.w	r3, r0, r1
 80067b4:	ec43 2b10 	vmov	d0, r2, r3
 80067b8:	4770      	bx	lr
 80067ba:	bf00      	nop
 80067bc:	0000      	movs	r0, r0
	...

080067c0 <__errno>:
 80067c0:	4b01      	ldr	r3, [pc, #4]	; (80067c8 <__errno+0x8>)
 80067c2:	6818      	ldr	r0, [r3, #0]
 80067c4:	4770      	bx	lr
 80067c6:	bf00      	nop
 80067c8:	20000ee8 	.word	0x20000ee8
 80067cc:	00000000 	.word	0x00000000

080067d0 <strcasecmp>:
 80067d0:	4b0f      	ldr	r3, [pc, #60]	; (8006810 <strcasecmp+0x40>)
 80067d2:	b430      	push	{r4, r5}
 80067d4:	681d      	ldr	r5, [r3, #0]
 80067d6:	e002      	b.n	80067de <strcasecmp+0xe>
 80067d8:	1ad2      	subs	r2, r2, r3
 80067da:	d116      	bne.n	800680a <strcasecmp+0x3a>
 80067dc:	b1ab      	cbz	r3, 800680a <strcasecmp+0x3a>
 80067de:	f810 4b01 	ldrb.w	r4, [r0], #1
 80067e2:	192b      	adds	r3, r5, r4
 80067e4:	4622      	mov	r2, r4
 80067e6:	785b      	ldrb	r3, [r3, #1]
 80067e8:	f003 0303 	and.w	r3, r3, #3
 80067ec:	2b01      	cmp	r3, #1
 80067ee:	f811 3b01 	ldrb.w	r3, [r1], #1
 80067f2:	bf08      	it	eq
 80067f4:	f104 0220 	addeq.w	r2, r4, #32
 80067f8:	18ec      	adds	r4, r5, r3
 80067fa:	7864      	ldrb	r4, [r4, #1]
 80067fc:	f004 0403 	and.w	r4, r4, #3
 8006800:	2c01      	cmp	r4, #1
 8006802:	d1e9      	bne.n	80067d8 <strcasecmp+0x8>
 8006804:	3320      	adds	r3, #32
 8006806:	1ad2      	subs	r2, r2, r3
 8006808:	d0e9      	beq.n	80067de <strcasecmp+0xe>
 800680a:	4610      	mov	r0, r2
 800680c:	bc30      	pop	{r4, r5}
 800680e:	4770      	bx	lr
 8006810:	20000eec 	.word	0x20000eec
	...

08006820 <strpbrk>:
 8006820:	b430      	push	{r4, r5}
 8006822:	7804      	ldrb	r4, [r0, #0]
 8006824:	b1ec      	cbz	r4, 8006862 <strpbrk+0x42>
 8006826:	780d      	ldrb	r5, [r1, #0]
 8006828:	b1ad      	cbz	r5, 8006856 <strpbrk+0x36>
 800682a:	42ac      	cmp	r4, r5
 800682c:	d00e      	beq.n	800684c <strpbrk+0x2c>
 800682e:	460a      	mov	r2, r1
 8006830:	e001      	b.n	8006836 <strpbrk+0x16>
 8006832:	429c      	cmp	r4, r3
 8006834:	d009      	beq.n	800684a <strpbrk+0x2a>
 8006836:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800683a:	2b00      	cmp	r3, #0
 800683c:	d1f9      	bne.n	8006832 <strpbrk+0x12>
 800683e:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8006842:	2c00      	cmp	r4, #0
 8006844:	d1f0      	bne.n	8006828 <strpbrk+0x8>
 8006846:	7815      	ldrb	r5, [r2, #0]
 8006848:	e000      	b.n	800684c <strpbrk+0x2c>
 800684a:	4625      	mov	r5, r4
 800684c:	2d00      	cmp	r5, #0
 800684e:	bf08      	it	eq
 8006850:	2000      	moveq	r0, #0
 8006852:	bc30      	pop	{r4, r5}
 8006854:	4770      	bx	lr
 8006856:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 800685a:	460a      	mov	r2, r1
 800685c:	2c00      	cmp	r4, #0
 800685e:	d1e3      	bne.n	8006828 <strpbrk+0x8>
 8006860:	e7f1      	b.n	8006846 <strpbrk+0x26>
 8006862:	4620      	mov	r0, r4
 8006864:	bc30      	pop	{r4, r5}
 8006866:	4770      	bx	lr
	...

08006870 <strspn>:
 8006870:	b470      	push	{r4, r5, r6}
 8006872:	7804      	ldrb	r4, [r0, #0]
 8006874:	b1a4      	cbz	r4, 80068a0 <strspn+0x30>
 8006876:	780e      	ldrb	r6, [r1, #0]
 8006878:	4605      	mov	r5, r0
 800687a:	b14e      	cbz	r6, 8006890 <strspn+0x20>
 800687c:	42b4      	cmp	r4, r6
 800687e:	d00a      	beq.n	8006896 <strspn+0x26>
 8006880:	460a      	mov	r2, r1
 8006882:	e001      	b.n	8006888 <strspn+0x18>
 8006884:	429c      	cmp	r4, r3
 8006886:	d006      	beq.n	8006896 <strspn+0x26>
 8006888:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800688c:	2b00      	cmp	r3, #0
 800688e:	d1f9      	bne.n	8006884 <strspn+0x14>
 8006890:	1a28      	subs	r0, r5, r0
 8006892:	bc70      	pop	{r4, r5, r6}
 8006894:	4770      	bx	lr
 8006896:	f815 4f01 	ldrb.w	r4, [r5, #1]!
 800689a:	2c00      	cmp	r4, #0
 800689c:	d1ed      	bne.n	800687a <strspn+0xa>
 800689e:	e7f7      	b.n	8006890 <strspn+0x20>
 80068a0:	4620      	mov	r0, r4
 80068a2:	e7f6      	b.n	8006892 <strspn+0x22>
	...
 80068b0:	656c6469 	.word	0x656c6469
	...

080068c0 <ch_debug>:
 80068c0:	6e69616d 18001600 08440404 1814100c     main......D.....
 80068d0:	1e1d1c00 00000000 00000000 00000000     ................

080068e0 <vmt>:
 80068e0:	08001fc1 08001fa1 08002001 08001fe1     ......... ......
 80068f0:	08001ff1 08001fd1 08001fb1 08001f91     ................

08006900 <zero_status>:
	...

08006910 <active_status>:
	...

08006920 <halted_status>:
 8006920:	00000001 00000000 00000000 00000000     ................

08006930 <_stm32_dma_streams>:
 8006930:	40020008 40020004 000b0000 4002001c     ...@...@.......@
 8006940:	40020004 000c0104 40020030 40020004     ...@....0..@...@
 8006950:	000d0208 40020044 40020004 000e030c     ....D..@...@....
 8006960:	40020058 40020004 000f0410 4002006c     X..@...@....l..@
 8006970:	40020004 00100514 40020080 40020004     ...@.......@...@
 8006980:	00110618 40020408 40020404 00380700     .......@...@..8.
 8006990:	4002041c 40020404 00390804 40020430     ...@...@..9.0..@
 80069a0:	40020404 003a0908 40020444 40020404     ...@..:.D..@...@
 80069b0:	003b0a0c 40020458 40020404 003c0b10     ..;.X..@...@..<.

080069c0 <default_config>:
 80069c0:	00002580 00000000 00004000 00000000     .%.......@......

080069d0 <ep0config>:
 80069d0:	00000000 08002221 08002551 08002611     ....!"..Q%...&..
 80069e0:	00400040 2000129c 2000129c 00000001     @.@.... ... ....
 80069f0:	200012b0 00000000 00000000 00000000     ... ............

08006a00 <CSWTCH.32>:
 8006a00:	00000400 00000600 00000000 00000000     ................

08006a10 <pal_default_config>:
 8006a10:	2a80a800 00000000 3cc0fc00 64151154     ...*.......<T..d
 8006a20:	0000ffff 55500000 000ee000 0000a080     ......PU........
 8006a30:	000000c0 0000f0c0 55550515 0000ffff     ..........UU....
 8006a40:	44000000 00000000 00000000 00000000     ...D............
 8006a50:	f0000000 05555555 0000ffff 00000000     ....UUU.........
	...
 8006a70:	55555555 0000ffff 00000000 00000000     UUUU............
 8006a80:	55550040 00000000 ffff00c0 01155515     @.UU.........U..
 8006a90:	000000ff 00000000 00000000 00000000     ................
 8006aa0:	00000000 0000000f 55555550 0000ffff     ........PUUU....
	...
 8006ac0:	67617355 25203a65 000a0d73 74737973     Usage: %s...syst
 8006ad0:	00656d69 0d756c25 0000000a 6f666e69     ime.%lu.....info
 8006ae0:	00000000 6e72654b 203a6c65 20202020     ....Kernel:     
 8006af0:	73252020 00000a0d 2e302e33 76656430       %s....3.0.0dev
 8006b00:	00000000 706d6f43 72656c69 2020203a     ....Compiler:   
 8006b10:	73252020 00000a0d 20434347 2e392e34       %s....GCC 4.9.
 8006b20:	30322033 31313431 28203931 656c6572     3 20141119 (rele
 8006b30:	29657361 52415b20 6d652f4d 64646562     ase) [ARM/embedd
 8006b40:	342d6465 622d395f 636e6172 65722068     ed-4_9-branch re
 8006b50:	69736976 32206e6f 37323831 00005d38     vision 218278]..
 8006b60:	68637241 63657469 65727574 7325203a     Architecture: %s
 8006b70:	00000a0d 764d5241 454d2d37 00000000     ....ARMv7-ME....
 8006b80:	65726f43 72615620 746e6169 7325203a     Core Variant: %s
 8006b90:	00000a0d 74726f43 4d2d7865 00004634     ....Cortex-M4F..
 8006ba0:	74726f50 666e4920 20203a6f 73252020     Port Info:    %s
 8006bb0:	00000a0d 61766441 6465636e 72656b20     ....Advanced ker
 8006bc0:	206c656e 65646f6d 00000000 74616c50     nel mode....Plat
 8006bd0:	6d726f66 2020203a 73252020 00000a0d     form:     %s....
 8006be0:	334d5453 30334632 20437833 6c616e41     STM32F303xC Anal
 8006bf0:	2620676f 50534420 00000000 72616f42     og & DSP....Boar
 8006c00:	20203a64 20202020 73252020 00000a0d     d:        %s....
 8006c10:	694d5453 656f7263 7463656c 696e6f72     STMicroelectroni
 8006c20:	53207363 32334d54 442d3346 6f637369     cs STM32F3-Disco
 8006c30:	79726576 00000000 6c697542 69742064     very....Build ti
 8006c40:	203a656d 73252020 73257325 00000a0d     me:   %s%s%s....
 8006c50:	2079614d 32203420 00353130 00202d20     May  4 2015. - .
 8006c60:	303a3431 31333a33 00000000 00000920     14:03:31.... ...
 8006c70:	0000445e 6c656873 0000006c 68430a0d     ^D..shell.....Ch
 8006c80:	4f696269 54522f53 65685320 0a0d6c6c     ibiOS/RT Shell..
 8006c90:	00000000 203e6863 00000000 6f6c0a0d     ....ch> ......lo
 8006ca0:	74756f67 00000000 206f6f74 796e616d     gout....too many
 8006cb0:	67726120 6e656d75 0a0d7374 00000000      arguments......
 8006cc0:	74697865 00000000 706c6568 00000000     exit....help....
 8006cd0:	6d6d6f43 73646e61 6568203a 6520706c     Commands: help e
 8006ce0:	20746978 00000000 00207325 00007325     xit ....%s .%s..
 8006cf0:	0a0d3f20 00000000 00000000 00000000      ?..............
 8006d00:	6c756e28 0000296c 00000000 00000000     (null)..........
 8006d10:	006e616e 00666e69 00000000 00000000     nan.inf.........

08006d20 <daccfg1>:
	...

08006d30 <commands>:
 8006d30:	08006e70 08004931 08006e78 08004b91     pn..1I..xn...K..
 8006d40:	08006e7c 08004a01 08006e84 08004a61     |n...J...n..aJ..
 8006d50:	08006e88 08004961 00000000 00000000     .n..aI..........
 8006d60:	6c656853 6944206c 0d0a6465 00000000     Shell Died......
 8006d70:	74736552 69747261 6620676e 206d6f72     Restarting from 
 8006d80:	6d726574 74616e69 206e6f69 646e6168     termination hand
 8006d90:	0a72656c 0000000d 0d0a7325 00000000     ler.....%s......
 8006da0:	30257830 00002078 0d0a7325 00000020     0x%0x ..%s.. ...
 8006db0:	30257830 00207834 002c6425 6f727245     0x%04x .%d,.Erro
 8006dc0:	77203a72 676e6f72 6d756e20 20726562     r: wrong number 
 8006dd0:	6120666f 6d756772 73746e65 6425202e     of arguments. %d
 8006de0:	6f727020 65646976 450d0a64 706d6178      provided..Examp
 8006df0:	203a656c 20636164 0a464633 0000000d     le: dac 3FF.....
 8006e00:	756c6156 72452065 3a726f72 3e203020     Value Error: 0 >
 8006e10:	6176203d 2065756c 30203d3c 46464678     = value <= 0xFFF
 8006e20:	6156203a 2065756c 766f7270 64656469     : Value provided
 8006e30:	25783020 000d0a78 746f7257 78302065      0x%x...Wrote 0x
 8006e40:	74207825 6164206f 0a312063 0000000d     %x to dac 1.....
 8006e50:	686f7461 72726520 203a726f 6e6e6163     atoh error: cann
 8006e60:	6320746f 65766e6f 25207472 000d0a73     ot convert %s...
 8006e70:	6365796d 00006f68 00636164 706d6173     myecho..dac.samp
 8006e80:	0000656c 00007774 6c6c6f63 00746365     le..tw..collect.

08006e90 <adcgrpcfg>:
 8006e90:	00020000 00000000 00000000 00000000     ................
	...
 8006ea8:	000000d8 00000000 00002041 00000000     ........A ......
	...

08006ec0 <shell_cfg1>:
 8006ec0:	2000119c 08006d30 00000000 00000000     ... 0m..........
 8006ed0:	31676f6c 00000030 00000000 00000000     log10...........
 8006ee0:	00776f70 00000000 00000000 00000000     pow.............

08006ef0 <dp_h>:
	...
 8006ef8:	40000000 3fe2b803                       ...@...?

08006f00 <dp_l>:
	...
 8006f08:	43cfd006 3e4cfdeb                       ...C..L>

08006f10 <bp>:
 8006f10:	00000000 3ff00000 00000000 3ff80000     .......?.......?

08006f20 <TWO52>:
 8006f20:	00000000 43300000 00000000 c3300000     ......0C......0.
 8006f30:	00000043 00000000 00000000 00000000     C...............

08006f40 <_ctype_>:
 8006f40:	20202000 20202020 28282020 20282828     .         ((((( 
 8006f50:	20202020 20202020 20202020 20202020                     
 8006f60:	10108820 10101010 10101010 10101010      ...............
 8006f70:	04040410 04040404 10040404 10101010     ................
 8006f80:	41411010 41414141 01010101 01010101     ..AAAAAA........
 8006f90:	01010101 01010101 01010101 10101010     ................
 8006fa0:	42421010 42424242 02020202 02020202     ..BBBBBB........
 8006fb0:	02020202 02020202 02020202 10101010     ................
 8006fc0:	00000020 00000000 00000000 00000000      ...............
	...
